{
  "plotly.animation.DurationValidator.description": {
    "name": "plotly_animation_DurationValidator_description",
    "description": "执行description操作（DurationValidator类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.animation.DurationValidator.description",
      "module": "plotly.animation",
      "class_name": "DurationValidator",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.animation.DurationValidator.present": {
    "name": "plotly_animation_DurationValidator_present",
    "description": "Convert output value of a previous call to `validate_coerce` into a\nform suitable to be returned to the user on upon property\naccess.\n\nNote: The value returned by present must be either immutable or an\ninstance of BasePlotlyType, otherwise the value could be mutated by\nthe user and we wouldn't get notified about the change.\n\nParameters\n----------\nv\nA value that was the ouput of a previous call the\n`validate_coerce` method on the same object\n\nReturns\n-------",
    "inputSchema": {
      "type": "object",
      "properties": {
        "v": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "v"
      ]
    },
    "metadata": {
      "source_function": "plotly.animation.DurationValidator.present",
      "module": "plotly.animation",
      "class_name": "DurationValidator",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.animation.DurationValidator.raise_invalid_elements": {
    "name": "plotly_animation_DurationValidator_raise_invalid_elements",
    "description": "执行raise_invalid_elements操作（DurationValidator类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "invalid_els": {
          "type": "integer",
          "description": "类型从参数名推断: invalid_els"
        }
      },
      "required": [
        "invalid_els"
      ]
    },
    "metadata": {
      "source_function": "plotly.animation.DurationValidator.raise_invalid_elements",
      "module": "plotly.animation",
      "class_name": "DurationValidator",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.animation.DurationValidator.raise_invalid_val": {
    "name": "plotly_animation_DurationValidator_raise_invalid_val",
    "description": "Helper method to raise an informative exception when an invalid\nvalue is passed to the validate_coerce method.\nParameters\n----------\nv :\nValue that was input to validate_coerce and could not be coerced\ninds: list of int or None (default)\nIndexes to display after property name. e.g. if self.plotly_name\nis 'prop' and inds=[2, 1] then the name in the validation error\nmessage will be 'prop[2][1]`\nRaises\n-------\nValueError",
    "inputSchema": {
      "type": "object",
      "properties": {
        "v": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "inds": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "v"
      ]
    },
    "metadata": {
      "source_function": "plotly.animation.DurationValidator.raise_invalid_val",
      "module": "plotly.animation",
      "class_name": "DurationValidator",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.animation.DurationValidator.validate_coerce": {
    "name": "plotly_animation_DurationValidator_validate_coerce",
    "description": "验证数据（DurationValidator类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "v": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "v"
      ]
    },
    "metadata": {
      "source_function": "plotly.animation.DurationValidator.validate_coerce",
      "module": "plotly.animation",
      "class_name": "DurationValidator",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.animation.EasingValidator.build_regex_replacement": {
    "name": "plotly_animation_EasingValidator_build_regex_replacement",
    "description": "执行build_regex_replacement操作（EasingValidator类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "regex_str": {
          "type": "string",
          "description": "类型从参数名推断: regex_str"
        }
      },
      "required": [
        "regex_str"
      ]
    },
    "metadata": {
      "source_function": "plotly.animation.EasingValidator.build_regex_replacement",
      "module": "plotly.animation",
      "class_name": "EasingValidator",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.animation.EasingValidator.description": {
    "name": "plotly_animation_EasingValidator_description",
    "description": "执行description操作（EasingValidator类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.animation.EasingValidator.description",
      "module": "plotly.animation",
      "class_name": "EasingValidator",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.animation.EasingValidator.in_values": {
    "name": "plotly_animation_EasingValidator_in_values",
    "description": "Return whether a value matches one of the enumeration options",
    "inputSchema": {
      "type": "object",
      "properties": {
        "e": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "e"
      ]
    },
    "metadata": {
      "source_function": "plotly.animation.EasingValidator.in_values",
      "module": "plotly.animation",
      "class_name": "EasingValidator",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.animation.EasingValidator.perform_replacemenet": {
    "name": "plotly_animation_EasingValidator_perform_replacemenet",
    "description": "Return v with any applicable regex replacements applied",
    "inputSchema": {
      "type": "object",
      "properties": {
        "v": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "v"
      ]
    },
    "metadata": {
      "source_function": "plotly.animation.EasingValidator.perform_replacemenet",
      "module": "plotly.animation",
      "class_name": "EasingValidator",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.animation.EasingValidator.present": {
    "name": "plotly_animation_EasingValidator_present",
    "description": "Convert output value of a previous call to `validate_coerce` into a\nform suitable to be returned to the user on upon property\naccess.\n\nNote: The value returned by present must be either immutable or an\ninstance of BasePlotlyType, otherwise the value could be mutated by\nthe user and we wouldn't get notified about the change.\n\nParameters\n----------\nv\nA value that was the ouput of a previous call the\n`validate_coerce` method on the same object\n\nReturns\n-------",
    "inputSchema": {
      "type": "object",
      "properties": {
        "v": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "v"
      ]
    },
    "metadata": {
      "source_function": "plotly.animation.EasingValidator.present",
      "module": "plotly.animation",
      "class_name": "EasingValidator",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.animation.EasingValidator.raise_invalid_elements": {
    "name": "plotly_animation_EasingValidator_raise_invalid_elements",
    "description": "执行raise_invalid_elements操作（EasingValidator类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "invalid_els": {
          "type": "integer",
          "description": "类型从参数名推断: invalid_els"
        }
      },
      "required": [
        "invalid_els"
      ]
    },
    "metadata": {
      "source_function": "plotly.animation.EasingValidator.raise_invalid_elements",
      "module": "plotly.animation",
      "class_name": "EasingValidator",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.animation.EasingValidator.raise_invalid_val": {
    "name": "plotly_animation_EasingValidator_raise_invalid_val",
    "description": "Helper method to raise an informative exception when an invalid\nvalue is passed to the validate_coerce method.\nParameters\n----------\nv :\nValue that was input to validate_coerce and could not be coerced\ninds: list of int or None (default)\nIndexes to display after property name. e.g. if self.plotly_name\nis 'prop' and inds=[2, 1] then the name in the validation error\nmessage will be 'prop[2][1]`\nRaises\n-------\nValueError",
    "inputSchema": {
      "type": "object",
      "properties": {
        "v": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "inds": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "v"
      ]
    },
    "metadata": {
      "source_function": "plotly.animation.EasingValidator.raise_invalid_val",
      "module": "plotly.animation",
      "class_name": "EasingValidator",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.animation.EasingValidator.validate_coerce": {
    "name": "plotly_animation_EasingValidator_validate_coerce",
    "description": "验证数据（EasingValidator类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "v": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "v"
      ]
    },
    "metadata": {
      "source_function": "plotly.animation.EasingValidator.validate_coerce",
      "module": "plotly.animation",
      "class_name": "EasingValidator",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.add_hline": {
    "name": "plotly_basedatatypes_BaseFigure_add_hline",
    "description": "Add a horizontal line to a plot or subplot that extends infinitely in the\nx-dimension.\nParameters\n----------\ny: float or int\nA number representing the y coordinate of the horizontal line.\nexclude_empty_subplots: Boolean\nIf True (default) do not place the shape on subplots that have no data\nplotted on them.\nrow: None, int or 'all'\nSubplot row for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\ncol: None, int or 'all'\nSubplot column for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\nannotation: dict or plotly.graph_objects.layout.Annotation. If dict(),\nit is interpreted as describing an annotation. The annotation is\nplaced relative to the shape based on annotation_position (see\nbelow) unless its x or y value has been specified for the annotation\npassed here. xref and yref are always the same as for the added\nshape and cannot be overridden.\nannotation_position: a string containing optionally [\"top\", \"bottom\"]\nand [\"left\", \"right\"] specifying where the text should be anchored\nto on the line. Example positions are \"bottom left\", \"right top\",\n\"right\", \"bottom\". If an annotation is added but annotation_position is\nnot specified, this defaults to \"top right\".\nannotation_*: any parameters to go.layout.Annotation can be passed as\nkeywords by prefixing them with \"annotation_\". For example, to specify the\nannotation text \"example\" you can pass annotation_text=\"example\" as a\nkeyword argument.\n**kwargs:\nAny named function parameters that can be passed to 'add_shape',\nexcept for x0, x1, y0, y1 or type.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "col": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "annotation": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "y",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.add_hline",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.add_hrect": {
    "name": "plotly_basedatatypes_BaseFigure_add_hrect",
    "description": "Add a rectangle to a plot or subplot that extends infinitely in the\nx-dimension.\nParameters\n----------\ny0: float or int\nA number representing the y coordinate of one side of the rectangle.\ny1: float or int\nA number representing the y coordinate of the other side of the rectangle.\nexclude_empty_subplots: Boolean\nIf True (default) do not place the shape on subplots that have no data\nplotted on them.\nrow: None, int or 'all'\nSubplot row for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\ncol: None, int or 'all'\nSubplot column for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\nannotation: dict or plotly.graph_objects.layout.Annotation. If dict(),\nit is interpreted as describing an annotation. The annotation is\nplaced relative to the shape based on annotation_position (see\nbelow) unless its x or y value has been specified for the annotation\npassed here. xref and yref are always the same as for the added\nshape and cannot be overridden.\nannotation_position: a string containing optionally [\"inside\", \"outside\"], [\"top\", \"bottom\"]\nand [\"left\", \"right\"] specifying where the text should be anchored\nto on the rectangle. Example positions are \"outside top left\", \"inside\nbottom\", \"right\", \"inside left\", \"inside\" (\"outside\" is not supported). If\nan annotation is added but annotation_position is not specified this\ndefaults to \"inside top right\".\nannotation_*: any parameters to go.layout.Annotation can be passed as\nkeywords by prefixing them with \"annotation_\". For example, to specify the\nannotation text \"example\" you can pass annotation_text=\"example\" as a\nkeyword argument.\n**kwargs:\nAny named function parameters that can be passed to 'add_shape',\nexcept for x0, x1, y0, y1 or type.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "y0": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "col": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "annotation": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "y0",
        "y1",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.add_hrect",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.add_trace": {
    "name": "plotly_basedatatypes_BaseFigure_add_trace",
    "description": "Add a trace to the figure\nParameters\n----------\ntrace : BaseTraceType or dict\nEither:\n- An instances of a trace classe from the plotly.graph_objs\npackage (e.g plotly.graph_objs.Scatter, plotly.graph_objs.Bar)\n- or a dicts where:\n- The 'type' property specifies the trace type (e.g.\n'scatter', 'bar', 'area', etc.). If the dict has no 'type'\nproperty then 'scatter' is assumed.\n- All remaining properties are passed to the constructor\nof the specified trace type.\nrow : 'all', int or None (default)\nSubplot row index (starting from 1) for the trace to be\nadded. Only valid if figure was created using\n`plotly.tools.make_subplots`.\nIf 'all', addresses all rows in the specified column(s).\ncol : 'all', int or None (default)\nSubplot col index (starting from 1) for the trace to be\nadded. Only valid if figure was created using\n`plotly.tools.make_subplots`.\nIf 'all', addresses all columns in the specified row(s).\nsecondary_y: boolean or None (default None)\nIf True, associate this trace with the secondary y-axis of the\nsubplot at the specified row and col. Only valid if all of the\nfollowing conditions are satisfied:\n* The figure was created using `plotly.subplots.make_subplots`.\n* The row and col arguments are not None\n* The subplot at the specified row and col has type xy\n(which is the default) and secondary_y True.  These\nproperties are specified in the specs argument to\nmake_subplots. See the make_subplots docstring for more info.\n* The trace argument is a 2D cartesian trace\n(scatter, bar, etc.)\nexclude_empty_subplots: boolean\nIf True, the trace will not be added to subplots that don't already\nhave traces.\nReturns\n-------\nBaseFigure\nThe Figure that add_trace was called on\nExamples\n--------\n>>> from plotly import subplots\n>>> import plotly.graph_objs as go\nAdd two Scatter traces to a figure\n>>> fig = go.Figure()\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2])) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2])) # doctest: +ELLIPSIS\nFigure(...)\nAdd two Scatter traces to vertically stacked subplots\n>>> fig = subplots.make_subplots(rows=2)\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=1, col=1) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=2, col=1) # doctest: +ELLIPSIS\nFigure(...)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "trace": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "trace"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.add_trace",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.add_traces": {
    "name": "plotly_basedatatypes_BaseFigure_add_traces",
    "description": "Add traces to the figure\nParameters\n----------\ndata : list[BaseTraceType or dict]\nA list of trace specifications to be added.\nTrace specifications may be either:\n- Instances of trace classes from the plotly.graph_objs\npackage (e.g plotly.graph_objs.Scatter, plotly.graph_objs.Bar)\n- Dicts where:\n- The 'type' property specifies the trace type (e.g.\n'scatter', 'bar', 'area', etc.). If the dict has no 'type'\nproperty then 'scatter' is assumed.\n- All remaining properties are passed to the constructor\nof the specified trace type.\nrows : None, list[int], or int (default None)\nList of subplot row indexes (starting from 1) for the traces to be\nadded. Only valid if figure was created using\n`plotly.tools.make_subplots`\nIf a single integer is passed, all traces will be added to row number\ncols : None or list[int] (default None)\nList of subplot column indexes (starting from 1) for the traces\nto be added. Only valid if figure was created using\n`plotly.tools.make_subplots`\nIf a single integer is passed, all traces will be added to column number\nsecondary_ys: None or list[boolean] (default None)\nList of secondary_y booleans for traces to be added. See the\ndocstring for `add_trace` for more info.\nexclude_empty_subplots: boolean\nIf True, the trace will not be added to subplots that don't already\nhave traces.\nReturns\n-------\nBaseFigure\nThe Figure that add_traces was called on\nExamples\n--------\n>>> from plotly import subplots\n>>> import plotly.graph_objs as go\nAdd two Scatter traces to a figure\n>>> fig = go.Figure()\n>>> fig.add_traces([go.Scatter(x=[1,2,3], y=[2,1,2]),\n...                 go.Scatter(x=[1,2,3], y=[2,1,2])]) # doctest: +ELLIPSIS\nFigure(...)\nAdd two Scatter traces to vertically stacked subplots\n>>> fig = subplots.make_subplots(rows=2)\n>>> fig.add_traces([go.Scatter(x=[1,2,3], y=[2,1,2]),\n...                 go.Scatter(x=[1,2,3], y=[2,1,2])],\n...                 rows=[1, 2], cols=[1, 1]) # doctest: +ELLIPSIS\nFigure(...)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "rows": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "cols": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_ys": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "data"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.add_traces",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.add_vline": {
    "name": "plotly_basedatatypes_BaseFigure_add_vline",
    "description": "Add a vertical line to a plot or subplot that extends infinitely in the\ny-dimension.\nParameters\n----------\nx: float or int\nA number representing the x coordinate of the vertical line.\nexclude_empty_subplots: Boolean\nIf True (default) do not place the shape on subplots that have no data\nplotted on them.\nrow: None, int or 'all'\nSubplot row for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\ncol: None, int or 'all'\nSubplot column for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\nannotation: dict or plotly.graph_objects.layout.Annotation. If dict(),\nit is interpreted as describing an annotation. The annotation is\nplaced relative to the shape based on annotation_position (see\nbelow) unless its x or y value has been specified for the annotation\npassed here. xref and yref are always the same as for the added\nshape and cannot be overridden.\nannotation_position: a string containing optionally [\"top\", \"bottom\"]\nand [\"left\", \"right\"] specifying where the text should be anchored\nto on the line. Example positions are \"bottom left\", \"right top\",\n\"right\", \"bottom\". If an annotation is added but annotation_position is\nnot specified, this defaults to \"top right\".\nannotation_*: any parameters to go.layout.Annotation can be passed as\nkeywords by prefixing them with \"annotation_\". For example, to specify the\nannotation text \"example\" you can pass annotation_text=\"example\" as a\nkeyword argument.\n**kwargs:\nAny named function parameters that can be passed to 'add_shape',\nexcept for x0, x1, y0, y1 or type.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "x": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "col": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "annotation": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "x",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.add_vline",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.add_vrect": {
    "name": "plotly_basedatatypes_BaseFigure_add_vrect",
    "description": "Add a rectangle to a plot or subplot that extends infinitely in the\ny-dimension.\nParameters\n----------\nx0: float or int\nA number representing the x coordinate of one side of the rectangle.\nx1: float or int\nA number representing the x coordinate of the other side of the rectangle.\nexclude_empty_subplots: Boolean\nIf True (default) do not place the shape on subplots that have no data\nplotted on them.\nrow: None, int or 'all'\nSubplot row for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\ncol: None, int or 'all'\nSubplot column for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\nannotation: dict or plotly.graph_objects.layout.Annotation. If dict(),\nit is interpreted as describing an annotation. The annotation is\nplaced relative to the shape based on annotation_position (see\nbelow) unless its x or y value has been specified for the annotation\npassed here. xref and yref are always the same as for the added\nshape and cannot be overridden.\nannotation_position: a string containing optionally [\"inside\", \"outside\"], [\"top\", \"bottom\"]\nand [\"left\", \"right\"] specifying where the text should be anchored\nto on the rectangle. Example positions are \"outside top left\", \"inside\nbottom\", \"right\", \"inside left\", \"inside\" (\"outside\" is not supported). If\nan annotation is added but annotation_position is not specified this\ndefaults to \"inside top right\".\nannotation_*: any parameters to go.layout.Annotation can be passed as\nkeywords by prefixing them with \"annotation_\". For example, to specify the\nannotation text \"example\" you can pass annotation_text=\"example\" as a\nkeyword argument.\n**kwargs:\nAny named function parameters that can be passed to 'add_shape',\nexcept for x0, x1, y0, y1 or type.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "x0": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "x1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "col": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "annotation": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "x0",
        "x1",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.add_vrect",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.append_trace": {
    "name": "plotly_basedatatypes_BaseFigure_append_trace",
    "description": "Add a trace to the figure bound to axes at the specified row,\ncol index.\nA row, col index grid is generated for figures created with\nplotly.tools.make_subplots, and can be viewed with the `print_grid`\nmethod\nParameters\n----------\ntrace\nThe data trace to be bound\nrow: int\nSubplot row index (see Figure.print_grid)\ncol: int\nSubplot column index (see Figure.print_grid)\nExamples\n--------\n>>> from plotly import tools\n>>> import plotly.graph_objs as go\n>>> # stack two subplots vertically\n>>> fig = tools.make_subplots(rows=2)\nThis is the format of your plot grid:\n[ (1,1) x1,y1 ]\n[ (2,1) x2,y2 ]\n>>> fig.append_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=1, col=1)\n>>> fig.append_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=2, col=1)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "trace": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "trace",
        "row",
        "col"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.append_trace",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.batch_animate": {
    "name": "plotly_basedatatypes_BaseFigure_batch_animate",
    "description": "Context manager to animate trace / layout updates\nParameters\n----------\nduration : number\nThe duration of the transition, in milliseconds.\nIf equal to zero, updates are synchronous.\neasing : string\nThe easing function used for the transition.\nOne of:\n- linear\n- quad\n- cubic\n- sin\n- exp\n- circle\n- elastic\n- back\n- bounce\n- linear-in\n- quad-in\n- cubic-in\n- sin-in\n- exp-in\n- circle-in\n- elastic-in\n- back-in\n- bounce-in\n- linear-out\n- quad-out\n- cubic-out\n- sin-out\n- exp-out\n- circle-out\n- elastic-out\n- back-out\n- bounce-out\n- linear-in-out\n- quad-in-out\n- cubic-in-out\n- sin-in-out\n- exp-in-out\n- circle-in-out\n- elastic-in-out\n- back-in-out\n- bounce-in-out\nExamples\n--------\nSuppose we have a figure widget, `fig`, with a single trace.\n>>> import plotly.graph_objs as go\n>>> fig = go.FigureWidget(data=[{'y': [3, 4, 2]}])\n1) Animate a change in the xaxis and yaxis ranges using default\nduration and easing parameters.\n>>> with fig.batch_animate():\n...     fig.layout.xaxis.range = [0, 5]\n...     fig.layout.yaxis.range = [0, 10]\n2) Animate a change in the size and color of the trace's markers\nover 2 seconds using the elastic-in-out easing method\n>>> with fig.batch_animate(duration=2000, easing='elastic-in-out'):\n...     fig.data[0].marker.color = 'green'\n...     fig.data[0].marker.size = 20",
    "inputSchema": {
      "type": "object",
      "properties": {
        "duration": {
          "type": "integer",
          "default": 500,
          "description": "类型从默认值推断: int"
        },
        "easing": {
          "type": "string",
          "default": "cubic-in-out",
          "description": "类型从默认值推断: str"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.batch_animate",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.batch_update": {
    "name": "plotly_basedatatypes_BaseFigure_batch_update",
    "description": "A context manager that batches up trace and layout assignment\noperations into a singe plotly_update message that is executed when\nthe context exits.\nExamples\n--------\nFor example, suppose we have a figure widget, `fig`, with a single\ntrace.\n>>> import plotly.graph_objs as go\n>>> fig = go.FigureWidget(data=[{'y': [3, 4, 2]}])\nIf we want to update the xaxis range, the yaxis range, and the\nmarker color, we could do so using a series of three property\nassignments as follows:\n>>> fig.layout.xaxis.range = [0, 5]\n>>> fig.layout.yaxis.range = [0, 10]\n>>> fig.data[0].marker.color = 'green'\nThis will work, however it will result in three messages being\nsent to the front end (two relayout messages for the axis range\nupdates followed by one restyle message for the marker color\nupdate). This can cause the plot to appear to stutter as the\nthree updates are applied incrementally.\nWe can avoid this problem by performing these three assignments in a\n`batch_update` context as follows:\n>>> with fig.batch_update():\n...     fig.layout.xaxis.range = [0, 5]\n...     fig.layout.yaxis.range = [0, 10]\n...     fig.data[0].marker.color = 'green'\nNow, these three property updates will be sent to the frontend in a\nsingle update message, and they will be applied by the front end\nsimultaneously.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.batch_update",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.for_each_trace": {
    "name": "plotly_basedatatypes_BaseFigure_for_each_trace",
    "description": "Apply a function to all traces that satisfy the specified selection\ncriteria\nParameters\n----------\nfn:\nFunction that inputs a single trace object.\nselector: dict, function, int, str or None (default None)\nDict to use as selection criteria.\nTraces will be selected if they contain properties corresponding\nto all of the dictionary's keys, with values that exactly match\nthe supplied values. If None (the default), all traces are\nselected. If a function, it must be a function accepting a single\nargument and returning a boolean. The function will be called on\neach trace and those for which the function returned True\nwill be in the selection. If an int N, the Nth trace matching row\nand col will be selected (N can be negative). If a string S, the selector\nis equivalent to dict(type=S).\nrow, col: int or None (default None)\nSubplot row and column index of traces to select.\nTo select traces by row and column, the Figure must have been\ncreated using plotly.subplots.make_subplots.  If None\n(the default), all traces are selected.\nsecondary_y: boolean or None (default None)\n* If True, only select traces associated with the secondary\ny-axis of the subplot.\n* If False, only select traces associated with the primary\ny-axis of the subplot.\n* If None (the default), do not filter traces based on secondary\ny-axis.\nTo select traces by secondary y-axis, the Figure must have been\ncreated using plotly.subplots.make_subplots. See the docstring\nfor the specs argument to make_subplots for more info on\ncreating subplots with secondary y-axes.\nReturns\n-------\nself\nReturns the Figure object that the method was called on",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fn": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "selector": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fn"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.for_each_trace",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.full_figure_for_development": {
    "name": "plotly_basedatatypes_BaseFigure_full_figure_for_development",
    "description": "Compute default values for all attributes not specified in the input figure and\nreturns the output as a \"full\" figure. This function calls Plotly.js via Kaleido\nto populate unspecified attributes. This function is intended for interactive use\nduring development to learn more about how Plotly.js computes default values and is\nnot generally necessary or recommended for production use.\nParameters\n----------\nfig:\nFigure object or dict representing a figure\nwarn: bool\nIf False, suppress warnings about not using this in production.\nas_dict: bool\nIf True, output is a dict with some keys that go.Figure can't parse.\nIf False, output is a go.Figure with unparseable keys skipped.\nReturns\n-------\nplotly.graph_objects.Figure or dict\nThe full figure",
    "inputSchema": {
      "type": "object",
      "properties": {
        "warn": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "as_dict": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.full_figure_for_development",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.get_subplot": {
    "name": "plotly_basedatatypes_BaseFigure_get_subplot",
    "description": "Return an object representing the subplot at the specified row\nand column.  May only be used on Figures created using\nplotly.tools.make_subplots\nParameters\n----------\nrow: int\n1-based index of subplot row\ncol: int\n1-based index of subplot column\nsecondary_y: bool\nIf True, select the subplot that consists of the x-axis and the\nsecondary y-axis at the specified row/col. Only valid if the\nsubplot at row/col is an 2D cartesian subplot that was created\nwith a secondary y-axis.  See the docstring for the specs argument\nto make_subplots for more info on creating a subplot with a\nsecondary y-axis.\nReturns\n-------\nsubplot\n* None: if subplot is empty\n* plotly.graph_objs.layout.Scene: if subplot type is 'scene'\n* plotly.graph_objs.layout.Polar: if subplot type is 'polar'\n* plotly.graph_objs.layout.Ternary: if subplot type is 'ternary'\n* plotly.graph_objs.layout.Mapbox: if subplot type is 'ternary'\n* SubplotDomain namedtuple with `x` and `y` fields:\nif subplot type is 'domain'.\n- x: length 2 list of the subplot start and stop width\n- y: length 2 list of the subplot start and stop height\n* SubplotXY namedtuple with `xaxis` and `yaxis` fields:\nif subplot type is 'xy'.\n- xaxis: plotly.graph_objs.layout.XAxis instance for subplot\n- yaxis: plotly.graph_objs.layout.YAxis instance for subplot",
    "inputSchema": {
      "type": "object",
      "properties": {
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "row",
        "col"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.get_subplot",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.plotly_relayout": {
    "name": "plotly_basedatatypes_BaseFigure_plotly_relayout",
    "description": "Perform a Plotly relayout operation on the figure's layout\nParameters\n----------\nrelayout_data : dict\nDict of layout updates\ndict keys are strings that specify the properties to be updated.\nNested properties are expressed by joining successive keys on\n'.' characters (e.g. 'xaxis.range')\ndict values are the values to use to update the layout.\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "relayout_data": {
          "type": "object",
          "description": "类型从参数名推断: relayout_data"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "relayout_data",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.plotly_relayout",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.plotly_restyle": {
    "name": "plotly_basedatatypes_BaseFigure_plotly_restyle",
    "description": "Perform a Plotly restyle operation on the figure's traces\nParameters\n----------\nrestyle_data : dict\nDict of trace style updates.\nKeys are strings that specify the properties to be updated.\nNested properties are expressed by joining successive keys on\n'.' characters (e.g. 'marker.color').\nValues may be scalars or lists. When values are scalars,\nthat scalar value is applied to all traces specified by the\n`trace_indexes` parameter.  When values are lists,\nthe restyle operation will cycle through the elements\nof the list as it cycles through the traces specified by the\n`trace_indexes` parameter.\nCaution: To use plotly_restyle to update a list property (e.g.\nthe `x` property of the scatter trace), the property value\nshould be a scalar list containing the list to update with. For\nexample, the following command would be used to update the 'x'\nproperty of the first trace to the list [1, 2, 3]\n>>> import plotly.graph_objects as go\n>>> fig = go.Figure(go.Scatter(x=[2, 4, 6]))\n>>> fig.plotly_restyle({'x': [[1, 2, 3]]}, 0)\ntrace_indexes : int or list of int\nTrace index, or list of trace indexes, that the restyle operation\napplies to. Defaults to all trace indexes.\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "restyle_data": {
          "type": "object",
          "description": "类型从参数名推断: restyle_data"
        },
        "trace_indexes": {
          "type": "integer",
          "description": "类型从参数名推断: trace_indexes"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "restyle_data",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.plotly_restyle",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.plotly_update": {
    "name": "plotly_basedatatypes_BaseFigure_plotly_update",
    "description": "Perform a Plotly update operation on the figure.\n\nNote: This operation both mutates and returns the figure\n\nParameters\n----------\nrestyle_data : dict\nTraces update specification. See the docstring for the\n`plotly_restyle` method for details\nrelayout_data : dict\nLayout update specification. See the docstring for the\n`plotly_relayout` method for details\ntrace_indexes :\nTrace index, or list of trace indexes, that the update operation\napplies to. Defaults to all trace indexes.\n\nReturns\n-------\nBaseFigure\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "restyle_data": {
          "type": "object",
          "description": "类型从参数名推断: restyle_data"
        },
        "relayout_data": {
          "type": "object",
          "description": "类型从参数名推断: relayout_data"
        },
        "trace_indexes": {
          "type": "integer",
          "description": "类型从参数名推断: trace_indexes"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.plotly_update",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.pop": {
    "name": "plotly_basedatatypes_BaseFigure_pop",
    "description": "Remove the value associated with the specified key and return it\nParameters\n----------\nkey: str\nProperty name\ndflt\nThe default value to return if key was not found in figure\nReturns\n-------\nvalue\nThe removed value that was previously associated with key\nRaises\n------\nKeyError\nIf key is not in object and no dflt argument specified",
    "inputSchema": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "key",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.pop",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.print_grid": {
    "name": "plotly_basedatatypes_BaseFigure_print_grid",
    "description": "Print a visual layout of the figure's axes arrangement.\nThis is only valid for figures that are created\nwith plotly.tools.make_subplots.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.print_grid",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.select_traces": {
    "name": "plotly_basedatatypes_BaseFigure_select_traces",
    "description": "Select traces from a particular subplot cell and/or traces\nthat satisfy custom selection criteria.\nParameters\n----------\nselector: dict, function, int, str or None (default None)\nDict to use as selection criteria.\nTraces will be selected if they contain properties corresponding\nto all of the dictionary's keys, with values that exactly match\nthe supplied values. If None (the default), all traces are\nselected. If a function, it must be a function accepting a single\nargument and returning a boolean. The function will be called on\neach trace and those for which the function returned True\nwill be in the selection. If an int N, the Nth trace matching row\nand col will be selected (N can be negative). If a string S, the selector\nis equivalent to dict(type=S).\nrow, col: int or None (default None)\nSubplot row and column index of traces to select.\nTo select traces by row and column, the Figure must have been\ncreated using plotly.subplots.make_subplots.  If None\n(the default), all traces are selected.\nsecondary_y: boolean or None (default None)\n* If True, only select traces associated with the secondary\ny-axis of the subplot.\n* If False, only select traces associated with the primary\ny-axis of the subplot.\n* If None (the default), do not filter traces based on secondary\ny-axis.\nTo select traces by secondary y-axis, the Figure must have been\ncreated using plotly.subplots.make_subplots. See the docstring\nfor the specs argument to make_subplots for more info on\ncreating subplots with secondary y-axes.\nReturns\n-------\ngenerator\nGenerator that iterates through all of the traces that satisfy\nall of the specified selection criteria",
    "inputSchema": {
      "type": "object",
      "properties": {
        "selector": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.select_traces",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.set_subplots": {
    "name": "plotly_basedatatypes_BaseFigure_set_subplots",
    "description": "Add subplots to this figure. If the figure already contains subplots,\nthen this throws an error. Accepts any keyword arguments that\nplotly.subplots.make_subplots accepts.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "rows": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "cols": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "make_subplots_args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "make_subplots_args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.set_subplots",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.show": {
    "name": "plotly_basedatatypes_BaseFigure_show",
    "description": "Show a figure using either the default renderer(s) or the renderer(s)\nspecified by the renderer argument\nParameters\n----------\nrenderer: str or None (default None)\nA string containing the names of one or more registered renderers\n(separated by '+' characters) or None.  If None, then the default\nrenderers specified in plotly.io.renderers.default are used.\nvalidate: bool (default True)\nTrue if the figure should be validated before being shown,\nFalse otherwise.\nwidth: int or float\nAn integer or float that determines the number of pixels wide the\nplot is. The default is set in plotly.js.\nheight: int or float\nAn integer or float that determines the number of pixels wide the\nplot is. The default is set in plotly.js.\nconfig: dict\nA dict of parameters to configure the figure. The defaults are set\nin plotly.js.\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.show",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.to_dict": {
    "name": "plotly_basedatatypes_BaseFigure_to_dict",
    "description": "Convert figure to a dictionary\n\nNote: the dictionary includes the properties explicitly set by the\nuser, it does not include default values of unspecified properties\n\nReturns\n-------\ndict",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.to_dict",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.to_html": {
    "name": "plotly_basedatatypes_BaseFigure_to_html",
    "description": "Convert a figure to an HTML string representation.\nParameters\n----------\nconfig: dict or None (default None)\nPlotly.js figure config options\nauto_play: bool (default=True)\nWhether to automatically start the animation sequence on page load\nif the figure contains frames. Has no effect if the figure does not\ncontain frames.\ninclude_plotlyjs: bool or string (default True)\nSpecifies how the plotly.js library is included/loaded in the output\ndiv string.\nIf True, a script tag containing the plotly.js source code (~3MB)\nis included in the output.  HTML files generated with this option are\nfully self-contained and can be used offline.\nIf 'cdn', a script tag that references the plotly.js CDN is included\nin the output. HTML files generated with this option are about 3MB\nsmaller than those generated with include_plotlyjs=True, but they\nrequire an active internet connection in order to load the plotly.js\nlibrary.\nIf 'directory', a script tag is included that references an external\nplotly.min.js bundle that is assumed to reside in the same\ndirectory as the HTML file.\nIf 'require', Plotly.js is loaded using require.js.  This option\nassumes that require.js is globally available and that it has been\nglobally configured to know how to find Plotly.js as 'plotly'.\nThis option is not advised when full_html=True as it will result\nin a non-functional html file.\nIf a string that ends in '.js', a script tag is included that\nreferences the specified path. This approach can be used to point\nthe resulting HTML file to an alternative CDN or local bundle.\nIf False, no script tag referencing plotly.js is included. This is\nuseful when the resulting div string will be placed inside an HTML\ndocument that already loads plotly.js. This option is not advised\nwhen full_html=True as it will result in a non-functional html file.\ninclude_mathjax: bool or string (default False)\nSpecifies how the MathJax.js library is included in the output html\ndiv string.  MathJax is required in order to display labels\nwith LaTeX typesetting.\nIf False, no script tag referencing MathJax.js will be included in the\noutput.\nIf 'cdn', a script tag that references a MathJax CDN location will be\nincluded in the output.  HTML div strings generated with this option\nwill be able to display LaTeX typesetting as long as internet access\nis available.\nIf a string that ends in '.js', a script tag is included that\nreferences the specified path. This approach can be used to point the\nresulting HTML div string to an alternative CDN.\npost_script: str or list or None (default None)\nJavaScript snippet(s) to be included in the resulting div just after\nplot creation.  The string(s) may include '{plot_id}' placeholders\nthat will then be replaced by the `id` of the div element that the\nplotly.js figure is associated with.  One application for this script\nis to install custom plotly.js event handlers.\nfull_html: bool (default True)\nIf True, produce a string containing a complete HTML document\nstarting with an <html> tag.  If False, produce a string containing\na single <div> element.\nanimation_opts: dict or None (default None)\ndict of custom animation parameters to be passed to the function\nPlotly.animate in Plotly.js. See\nhttps://github.com/plotly/plotly.js/blob/master/src/plots/animation_attributes.js\nfor available options. Has no effect if the figure does not contain\nframes, or auto_play is False.\ndefault_width, default_height: number or str (default '100%')\nThe default figure width/height to use if the provided figure does not\nspecify its own layout.width/layout.height property.  May be\nspecified in pixels as an integer (e.g. 500), or as a css width style\nstring (e.g. '500px', '100%').\nvalidate: bool (default True)\nTrue if the figure should be validated before being converted to\nJSON, False otherwise.\ndiv_id: str (default None)\nIf provided, this is the value of the id attribute of the div tag. If None, the\nid attribute is a UUID.\nReturns\n-------\nstr\nRepresentation of figure as an HTML div string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.to_html",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.to_image": {
    "name": "plotly_basedatatypes_BaseFigure_to_image",
    "description": "Convert a figure to a static image bytes string\nParameters\n----------\nformat: str or None\nThe desired image format. One of\n- 'png'\n- 'jpg' or 'jpeg'\n- 'webp'\n- 'svg'\n- 'pdf'\n- 'eps' (Requires the poppler library to be installed)\nIf not specified, will default to `plotly.io.config.default_format`\nwidth: int or None\nThe width of the exported image in layout pixels. If the `scale`\nproperty is 1.0, this will also be the width of the exported image\nin physical pixels.\nIf not specified, will default to `plotly.io.config.default_width`\nheight: int or None\nThe height of the exported image in layout pixels. If the `scale`\nproperty is 1.0, this will also be the height of the exported image\nin physical pixels.\nIf not specified, will default to `plotly.io.config.default_height`\nscale: int or float or None\nThe scale factor to use when exporting the figure. A scale factor\nlarger than 1.0 will increase the image resolution with respect\nto the figure's layout pixel dimensions. Whereas as scale factor of\nless than 1.0 will decrease the image resolution.\nIf not specified, will default to `plotly.io.config.default_scale`\nvalidate: bool\nTrue if the figure should be validated before being converted to\nan image, False otherwise.\nengine: str\nImage export engine to use:\n- \"kaleido\": Use Kaleido for image export\n- \"orca\": Use Orca for image export\n- \"auto\" (default): Use Kaleido if installed, otherwise use orca\nReturns\n-------\nbytes\nThe image data",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.to_image",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.to_json": {
    "name": "plotly_basedatatypes_BaseFigure_to_json",
    "description": "Convert a figure to a JSON string representation\nParameters\n----------\nvalidate: bool (default True)\nTrue if the figure should be validated before being converted to\nJSON, False otherwise.\npretty: bool (default False)\nTrue if JSON representation should be pretty-printed, False if\nrepresentation should be as compact as possible.\nremove_uids: bool (default True)\nTrue if trace UIDs should be omitted from the JSON representation\nengine: str (default None)\nThe JSON encoding engine to use. One of:\n- \"json\" for an encoder based on the built-in Python json module\n- \"orjson\" for a fast encoder the requires the orjson package\nIf not specified, the default encoder is set to the current value of\nplotly.io.json.config.default_encoder.\nReturns\n-------\nstr\nRepresentation of figure as a JSON string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.to_json",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.to_ordered_dict": {
    "name": "plotly_basedatatypes_BaseFigure_to_ordered_dict",
    "description": "执行to_ordered_dict操作（BaseFigure类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skip_uid": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.to_ordered_dict",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.to_plotly_json": {
    "name": "plotly_basedatatypes_BaseFigure_to_plotly_json",
    "description": "Convert figure to a JSON representation as a Python dict\n\nNote: May include some JSON-invalid data types, use the `PlotlyJSONEncoder` util\nor the `to_json` method to encode to a string.\n\nReturns\n-------\ndict",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.to_plotly_json",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.update": {
    "name": "plotly_basedatatypes_BaseFigure_update",
    "description": "Update the properties of the figure with a dict and/or with\nkeyword arguments.\nThis recursively updates the structure of the figure\nobject with the values in the input dict / keyword arguments.\nParameters\n----------\ndict1 : dict\nDictionary of properties to be updated\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\nkwargs :\nKeyword/value pair of properties to be updated\nExamples\n--------\n>>> import plotly.graph_objs as go\n>>> fig = go.Figure(data=[{'y': [1, 2, 3]}])\n>>> fig.update(data=[{'y': [4, 5, 6]}]) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.to_plotly_json() # doctest: +SKIP\n{'data': [{'type': 'scatter',\n'uid': 'e86a7c7a-346a-11e8-8aa8-a0999b0c017b',\n'y': array([4, 5, 6], dtype=int32)}],\n'layout': {}}\n>>> fig = go.Figure(layout={'xaxis':\n...                         {'color': 'green',\n...                          'range': [0, 1]}})\n>>> fig.update({'layout': {'xaxis': {'color': 'pink'}}}) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.to_plotly_json() # doctest: +SKIP\n{'data': [],\n'layout': {'xaxis':\n{'color': 'pink',\n'range': [0, 1]}}}\nReturns\n-------\nBaseFigure\nUpdated figure",
    "inputSchema": {
      "type": "object",
      "properties": {
        "dict1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.update",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.update_layout": {
    "name": "plotly_basedatatypes_BaseFigure_update_layout",
    "description": "Update the properties of the figure's layout with a dict and/or with\nkeyword arguments.\nThis recursively updates the structure of the original\nlayout with the values in the input dict / keyword arguments.\nParameters\n----------\ndict1 : dict\nDictionary of properties to be updated\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\nkwargs :\nKeyword/value pair of properties to be updated\nReturns\n-------\nBaseFigure\nThe Figure object that the update_layout method was called on",
    "inputSchema": {
      "type": "object",
      "properties": {
        "dict1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.update_layout",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.update_traces": {
    "name": "plotly_basedatatypes_BaseFigure_update_traces",
    "description": "Perform a property update operation on all traces that satisfy the\nspecified selection criteria\nParameters\n----------\npatch: dict or None (default None)\nDictionary of property updates to be applied to all traces that\nsatisfy the selection criteria.\nselector: dict, function, int, str or None (default None)\nDict to use as selection criteria.\nTraces will be selected if they contain properties corresponding\nto all of the dictionary's keys, with values that exactly match\nthe supplied values. If None (the default), all traces are\nselected. If a function, it must be a function accepting a single\nargument and returning a boolean. The function will be called on\neach trace and those for which the function returned True\nwill be in the selection. If an int N, the Nth trace matching row\nand col will be selected (N can be negative). If a string S, the selector\nis equivalent to dict(type=S).\nrow, col: int or None (default None)\nSubplot row and column index of traces to select.\nTo select traces by row and column, the Figure must have been\ncreated using plotly.subplots.make_subplots.  If None\n(the default), all traces are selected.\nsecondary_y: boolean or None (default None)\n* If True, only select traces associated with the secondary\ny-axis of the subplot.\n* If False, only select traces associated with the primary\ny-axis of the subplot.\n* If None (the default), do not filter traces based on secondary\ny-axis.\nTo select traces by secondary y-axis, the Figure must have been\ncreated using plotly.subplots.make_subplots. See the docstring\nfor the specs argument to make_subplots for more info on\ncreating subplots with secondary y-axes.\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\n**kwargs\nAdditional property updates to apply to each selected trace. If\na property is specified in both patch and in **kwargs then the\none in **kwargs takes precedence.\nReturns\n-------\nself\nReturns the Figure object that the method was called on",
    "inputSchema": {
      "type": "object",
      "properties": {
        "patch": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "selector": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.update_traces",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.write_html": {
    "name": "plotly_basedatatypes_BaseFigure_write_html",
    "description": "Write a figure to an HTML file representation\nParameters\n----------\nfile: str or writeable\nA string representing a local file path or a writeable object\n(e.g. a pathlib.Path object or an open file descriptor)\nconfig: dict or None (default None)\nPlotly.js figure config options\nauto_play: bool (default=True)\nWhether to automatically start the animation sequence on page load\nif the figure contains frames. Has no effect if the figure does not\ncontain frames.\ninclude_plotlyjs: bool or string (default True)\nSpecifies how the plotly.js library is included/loaded in the output\ndiv string.\nIf True, a script tag containing the plotly.js source code (~3MB)\nis included in the output.  HTML files generated with this option are\nfully self-contained and can be used offline.\nIf 'cdn', a script tag that references the plotly.js CDN is included\nin the output. HTML files generated with this option are about 3MB\nsmaller than those generated with include_plotlyjs=True, but they\nrequire an active internet connection in order to load the plotly.js\nlibrary.\nIf 'directory', a script tag is included that references an external\nplotly.min.js bundle that is assumed to reside in the same\ndirectory as the HTML file. If `file` is a string to a local file path\nand `full_html` is True then\nIf 'directory', a script tag is included that references an external\nplotly.min.js bundle that is assumed to reside in the same\ndirectory as the HTML file.  If `file` is a string to a local file\npath and `full_html` is True, then the plotly.min.js bundle is copied\ninto the directory of the resulting HTML file. If a file named\nplotly.min.js already exists in the output directory then this file\nis left unmodified and no copy is performed. HTML files generated\nwith this option can be used offline, but they require a copy of\nthe plotly.min.js bundle in the same directory. This option is\nuseful when many figures will be saved as HTML files in the same\ndirectory because the plotly.js source code will be included only\nonce per output directory, rather than once per output file.\nIf 'require', Plotly.js is loaded using require.js.  This option\nassumes that require.js is globally available and that it has been\nglobally configured to know how to find Plotly.js as 'plotly'.\nThis option is not advised when full_html=True as it will result\nin a non-functional html file.\nIf a string that ends in '.js', a script tag is included that\nreferences the specified path. This approach can be used to point\nthe resulting HTML file to an alternative CDN or local bundle.\nIf False, no script tag referencing plotly.js is included. This is\nuseful when the resulting div string will be placed inside an HTML\ndocument that already loads plotly.js.  This option is not advised\nwhen full_html=True as it will result in a non-functional html file.\ninclude_mathjax: bool or string (default False)\nSpecifies how the MathJax.js library is included in the output html\ndiv string.  MathJax is required in order to display labels\nwith LaTeX typesetting.\nIf False, no script tag referencing MathJax.js will be included in the\noutput.\nIf 'cdn', a script tag that references a MathJax CDN location will be\nincluded in the output.  HTML div strings generated with this option\nwill be able to display LaTeX typesetting as long as internet access\nis available.\nIf a string that ends in '.js', a script tag is included that\nreferences the specified path. This approach can be used to point the\nresulting HTML div string to an alternative CDN.\npost_script: str or list or None (default None)\nJavaScript snippet(s) to be included in the resulting div just after\nplot creation.  The string(s) may include '{plot_id}' placeholders\nthat will then be replaced by the `id` of the div element that the\nplotly.js figure is associated with.  One application for this script\nis to install custom plotly.js event handlers.\nfull_html: bool (default True)\nIf True, produce a string containing a complete HTML document\nstarting with an <html> tag.  If False, produce a string containing\na single <div> element.\nanimation_opts: dict or None (default None)\ndict of custom animation parameters to be passed to the function\nPlotly.animate in Plotly.js. See\nhttps://github.com/plotly/plotly.js/blob/master/src/plots/animation_attributes.js\nfor available options. Has no effect if the figure does not contain\nframes, or auto_play is False.\ndefault_width, default_height: number or str (default '100%')\nThe default figure width/height to use if the provided figure does not\nspecify its own layout.width/layout.height property.  May be\nspecified in pixels as an integer (e.g. 500), or as a css width style\nstring (e.g. '500px', '100%').\nvalidate: bool (default True)\nTrue if the figure should be validated before being converted to\nJSON, False otherwise.\nauto_open: bool (default True)\nIf True, open the saved file in a web browser after saving.\nThis argument only applies if `full_html` is True.\ndiv_id: str (default None)\nIf provided, this is the value of the id attribute of the div tag. If None, the\nid attribute is a UUID.\nReturns\n-------\nstr\nRepresentation of figure as an HTML div string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.write_html",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.write_image": {
    "name": "plotly_basedatatypes_BaseFigure_write_image",
    "description": "Convert a figure to a static image and write it to a file or writeable\nobject\nParameters\n----------\nfile: str or writeable\nA string representing a local file path or a writeable object\n(e.g. a pathlib.Path object or an open file descriptor)\nformat: str or None\nThe desired image format. One of\n- 'png'\n- 'jpg' or 'jpeg'\n- 'webp'\n- 'svg'\n- 'pdf'\n- 'eps' (Requires the poppler library to be installed)\nIf not specified and `file` is a string then this will default to the\nfile extension. If not specified and `file` is not a string then this\nwill default to `plotly.io.config.default_format`\nwidth: int or None\nThe width of the exported image in layout pixels. If the `scale`\nproperty is 1.0, this will also be the width of the exported image\nin physical pixels.\nIf not specified, will default to `plotly.io.config.default_width`\nheight: int or None\nThe height of the exported image in layout pixels. If the `scale`\nproperty is 1.0, this will also be the height of the exported image\nin physical pixels.\nIf not specified, will default to `plotly.io.config.default_height`\nscale: int or float or None\nThe scale factor to use when exporting the figure. A scale factor\nlarger than 1.0 will increase the image resolution with respect\nto the figure's layout pixel dimensions. Whereas as scale factor of\nless than 1.0 will decrease the image resolution.\nIf not specified, will default to `plotly.io.config.default_scale`\nvalidate: bool\nTrue if the figure should be validated before being converted to\nan image, False otherwise.\nengine: str\nImage export engine to use:\n- \"kaleido\": Use Kaleido for image export\n- \"orca\": Use Orca for image export\n- \"auto\" (default): Use Kaleido if installed, otherwise use orca\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.write_image",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFigure.write_json": {
    "name": "plotly_basedatatypes_BaseFigure_write_json",
    "description": "Convert a figure to JSON and write it to a file or writeable\nobject\nParameters\n----------\nfile: str or writeable\nA string representing a local file path or a writeable object\n(e.g. an open file descriptor)\npretty: bool (default False)\nTrue if JSON representation should be pretty-printed, False if\nrepresentation should be as compact as possible.\nremove_uids: bool (default True)\nTrue if trace UIDs should be omitted from the JSON representation\nengine: str (default None)\nThe JSON encoding engine to use. One of:\n- \"json\" for an encoder based on the built-in Python json module\n- \"orjson\" for a fast encoder the requires the orjson package\nIf not specified, the default encoder is set to the current value of\nplotly.io.json.config.default_encoder.\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFigure.write_json",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFigure",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFrameHierarchyType.on_change": {
    "name": "plotly_basedatatypes_BaseFrameHierarchyType_on_change",
    "description": "执行on_change操作（BaseFrameHierarchyType类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "callback": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "callback",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFrameHierarchyType.on_change",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFrameHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFrameHierarchyType.pop": {
    "name": "plotly_basedatatypes_BaseFrameHierarchyType_pop",
    "description": "Remove the value associated with the specified key and return it\nParameters\n----------\nkey: str\nProperty name\ndflt\nThe default value to return if key was not found in object\nReturns\n-------\nvalue\nThe removed value that was previously associated with key\nRaises\n------\nKeyError\nIf key is not in object and no dflt argument specified",
    "inputSchema": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "key",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFrameHierarchyType.pop",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFrameHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFrameHierarchyType.to_json": {
    "name": "plotly_basedatatypes_BaseFrameHierarchyType_to_json",
    "description": "Convert object to a JSON string representation\nParameters\n----------\nvalidate: bool (default True)\nTrue if the object should be validated before being converted to\nJSON, False otherwise.\npretty: bool (default False)\nTrue if JSON representation should be pretty-printed, False if\nrepresentation should be as compact as possible.\nremove_uids: bool (default True)\nTrue if trace UIDs should be omitted from the JSON representation\nengine: str (default None)\nThe JSON encoding engine to use. One of:\n- \"json\" for an encoder based on the built-in Python json module\n- \"orjson\" for a fast encoder the requires the orjson package\nIf not specified, the default encoder is set to the current value of\nplotly.io.json.config.default_encoder.\nReturns\n-------\nstr\nRepresentation of object as a JSON string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFrameHierarchyType.to_json",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFrameHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFrameHierarchyType.to_plotly_json": {
    "name": "plotly_basedatatypes_BaseFrameHierarchyType_to_plotly_json",
    "description": "Return plotly JSON representation of object as a Python dict\n\nNote: May include some JSON-invalid data types, use the `PlotlyJSONEncoder` util\nor the `to_json` method to encode to a string.\n\nReturns\n-------\ndict",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFrameHierarchyType.to_plotly_json",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFrameHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseFrameHierarchyType.update": {
    "name": "plotly_basedatatypes_BaseFrameHierarchyType_update",
    "description": "Update the properties of an object with a dict and/or with\nkeyword arguments.\nThis recursively updates the structure of the original\nobject with the values in the input dict / keyword arguments.\nParameters\n----------\ndict1 : dict\nDictionary of properties to be updated\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\nkwargs :\nKeyword/value pair of properties to be updated\nReturns\n-------\nBasePlotlyType\nUpdated plotly object",
    "inputSchema": {
      "type": "object",
      "properties": {
        "dict1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseFrameHierarchyType.update",
      "module": "plotly.basedatatypes",
      "class_name": "BaseFrameHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseLayoutHierarchyType.on_change": {
    "name": "plotly_basedatatypes_BaseLayoutHierarchyType_on_change",
    "description": "Register callback function to be called when certain properties or\nsubproperties of this object are modified.\nCallback will be invoked whenever ANY of these properties is\nmodified. Furthermore, the callback will only be invoked once even\nif multiple properties are modified during the same restyle /\nrelayout / update operation.\nParameters\n----------\ncallback : function\nFunction that accepts 1 + len(`args`) parameters. First parameter\nis this object. Second through last parameters are the\nproperty / subpropery values referenced by args.\nargs : list[str|tuple[int|str]]\nList of property references where each reference may be one of:\n1) A property name string (e.g. 'foo') for direct properties\n2) A property path string (e.g. 'foo[0].bar') for\nsubproperties\n3) A property path tuple (e.g. ('foo', 0, 'bar')) for\nsubproperties\nappend : bool\nTrue if callback should be appended to previously registered\ncallback on the same properties, False if callback should replace\npreviously registered callbacks on the same properties. Defaults\nto False.\nExamples\n--------\nRegister callback that prints out the range extents of the xaxis and\nyaxis whenever either either of them changes.\n>>> import plotly.graph_objects as go\n>>> fig = go.Figure(go.Scatter(x=[1, 2], y=[1, 0]))\n>>> fig.layout.on_change(\n...   lambda obj, xrange, yrange: print(\"%s-%s\" % (xrange, yrange)),\n...   ('xaxis', 'range'), ('yaxis', 'range'))\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "callback": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "callback",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseLayoutHierarchyType.on_change",
      "module": "plotly.basedatatypes",
      "class_name": "BaseLayoutHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseLayoutHierarchyType.pop": {
    "name": "plotly_basedatatypes_BaseLayoutHierarchyType_pop",
    "description": "Remove the value associated with the specified key and return it\nParameters\n----------\nkey: str\nProperty name\ndflt\nThe default value to return if key was not found in object\nReturns\n-------\nvalue\nThe removed value that was previously associated with key\nRaises\n------\nKeyError\nIf key is not in object and no dflt argument specified",
    "inputSchema": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "key",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseLayoutHierarchyType.pop",
      "module": "plotly.basedatatypes",
      "class_name": "BaseLayoutHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseLayoutHierarchyType.to_json": {
    "name": "plotly_basedatatypes_BaseLayoutHierarchyType_to_json",
    "description": "Convert object to a JSON string representation\nParameters\n----------\nvalidate: bool (default True)\nTrue if the object should be validated before being converted to\nJSON, False otherwise.\npretty: bool (default False)\nTrue if JSON representation should be pretty-printed, False if\nrepresentation should be as compact as possible.\nremove_uids: bool (default True)\nTrue if trace UIDs should be omitted from the JSON representation\nengine: str (default None)\nThe JSON encoding engine to use. One of:\n- \"json\" for an encoder based on the built-in Python json module\n- \"orjson\" for a fast encoder the requires the orjson package\nIf not specified, the default encoder is set to the current value of\nplotly.io.json.config.default_encoder.\nReturns\n-------\nstr\nRepresentation of object as a JSON string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseLayoutHierarchyType.to_json",
      "module": "plotly.basedatatypes",
      "class_name": "BaseLayoutHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseLayoutHierarchyType.to_plotly_json": {
    "name": "plotly_basedatatypes_BaseLayoutHierarchyType_to_plotly_json",
    "description": "Return plotly JSON representation of object as a Python dict\n\nNote: May include some JSON-invalid data types, use the `PlotlyJSONEncoder` util\nor the `to_json` method to encode to a string.\n\nReturns\n-------\ndict",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseLayoutHierarchyType.to_plotly_json",
      "module": "plotly.basedatatypes",
      "class_name": "BaseLayoutHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseLayoutHierarchyType.update": {
    "name": "plotly_basedatatypes_BaseLayoutHierarchyType_update",
    "description": "Update the properties of an object with a dict and/or with\nkeyword arguments.\nThis recursively updates the structure of the original\nobject with the values in the input dict / keyword arguments.\nParameters\n----------\ndict1 : dict\nDictionary of properties to be updated\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\nkwargs :\nKeyword/value pair of properties to be updated\nReturns\n-------\nBasePlotlyType\nUpdated plotly object",
    "inputSchema": {
      "type": "object",
      "properties": {
        "dict1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseLayoutHierarchyType.update",
      "module": "plotly.basedatatypes",
      "class_name": "BaseLayoutHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseLayoutType.on_change": {
    "name": "plotly_basedatatypes_BaseLayoutType_on_change",
    "description": "Register callback function to be called when certain properties or\nsubproperties of this object are modified.\nCallback will be invoked whenever ANY of these properties is\nmodified. Furthermore, the callback will only be invoked once even\nif multiple properties are modified during the same restyle /\nrelayout / update operation.\nParameters\n----------\ncallback : function\nFunction that accepts 1 + len(`args`) parameters. First parameter\nis this object. Second through last parameters are the\nproperty / subpropery values referenced by args.\nargs : list[str|tuple[int|str]]\nList of property references where each reference may be one of:\n1) A property name string (e.g. 'foo') for direct properties\n2) A property path string (e.g. 'foo[0].bar') for\nsubproperties\n3) A property path tuple (e.g. ('foo', 0, 'bar')) for\nsubproperties\nappend : bool\nTrue if callback should be appended to previously registered\ncallback on the same properties, False if callback should replace\npreviously registered callbacks on the same properties. Defaults\nto False.\nExamples\n--------\nRegister callback that prints out the range extents of the xaxis and\nyaxis whenever either either of them changes.\n>>> import plotly.graph_objects as go\n>>> fig = go.Figure(go.Scatter(x=[1, 2], y=[1, 0]))\n>>> fig.layout.on_change(\n...   lambda obj, xrange, yrange: print(\"%s-%s\" % (xrange, yrange)),\n...   ('xaxis', 'range'), ('yaxis', 'range'))\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "callback": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "callback",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseLayoutType.on_change",
      "module": "plotly.basedatatypes",
      "class_name": "BaseLayoutType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseLayoutType.pop": {
    "name": "plotly_basedatatypes_BaseLayoutType_pop",
    "description": "Remove the value associated with the specified key and return it\nParameters\n----------\nkey: str\nProperty name\ndflt\nThe default value to return if key was not found in object\nReturns\n-------\nvalue\nThe removed value that was previously associated with key\nRaises\n------\nKeyError\nIf key is not in object and no dflt argument specified",
    "inputSchema": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "key",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseLayoutType.pop",
      "module": "plotly.basedatatypes",
      "class_name": "BaseLayoutType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseLayoutType.to_json": {
    "name": "plotly_basedatatypes_BaseLayoutType_to_json",
    "description": "Convert object to a JSON string representation\nParameters\n----------\nvalidate: bool (default True)\nTrue if the object should be validated before being converted to\nJSON, False otherwise.\npretty: bool (default False)\nTrue if JSON representation should be pretty-printed, False if\nrepresentation should be as compact as possible.\nremove_uids: bool (default True)\nTrue if trace UIDs should be omitted from the JSON representation\nengine: str (default None)\nThe JSON encoding engine to use. One of:\n- \"json\" for an encoder based on the built-in Python json module\n- \"orjson\" for a fast encoder the requires the orjson package\nIf not specified, the default encoder is set to the current value of\nplotly.io.json.config.default_encoder.\nReturns\n-------\nstr\nRepresentation of object as a JSON string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseLayoutType.to_json",
      "module": "plotly.basedatatypes",
      "class_name": "BaseLayoutType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseLayoutType.to_plotly_json": {
    "name": "plotly_basedatatypes_BaseLayoutType_to_plotly_json",
    "description": "Return plotly JSON representation of object as a Python dict\n\nNote: May include some JSON-invalid data types, use the `PlotlyJSONEncoder` util\nor the `to_json` method to encode to a string.\n\nReturns\n-------\ndict",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseLayoutType.to_plotly_json",
      "module": "plotly.basedatatypes",
      "class_name": "BaseLayoutType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseLayoutType.update": {
    "name": "plotly_basedatatypes_BaseLayoutType_update",
    "description": "Update the properties of an object with a dict and/or with\nkeyword arguments.\nThis recursively updates the structure of the original\nobject with the values in the input dict / keyword arguments.\nParameters\n----------\ndict1 : dict\nDictionary of properties to be updated\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\nkwargs :\nKeyword/value pair of properties to be updated\nReturns\n-------\nBasePlotlyType\nUpdated plotly object",
    "inputSchema": {
      "type": "object",
      "properties": {
        "dict1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseLayoutType.update",
      "module": "plotly.basedatatypes",
      "class_name": "BaseLayoutType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BasePlotlyType.on_change": {
    "name": "plotly_basedatatypes_BasePlotlyType_on_change",
    "description": "Register callback function to be called when certain properties or\nsubproperties of this object are modified.\nCallback will be invoked whenever ANY of these properties is\nmodified. Furthermore, the callback will only be invoked once even\nif multiple properties are modified during the same restyle /\nrelayout / update operation.\nParameters\n----------\ncallback : function\nFunction that accepts 1 + len(`args`) parameters. First parameter\nis this object. Second through last parameters are the\nproperty / subpropery values referenced by args.\nargs : list[str|tuple[int|str]]\nList of property references where each reference may be one of:\n1) A property name string (e.g. 'foo') for direct properties\n2) A property path string (e.g. 'foo[0].bar') for\nsubproperties\n3) A property path tuple (e.g. ('foo', 0, 'bar')) for\nsubproperties\nappend : bool\nTrue if callback should be appended to previously registered\ncallback on the same properties, False if callback should replace\npreviously registered callbacks on the same properties. Defaults\nto False.\nExamples\n--------\nRegister callback that prints out the range extents of the xaxis and\nyaxis whenever either either of them changes.\n>>> import plotly.graph_objects as go\n>>> fig = go.Figure(go.Scatter(x=[1, 2], y=[1, 0]))\n>>> fig.layout.on_change(\n...   lambda obj, xrange, yrange: print(\"%s-%s\" % (xrange, yrange)),\n...   ('xaxis', 'range'), ('yaxis', 'range'))\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "callback": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "callback",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BasePlotlyType.on_change",
      "module": "plotly.basedatatypes",
      "class_name": "BasePlotlyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BasePlotlyType.pop": {
    "name": "plotly_basedatatypes_BasePlotlyType_pop",
    "description": "Remove the value associated with the specified key and return it\nParameters\n----------\nkey: str\nProperty name\ndflt\nThe default value to return if key was not found in object\nReturns\n-------\nvalue\nThe removed value that was previously associated with key\nRaises\n------\nKeyError\nIf key is not in object and no dflt argument specified",
    "inputSchema": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "key",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BasePlotlyType.pop",
      "module": "plotly.basedatatypes",
      "class_name": "BasePlotlyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BasePlotlyType.to_json": {
    "name": "plotly_basedatatypes_BasePlotlyType_to_json",
    "description": "Convert object to a JSON string representation\nParameters\n----------\nvalidate: bool (default True)\nTrue if the object should be validated before being converted to\nJSON, False otherwise.\npretty: bool (default False)\nTrue if JSON representation should be pretty-printed, False if\nrepresentation should be as compact as possible.\nremove_uids: bool (default True)\nTrue if trace UIDs should be omitted from the JSON representation\nengine: str (default None)\nThe JSON encoding engine to use. One of:\n- \"json\" for an encoder based on the built-in Python json module\n- \"orjson\" for a fast encoder the requires the orjson package\nIf not specified, the default encoder is set to the current value of\nplotly.io.json.config.default_encoder.\nReturns\n-------\nstr\nRepresentation of object as a JSON string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BasePlotlyType.to_json",
      "module": "plotly.basedatatypes",
      "class_name": "BasePlotlyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BasePlotlyType.to_plotly_json": {
    "name": "plotly_basedatatypes_BasePlotlyType_to_plotly_json",
    "description": "Return plotly JSON representation of object as a Python dict\n\nNote: May include some JSON-invalid data types, use the `PlotlyJSONEncoder` util\nor the `to_json` method to encode to a string.\n\nReturns\n-------\ndict",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BasePlotlyType.to_plotly_json",
      "module": "plotly.basedatatypes",
      "class_name": "BasePlotlyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BasePlotlyType.update": {
    "name": "plotly_basedatatypes_BasePlotlyType_update",
    "description": "Update the properties of an object with a dict and/or with\nkeyword arguments.\nThis recursively updates the structure of the original\nobject with the values in the input dict / keyword arguments.\nParameters\n----------\ndict1 : dict\nDictionary of properties to be updated\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\nkwargs :\nKeyword/value pair of properties to be updated\nReturns\n-------\nBasePlotlyType\nUpdated plotly object",
    "inputSchema": {
      "type": "object",
      "properties": {
        "dict1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BasePlotlyType.update",
      "module": "plotly.basedatatypes",
      "class_name": "BasePlotlyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceHierarchyType.on_change": {
    "name": "plotly_basedatatypes_BaseTraceHierarchyType_on_change",
    "description": "Register callback function to be called when certain properties or\nsubproperties of this object are modified.\nCallback will be invoked whenever ANY of these properties is\nmodified. Furthermore, the callback will only be invoked once even\nif multiple properties are modified during the same restyle /\nrelayout / update operation.\nParameters\n----------\ncallback : function\nFunction that accepts 1 + len(`args`) parameters. First parameter\nis this object. Second through last parameters are the\nproperty / subpropery values referenced by args.\nargs : list[str|tuple[int|str]]\nList of property references where each reference may be one of:\n1) A property name string (e.g. 'foo') for direct properties\n2) A property path string (e.g. 'foo[0].bar') for\nsubproperties\n3) A property path tuple (e.g. ('foo', 0, 'bar')) for\nsubproperties\nappend : bool\nTrue if callback should be appended to previously registered\ncallback on the same properties, False if callback should replace\npreviously registered callbacks on the same properties. Defaults\nto False.\nExamples\n--------\nRegister callback that prints out the range extents of the xaxis and\nyaxis whenever either either of them changes.\n>>> import plotly.graph_objects as go\n>>> fig = go.Figure(go.Scatter(x=[1, 2], y=[1, 0]))\n>>> fig.layout.on_change(\n...   lambda obj, xrange, yrange: print(\"%s-%s\" % (xrange, yrange)),\n...   ('xaxis', 'range'), ('yaxis', 'range'))\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "callback": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "callback",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceHierarchyType.on_change",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceHierarchyType.pop": {
    "name": "plotly_basedatatypes_BaseTraceHierarchyType_pop",
    "description": "Remove the value associated with the specified key and return it\nParameters\n----------\nkey: str\nProperty name\ndflt\nThe default value to return if key was not found in object\nReturns\n-------\nvalue\nThe removed value that was previously associated with key\nRaises\n------\nKeyError\nIf key is not in object and no dflt argument specified",
    "inputSchema": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "key",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceHierarchyType.pop",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceHierarchyType.to_json": {
    "name": "plotly_basedatatypes_BaseTraceHierarchyType_to_json",
    "description": "Convert object to a JSON string representation\nParameters\n----------\nvalidate: bool (default True)\nTrue if the object should be validated before being converted to\nJSON, False otherwise.\npretty: bool (default False)\nTrue if JSON representation should be pretty-printed, False if\nrepresentation should be as compact as possible.\nremove_uids: bool (default True)\nTrue if trace UIDs should be omitted from the JSON representation\nengine: str (default None)\nThe JSON encoding engine to use. One of:\n- \"json\" for an encoder based on the built-in Python json module\n- \"orjson\" for a fast encoder the requires the orjson package\nIf not specified, the default encoder is set to the current value of\nplotly.io.json.config.default_encoder.\nReturns\n-------\nstr\nRepresentation of object as a JSON string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceHierarchyType.to_json",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceHierarchyType.to_plotly_json": {
    "name": "plotly_basedatatypes_BaseTraceHierarchyType_to_plotly_json",
    "description": "Return plotly JSON representation of object as a Python dict\n\nNote: May include some JSON-invalid data types, use the `PlotlyJSONEncoder` util\nor the `to_json` method to encode to a string.\n\nReturns\n-------\ndict",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceHierarchyType.to_plotly_json",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceHierarchyType.update": {
    "name": "plotly_basedatatypes_BaseTraceHierarchyType_update",
    "description": "Update the properties of an object with a dict and/or with\nkeyword arguments.\nThis recursively updates the structure of the original\nobject with the values in the input dict / keyword arguments.\nParameters\n----------\ndict1 : dict\nDictionary of properties to be updated\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\nkwargs :\nKeyword/value pair of properties to be updated\nReturns\n-------\nBasePlotlyType\nUpdated plotly object",
    "inputSchema": {
      "type": "object",
      "properties": {
        "dict1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceHierarchyType.update",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceHierarchyType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceType.on_change": {
    "name": "plotly_basedatatypes_BaseTraceType_on_change",
    "description": "Register callback function to be called when certain properties or\nsubproperties of this object are modified.\nCallback will be invoked whenever ANY of these properties is\nmodified. Furthermore, the callback will only be invoked once even\nif multiple properties are modified during the same restyle /\nrelayout / update operation.\nParameters\n----------\ncallback : function\nFunction that accepts 1 + len(`args`) parameters. First parameter\nis this object. Second through last parameters are the\nproperty / subpropery values referenced by args.\nargs : list[str|tuple[int|str]]\nList of property references where each reference may be one of:\n1) A property name string (e.g. 'foo') for direct properties\n2) A property path string (e.g. 'foo[0].bar') for\nsubproperties\n3) A property path tuple (e.g. ('foo', 0, 'bar')) for\nsubproperties\nappend : bool\nTrue if callback should be appended to previously registered\ncallback on the same properties, False if callback should replace\npreviously registered callbacks on the same properties. Defaults\nto False.\nExamples\n--------\nRegister callback that prints out the range extents of the xaxis and\nyaxis whenever either either of them changes.\n>>> import plotly.graph_objects as go\n>>> fig = go.Figure(go.Scatter(x=[1, 2], y=[1, 0]))\n>>> fig.layout.on_change(\n...   lambda obj, xrange, yrange: print(\"%s-%s\" % (xrange, yrange)),\n...   ('xaxis', 'range'), ('yaxis', 'range'))\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "callback": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "callback",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceType.on_change",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceType.on_click": {
    "name": "plotly_basedatatypes_BaseTraceType_on_click",
    "description": "Register function to be called when the user clicks on one or more\npoints in this trace.\n\nNote: Callbacks will only be triggered when the trace belongs to a\ninstance of plotly.graph_objs.FigureWidget and it is displayed in an\nipywidget context. Callbacks will not be triggered on figures\nthat are displayed using plot/iplot.\n\nParameters\n----------\ncallback\nCallable function that accepts 3 arguments\n\n- this trace\n- plotly.callbacks.Points object\n- plotly.callbacks.InputDeviceState object\n\nappend : bool\nIf False (the default), this callback replaces any previously\ndefined on_click callbacks for this trace. If True,\nthis callback is appended to the list of any previously defined\ncallbacks.\n\nReturns\n-------\nNone\n\nExamples\n--------\n\n>>> import plotly.graph_objects as go\n>>> from plotly.callbacks import Points, InputDeviceState\n>>> points, state = Points(), InputDeviceState()\n\n>>> def click_fn(trace, points, state):\n...     inds = points.point_inds\n...     # Do something\n\n>>> trace = go.Scatter(x=[1, 2], y=[3, 0])\n>>> trace.on_click(click_fn)\n\nNote: The creation of the `points` and `state` objects is optional,\nit's simply a convenience to help the text editor perform completion\non the arguments inside `click_fn`",
    "inputSchema": {
      "type": "object",
      "properties": {
        "callback": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "append": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "callback"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceType.on_click",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceType.on_deselect": {
    "name": "plotly_basedatatypes_BaseTraceType_on_deselect",
    "description": "Register function to be called when the user deselects points\nin this trace using doubleclick.\n\nNote: Callbacks will only be triggered when the trace belongs to a\ninstance of plotly.graph_objs.FigureWidget and it is displayed in an\nipywidget context. Callbacks will not be triggered on figures\nthat are displayed using plot/iplot.\n\nParameters\n----------\ncallback\nCallable function that accepts 3 arguments\n\n- this trace\n- plotly.callbacks.Points object\n\nappend : bool\nIf False (the default), this callback replaces any previously\ndefined on_deselect callbacks for this trace. If True,\nthis callback is appended to the list of any previously defined\ncallbacks.\n\nReturns\n-------\nNone\n\nExamples\n--------\n\n>>> import plotly.graph_objects as go\n>>> from plotly.callbacks import Points\n>>> points = Points()\n\n>>> def deselect_fn(trace, points):\n...     inds = points.point_inds\n...     # Do something\n\n>>> trace = go.Scatter(x=[1, 2], y=[3, 0])\n>>> trace.on_deselect(deselect_fn)\n\nNote: The creation of the `points` object is optional,\nit's simply a convenience to help the text editor perform completion\non the `points` arguments inside `selection_fn`",
    "inputSchema": {
      "type": "object",
      "properties": {
        "callback": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "append": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "callback"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceType.on_deselect",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceType.on_hover": {
    "name": "plotly_basedatatypes_BaseTraceType_on_hover",
    "description": "Register function to be called when the user hovers over one or more\npoints in this trace\n\nNote: Callbacks will only be triggered when the trace belongs to a\ninstance of plotly.graph_objs.FigureWidget and it is displayed in an\nipywidget context. Callbacks will not be triggered on figures\nthat are displayed using plot/iplot.\n\nParameters\n----------\ncallback\nCallable function that accepts 3 arguments\n\n- this trace\n- plotly.callbacks.Points object\n- plotly.callbacks.InputDeviceState object\n\nappend : bool\nIf False (the default), this callback replaces any previously\ndefined on_hover callbacks for this trace. If True,\nthis callback is appended to the list of any previously defined\ncallbacks.\n\nReturns\n-------\nNone\n\nExamples\n--------\n\n>>> import plotly.graph_objects as go\n>>> from plotly.callbacks import Points, InputDeviceState\n>>> points, state = Points(), InputDeviceState()\n\n>>> def hover_fn(trace, points, state):\n...     inds = points.point_inds\n...     # Do something\n\n>>> trace = go.Scatter(x=[1, 2], y=[3, 0])\n>>> trace.on_hover(hover_fn)\n\nNote: The creation of the `points` and `state` objects is optional,\nit's simply a convenience to help the text editor perform completion\non the arguments inside `hover_fn`",
    "inputSchema": {
      "type": "object",
      "properties": {
        "callback": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "append": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "callback"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceType.on_hover",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceType.on_selection": {
    "name": "plotly_basedatatypes_BaseTraceType_on_selection",
    "description": "Register function to be called when the user selects one or more\npoints in this trace.\n\nNote: Callbacks will only be triggered when the trace belongs to a\ninstance of plotly.graph_objs.FigureWidget and it is displayed in an\nipywidget context. Callbacks will not be triggered on figures\nthat are displayed using plot/iplot.\n\nParameters\n----------\ncallback\nCallable function that accepts 4 arguments\n\n- this trace\n- plotly.callbacks.Points object\n- plotly.callbacks.BoxSelector or plotly.callbacks.LassoSelector\n\nappend : bool\nIf False (the default), this callback replaces any previously\ndefined on_selection callbacks for this trace. If True,\nthis callback is appended to the list of any previously defined\ncallbacks.\n\nReturns\n-------\nNone\n\nExamples\n--------\n\n>>> import plotly.graph_objects as go\n>>> from plotly.callbacks import Points\n>>> points = Points()\n\n>>> def selection_fn(trace, points, selector):\n...     inds = points.point_inds\n...     # Do something\n\n>>> trace = go.Scatter(x=[1, 2], y=[3, 0])\n>>> trace.on_selection(selection_fn)\n\nNote: The creation of the `points` object is optional,\nit's simply a convenience to help the text editor perform completion\non the `points` arguments inside `selection_fn`",
    "inputSchema": {
      "type": "object",
      "properties": {
        "callback": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "append": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "callback"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceType.on_selection",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceType.on_unhover": {
    "name": "plotly_basedatatypes_BaseTraceType_on_unhover",
    "description": "Register function to be called when the user unhovers away from one\nor more points in this trace.\n\nNote: Callbacks will only be triggered when the trace belongs to a\ninstance of plotly.graph_objs.FigureWidget and it is displayed in an\nipywidget context. Callbacks will not be triggered on figures\nthat are displayed using plot/iplot.\n\nParameters\n----------\ncallback\nCallable function that accepts 3 arguments\n\n- this trace\n- plotly.callbacks.Points object\n- plotly.callbacks.InputDeviceState object\n\nappend : bool\nIf False (the default), this callback replaces any previously\ndefined on_unhover callbacks for this trace. If True,\nthis callback is appended to the list of any previously defined\ncallbacks.\n\nReturns\n-------\nNone\n\nExamples\n--------\n\n>>> import plotly.graph_objects as go\n>>> from plotly.callbacks import Points, InputDeviceState\n>>> points, state = Points(), InputDeviceState()\n\n>>> def unhover_fn(trace, points, state):\n...     inds = points.point_inds\n...     # Do something\n\n>>> trace = go.Scatter(x=[1, 2], y=[3, 0])\n>>> trace.on_unhover(unhover_fn)\n\nNote: The creation of the `points` and `state` objects is optional,\nit's simply a convenience to help the text editor perform completion\non the arguments inside `unhover_fn`",
    "inputSchema": {
      "type": "object",
      "properties": {
        "callback": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "append": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "callback"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceType.on_unhover",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceType.pop": {
    "name": "plotly_basedatatypes_BaseTraceType_pop",
    "description": "Remove the value associated with the specified key and return it\nParameters\n----------\nkey: str\nProperty name\ndflt\nThe default value to return if key was not found in object\nReturns\n-------\nvalue\nThe removed value that was previously associated with key\nRaises\n------\nKeyError\nIf key is not in object and no dflt argument specified",
    "inputSchema": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "key",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceType.pop",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceType.to_json": {
    "name": "plotly_basedatatypes_BaseTraceType_to_json",
    "description": "Convert object to a JSON string representation\nParameters\n----------\nvalidate: bool (default True)\nTrue if the object should be validated before being converted to\nJSON, False otherwise.\npretty: bool (default False)\nTrue if JSON representation should be pretty-printed, False if\nrepresentation should be as compact as possible.\nremove_uids: bool (default True)\nTrue if trace UIDs should be omitted from the JSON representation\nengine: str (default None)\nThe JSON encoding engine to use. One of:\n- \"json\" for an encoder based on the built-in Python json module\n- \"orjson\" for a fast encoder the requires the orjson package\nIf not specified, the default encoder is set to the current value of\nplotly.io.json.config.default_encoder.\nReturns\n-------\nstr\nRepresentation of object as a JSON string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceType.to_json",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceType.to_plotly_json": {
    "name": "plotly_basedatatypes_BaseTraceType_to_plotly_json",
    "description": "Return plotly JSON representation of object as a Python dict\n\nNote: May include some JSON-invalid data types, use the `PlotlyJSONEncoder` util\nor the `to_json` method to encode to a string.\n\nReturns\n-------\ndict",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceType.to_plotly_json",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basedatatypes.BaseTraceType.update": {
    "name": "plotly_basedatatypes_BaseTraceType_update",
    "description": "Update the properties of an object with a dict and/or with\nkeyword arguments.\nThis recursively updates the structure of the original\nobject with the values in the input dict / keyword arguments.\nParameters\n----------\ndict1 : dict\nDictionary of properties to be updated\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\nkwargs :\nKeyword/value pair of properties to be updated\nReturns\n-------\nBasePlotlyType\nUpdated plotly object",
    "inputSchema": {
      "type": "object",
      "properties": {
        "dict1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basedatatypes.BaseTraceType.update",
      "module": "plotly.basedatatypes",
      "class_name": "BaseTraceType",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.add_class": {
    "name": "plotly_basewidget_BaseFigureWidget_add_class",
    "description": "Adds a class to the top level element of the widget.\nDoesn't add the class if it already exists.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "className": {
          "type": "string",
          "description": "类型从参数名推断: className"
        }
      },
      "required": [
        "className"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.add_class",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.add_hline": {
    "name": "plotly_basewidget_BaseFigureWidget_add_hline",
    "description": "Add a horizontal line to a plot or subplot that extends infinitely in the\nx-dimension.\nParameters\n----------\ny: float or int\nA number representing the y coordinate of the horizontal line.\nexclude_empty_subplots: Boolean\nIf True (default) do not place the shape on subplots that have no data\nplotted on them.\nrow: None, int or 'all'\nSubplot row for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\ncol: None, int or 'all'\nSubplot column for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\nannotation: dict or plotly.graph_objects.layout.Annotation. If dict(),\nit is interpreted as describing an annotation. The annotation is\nplaced relative to the shape based on annotation_position (see\nbelow) unless its x or y value has been specified for the annotation\npassed here. xref and yref are always the same as for the added\nshape and cannot be overridden.\nannotation_position: a string containing optionally [\"top\", \"bottom\"]\nand [\"left\", \"right\"] specifying where the text should be anchored\nto on the line. Example positions are \"bottom left\", \"right top\",\n\"right\", \"bottom\". If an annotation is added but annotation_position is\nnot specified, this defaults to \"top right\".\nannotation_*: any parameters to go.layout.Annotation can be passed as\nkeywords by prefixing them with \"annotation_\". For example, to specify the\nannotation text \"example\" you can pass annotation_text=\"example\" as a\nkeyword argument.\n**kwargs:\nAny named function parameters that can be passed to 'add_shape',\nexcept for x0, x1, y0, y1 or type.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "col": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "annotation": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "y",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.add_hline",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.add_hrect": {
    "name": "plotly_basewidget_BaseFigureWidget_add_hrect",
    "description": "Add a rectangle to a plot or subplot that extends infinitely in the\nx-dimension.\nParameters\n----------\ny0: float or int\nA number representing the y coordinate of one side of the rectangle.\ny1: float or int\nA number representing the y coordinate of the other side of the rectangle.\nexclude_empty_subplots: Boolean\nIf True (default) do not place the shape on subplots that have no data\nplotted on them.\nrow: None, int or 'all'\nSubplot row for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\ncol: None, int or 'all'\nSubplot column for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\nannotation: dict or plotly.graph_objects.layout.Annotation. If dict(),\nit is interpreted as describing an annotation. The annotation is\nplaced relative to the shape based on annotation_position (see\nbelow) unless its x or y value has been specified for the annotation\npassed here. xref and yref are always the same as for the added\nshape and cannot be overridden.\nannotation_position: a string containing optionally [\"inside\", \"outside\"], [\"top\", \"bottom\"]\nand [\"left\", \"right\"] specifying where the text should be anchored\nto on the rectangle. Example positions are \"outside top left\", \"inside\nbottom\", \"right\", \"inside left\", \"inside\" (\"outside\" is not supported). If\nan annotation is added but annotation_position is not specified this\ndefaults to \"inside top right\".\nannotation_*: any parameters to go.layout.Annotation can be passed as\nkeywords by prefixing them with \"annotation_\". For example, to specify the\nannotation text \"example\" you can pass annotation_text=\"example\" as a\nkeyword argument.\n**kwargs:\nAny named function parameters that can be passed to 'add_shape',\nexcept for x0, x1, y0, y1 or type.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "y0": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "col": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "annotation": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "y0",
        "y1",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.add_hrect",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.add_trace": {
    "name": "plotly_basewidget_BaseFigureWidget_add_trace",
    "description": "Add a trace to the figure\nParameters\n----------\ntrace : BaseTraceType or dict\nEither:\n- An instances of a trace classe from the plotly.graph_objs\npackage (e.g plotly.graph_objs.Scatter, plotly.graph_objs.Bar)\n- or a dicts where:\n- The 'type' property specifies the trace type (e.g.\n'scatter', 'bar', 'area', etc.). If the dict has no 'type'\nproperty then 'scatter' is assumed.\n- All remaining properties are passed to the constructor\nof the specified trace type.\nrow : 'all', int or None (default)\nSubplot row index (starting from 1) for the trace to be\nadded. Only valid if figure was created using\n`plotly.tools.make_subplots`.\nIf 'all', addresses all rows in the specified column(s).\ncol : 'all', int or None (default)\nSubplot col index (starting from 1) for the trace to be\nadded. Only valid if figure was created using\n`plotly.tools.make_subplots`.\nIf 'all', addresses all columns in the specified row(s).\nsecondary_y: boolean or None (default None)\nIf True, associate this trace with the secondary y-axis of the\nsubplot at the specified row and col. Only valid if all of the\nfollowing conditions are satisfied:\n* The figure was created using `plotly.subplots.make_subplots`.\n* The row and col arguments are not None\n* The subplot at the specified row and col has type xy\n(which is the default) and secondary_y True.  These\nproperties are specified in the specs argument to\nmake_subplots. See the make_subplots docstring for more info.\n* The trace argument is a 2D cartesian trace\n(scatter, bar, etc.)\nexclude_empty_subplots: boolean\nIf True, the trace will not be added to subplots that don't already\nhave traces.\nReturns\n-------\nBaseFigure\nThe Figure that add_trace was called on\nExamples\n--------\n>>> from plotly import subplots\n>>> import plotly.graph_objs as go\nAdd two Scatter traces to a figure\n>>> fig = go.Figure()\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2])) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2])) # doctest: +ELLIPSIS\nFigure(...)\nAdd two Scatter traces to vertically stacked subplots\n>>> fig = subplots.make_subplots(rows=2)\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=1, col=1) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=2, col=1) # doctest: +ELLIPSIS\nFigure(...)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "trace": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "trace"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.add_trace",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.add_traces": {
    "name": "plotly_basewidget_BaseFigureWidget_add_traces",
    "description": "Add traces to the figure\nParameters\n----------\ndata : list[BaseTraceType or dict]\nA list of trace specifications to be added.\nTrace specifications may be either:\n- Instances of trace classes from the plotly.graph_objs\npackage (e.g plotly.graph_objs.Scatter, plotly.graph_objs.Bar)\n- Dicts where:\n- The 'type' property specifies the trace type (e.g.\n'scatter', 'bar', 'area', etc.). If the dict has no 'type'\nproperty then 'scatter' is assumed.\n- All remaining properties are passed to the constructor\nof the specified trace type.\nrows : None, list[int], or int (default None)\nList of subplot row indexes (starting from 1) for the traces to be\nadded. Only valid if figure was created using\n`plotly.tools.make_subplots`\nIf a single integer is passed, all traces will be added to row number\ncols : None or list[int] (default None)\nList of subplot column indexes (starting from 1) for the traces\nto be added. Only valid if figure was created using\n`plotly.tools.make_subplots`\nIf a single integer is passed, all traces will be added to column number\nsecondary_ys: None or list[boolean] (default None)\nList of secondary_y booleans for traces to be added. See the\ndocstring for `add_trace` for more info.\nexclude_empty_subplots: boolean\nIf True, the trace will not be added to subplots that don't already\nhave traces.\nReturns\n-------\nBaseFigure\nThe Figure that add_traces was called on\nExamples\n--------\n>>> from plotly import subplots\n>>> import plotly.graph_objs as go\nAdd two Scatter traces to a figure\n>>> fig = go.Figure()\n>>> fig.add_traces([go.Scatter(x=[1,2,3], y=[2,1,2]),\n...                 go.Scatter(x=[1,2,3], y=[2,1,2])]) # doctest: +ELLIPSIS\nFigure(...)\nAdd two Scatter traces to vertically stacked subplots\n>>> fig = subplots.make_subplots(rows=2)\n>>> fig.add_traces([go.Scatter(x=[1,2,3], y=[2,1,2]),\n...                 go.Scatter(x=[1,2,3], y=[2,1,2])],\n...                 rows=[1, 2], cols=[1, 1]) # doctest: +ELLIPSIS\nFigure(...)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "rows": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "cols": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_ys": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "data"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.add_traces",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.add_traits": {
    "name": "plotly_basewidget_BaseFigureWidget_add_traits",
    "description": "Dynamically add trait attributes to the Widget.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "traits": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "traits"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.add_traits",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.add_vline": {
    "name": "plotly_basewidget_BaseFigureWidget_add_vline",
    "description": "Add a vertical line to a plot or subplot that extends infinitely in the\ny-dimension.\nParameters\n----------\nx: float or int\nA number representing the x coordinate of the vertical line.\nexclude_empty_subplots: Boolean\nIf True (default) do not place the shape on subplots that have no data\nplotted on them.\nrow: None, int or 'all'\nSubplot row for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\ncol: None, int or 'all'\nSubplot column for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\nannotation: dict or plotly.graph_objects.layout.Annotation. If dict(),\nit is interpreted as describing an annotation. The annotation is\nplaced relative to the shape based on annotation_position (see\nbelow) unless its x or y value has been specified for the annotation\npassed here. xref and yref are always the same as for the added\nshape and cannot be overridden.\nannotation_position: a string containing optionally [\"top\", \"bottom\"]\nand [\"left\", \"right\"] specifying where the text should be anchored\nto on the line. Example positions are \"bottom left\", \"right top\",\n\"right\", \"bottom\". If an annotation is added but annotation_position is\nnot specified, this defaults to \"top right\".\nannotation_*: any parameters to go.layout.Annotation can be passed as\nkeywords by prefixing them with \"annotation_\". For example, to specify the\nannotation text \"example\" you can pass annotation_text=\"example\" as a\nkeyword argument.\n**kwargs:\nAny named function parameters that can be passed to 'add_shape',\nexcept for x0, x1, y0, y1 or type.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "x": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "col": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "annotation": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "x",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.add_vline",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.add_vrect": {
    "name": "plotly_basewidget_BaseFigureWidget_add_vrect",
    "description": "Add a rectangle to a plot or subplot that extends infinitely in the\ny-dimension.\nParameters\n----------\nx0: float or int\nA number representing the x coordinate of one side of the rectangle.\nx1: float or int\nA number representing the x coordinate of the other side of the rectangle.\nexclude_empty_subplots: Boolean\nIf True (default) do not place the shape on subplots that have no data\nplotted on them.\nrow: None, int or 'all'\nSubplot row for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\ncol: None, int or 'all'\nSubplot column for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\nannotation: dict or plotly.graph_objects.layout.Annotation. If dict(),\nit is interpreted as describing an annotation. The annotation is\nplaced relative to the shape based on annotation_position (see\nbelow) unless its x or y value has been specified for the annotation\npassed here. xref and yref are always the same as for the added\nshape and cannot be overridden.\nannotation_position: a string containing optionally [\"inside\", \"outside\"], [\"top\", \"bottom\"]\nand [\"left\", \"right\"] specifying where the text should be anchored\nto on the rectangle. Example positions are \"outside top left\", \"inside\nbottom\", \"right\", \"inside left\", \"inside\" (\"outside\" is not supported). If\nan annotation is added but annotation_position is not specified this\ndefaults to \"inside top right\".\nannotation_*: any parameters to go.layout.Annotation can be passed as\nkeywords by prefixing them with \"annotation_\". For example, to specify the\nannotation text \"example\" you can pass annotation_text=\"example\" as a\nkeyword argument.\n**kwargs:\nAny named function parameters that can be passed to 'add_shape',\nexcept for x0, x1, y0, y1 or type.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "x0": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "x1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "col": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "annotation": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "x0",
        "x1",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.add_vrect",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.append_trace": {
    "name": "plotly_basewidget_BaseFigureWidget_append_trace",
    "description": "Add a trace to the figure bound to axes at the specified row,\ncol index.\nA row, col index grid is generated for figures created with\nplotly.tools.make_subplots, and can be viewed with the `print_grid`\nmethod\nParameters\n----------\ntrace\nThe data trace to be bound\nrow: int\nSubplot row index (see Figure.print_grid)\ncol: int\nSubplot column index (see Figure.print_grid)\nExamples\n--------\n>>> from plotly import tools\n>>> import plotly.graph_objs as go\n>>> # stack two subplots vertically\n>>> fig = tools.make_subplots(rows=2)\nThis is the format of your plot grid:\n[ (1,1) x1,y1 ]\n[ (2,1) x2,y2 ]\n>>> fig.append_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=1, col=1)\n>>> fig.append_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=2, col=1)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "trace": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "trace",
        "row",
        "col"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.append_trace",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.batch_animate": {
    "name": "plotly_basewidget_BaseFigureWidget_batch_animate",
    "description": "Context manager to animate trace / layout updates\nParameters\n----------\nduration : number\nThe duration of the transition, in milliseconds.\nIf equal to zero, updates are synchronous.\neasing : string\nThe easing function used for the transition.\nOne of:\n- linear\n- quad\n- cubic\n- sin\n- exp\n- circle\n- elastic\n- back\n- bounce\n- linear-in\n- quad-in\n- cubic-in\n- sin-in\n- exp-in\n- circle-in\n- elastic-in\n- back-in\n- bounce-in\n- linear-out\n- quad-out\n- cubic-out\n- sin-out\n- exp-out\n- circle-out\n- elastic-out\n- back-out\n- bounce-out\n- linear-in-out\n- quad-in-out\n- cubic-in-out\n- sin-in-out\n- exp-in-out\n- circle-in-out\n- elastic-in-out\n- back-in-out\n- bounce-in-out\nExamples\n--------\nSuppose we have a figure widget, `fig`, with a single trace.\n>>> import plotly.graph_objs as go\n>>> fig = go.FigureWidget(data=[{'y': [3, 4, 2]}])\n1) Animate a change in the xaxis and yaxis ranges using default\nduration and easing parameters.\n>>> with fig.batch_animate():\n...     fig.layout.xaxis.range = [0, 5]\n...     fig.layout.yaxis.range = [0, 10]\n2) Animate a change in the size and color of the trace's markers\nover 2 seconds using the elastic-in-out easing method\n>>> with fig.batch_animate(duration=2000, easing='elastic-in-out'):\n...     fig.data[0].marker.color = 'green'\n...     fig.data[0].marker.size = 20",
    "inputSchema": {
      "type": "object",
      "properties": {
        "duration": {
          "type": "integer",
          "default": 500,
          "description": "类型从默认值推断: int"
        },
        "easing": {
          "type": "string",
          "default": "cubic-in-out",
          "description": "类型从默认值推断: str"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.batch_animate",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.batch_update": {
    "name": "plotly_basewidget_BaseFigureWidget_batch_update",
    "description": "A context manager that batches up trace and layout assignment\noperations into a singe plotly_update message that is executed when\nthe context exits.\nExamples\n--------\nFor example, suppose we have a figure widget, `fig`, with a single\ntrace.\n>>> import plotly.graph_objs as go\n>>> fig = go.FigureWidget(data=[{'y': [3, 4, 2]}])\nIf we want to update the xaxis range, the yaxis range, and the\nmarker color, we could do so using a series of three property\nassignments as follows:\n>>> fig.layout.xaxis.range = [0, 5]\n>>> fig.layout.yaxis.range = [0, 10]\n>>> fig.data[0].marker.color = 'green'\nThis will work, however it will result in three messages being\nsent to the front end (two relayout messages for the axis range\nupdates followed by one restyle message for the marker color\nupdate). This can cause the plot to appear to stutter as the\nthree updates are applied incrementally.\nWe can avoid this problem by performing these three assignments in a\n`batch_update` context as follows:\n>>> with fig.batch_update():\n...     fig.layout.xaxis.range = [0, 5]\n...     fig.layout.yaxis.range = [0, 10]\n...     fig.data[0].marker.color = 'green'\nNow, these three property updates will be sent to the frontend in a\nsingle update message, and they will be applied by the front end\nsimultaneously.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.batch_update",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.close": {
    "name": "plotly_basewidget_BaseFigureWidget_close",
    "description": "Close method.\nCloses the underlying comm.\nWhen the comm is closed, all of the widget views are automatically\nremoved from the front-end.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.close",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.for_each_trace": {
    "name": "plotly_basewidget_BaseFigureWidget_for_each_trace",
    "description": "Apply a function to all traces that satisfy the specified selection\ncriteria\nParameters\n----------\nfn:\nFunction that inputs a single trace object.\nselector: dict, function, int, str or None (default None)\nDict to use as selection criteria.\nTraces will be selected if they contain properties corresponding\nto all of the dictionary's keys, with values that exactly match\nthe supplied values. If None (the default), all traces are\nselected. If a function, it must be a function accepting a single\nargument and returning a boolean. The function will be called on\neach trace and those for which the function returned True\nwill be in the selection. If an int N, the Nth trace matching row\nand col will be selected (N can be negative). If a string S, the selector\nis equivalent to dict(type=S).\nrow, col: int or None (default None)\nSubplot row and column index of traces to select.\nTo select traces by row and column, the Figure must have been\ncreated using plotly.subplots.make_subplots.  If None\n(the default), all traces are selected.\nsecondary_y: boolean or None (default None)\n* If True, only select traces associated with the secondary\ny-axis of the subplot.\n* If False, only select traces associated with the primary\ny-axis of the subplot.\n* If None (the default), do not filter traces based on secondary\ny-axis.\nTo select traces by secondary y-axis, the Figure must have been\ncreated using plotly.subplots.make_subplots. See the docstring\nfor the specs argument to make_subplots for more info on\ncreating subplots with secondary y-axes.\nReturns\n-------\nself\nReturns the Figure object that the method was called on",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fn": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "selector": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fn"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.for_each_trace",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.full_figure_for_development": {
    "name": "plotly_basewidget_BaseFigureWidget_full_figure_for_development",
    "description": "Compute default values for all attributes not specified in the input figure and\nreturns the output as a \"full\" figure. This function calls Plotly.js via Kaleido\nto populate unspecified attributes. This function is intended for interactive use\nduring development to learn more about how Plotly.js computes default values and is\nnot generally necessary or recommended for production use.\nParameters\n----------\nfig:\nFigure object or dict representing a figure\nwarn: bool\nIf False, suppress warnings about not using this in production.\nas_dict: bool\nIf True, output is a dict with some keys that go.Figure can't parse.\nIf False, output is a go.Figure with unparseable keys skipped.\nReturns\n-------\nplotly.graph_objects.Figure or dict\nThe full figure",
    "inputSchema": {
      "type": "object",
      "properties": {
        "warn": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "as_dict": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.full_figure_for_development",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.get_manager_state": {
    "name": "plotly_basewidget_BaseFigureWidget_get_manager_state",
    "description": "Returns the full state for a widget manager for embedding",
    "inputSchema": {
      "type": "object",
      "properties": {
        "drop_defaults": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "widgets": {
          "type": "integer",
          "description": "类型从参数名推断: widgets"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.get_manager_state",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.get_state": {
    "name": "plotly_basewidget_BaseFigureWidget_get_state",
    "description": "Gets the widget state, or a piece of it.\nParameters\n----------\nkey : unicode or iterable (optional)\nA single property's name or iterable of property names to get.\nReturns\n-------\nstate : dict of states\nmetadata : dict\nmetadata for each field: {key: metadata}",
    "inputSchema": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "drop_defaults": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.get_state",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.get_subplot": {
    "name": "plotly_basewidget_BaseFigureWidget_get_subplot",
    "description": "Return an object representing the subplot at the specified row\nand column.  May only be used on Figures created using\nplotly.tools.make_subplots\nParameters\n----------\nrow: int\n1-based index of subplot row\ncol: int\n1-based index of subplot column\nsecondary_y: bool\nIf True, select the subplot that consists of the x-axis and the\nsecondary y-axis at the specified row/col. Only valid if the\nsubplot at row/col is an 2D cartesian subplot that was created\nwith a secondary y-axis.  See the docstring for the specs argument\nto make_subplots for more info on creating a subplot with a\nsecondary y-axis.\nReturns\n-------\nsubplot\n* None: if subplot is empty\n* plotly.graph_objs.layout.Scene: if subplot type is 'scene'\n* plotly.graph_objs.layout.Polar: if subplot type is 'polar'\n* plotly.graph_objs.layout.Ternary: if subplot type is 'ternary'\n* plotly.graph_objs.layout.Mapbox: if subplot type is 'ternary'\n* SubplotDomain namedtuple with `x` and `y` fields:\nif subplot type is 'domain'.\n- x: length 2 list of the subplot start and stop width\n- y: length 2 list of the subplot start and stop height\n* SubplotXY namedtuple with `xaxis` and `yaxis` fields:\nif subplot type is 'xy'.\n- xaxis: plotly.graph_objs.layout.XAxis instance for subplot\n- yaxis: plotly.graph_objs.layout.YAxis instance for subplot",
    "inputSchema": {
      "type": "object",
      "properties": {
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "row",
        "col"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.get_subplot",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.get_view_spec": {
    "name": "plotly_basewidget_BaseFigureWidget_get_view_spec",
    "description": "获取数据（BaseFigureWidget类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.get_view_spec",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.handle_comm_opened": {
    "name": "plotly_basewidget_BaseFigureWidget_handle_comm_opened",
    "description": "Static method, called when a widget is constructed.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "comm": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "msg": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "comm",
        "msg"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.handle_comm_opened",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.has_trait": {
    "name": "plotly_basewidget_BaseFigureWidget_has_trait",
    "description": "Returns True if the object has a trait with the specified name.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "类型从参数名推断: name"
        }
      },
      "required": [
        "name"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.has_trait",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    },
    "outputSchema": {
      "type": "boolean"
    }
  },
  "plotly.basewidget.BaseFigureWidget.hold_sync": {
    "name": "plotly_basewidget_BaseFigureWidget_hold_sync",
    "description": "Hold syncing any state until the outermost context manager exits",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.hold_sync",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.hold_trait_notifications": {
    "name": "plotly_basewidget_BaseFigureWidget_hold_trait_notifications",
    "description": "Context manager for bundling trait change notifications and cross\nvalidation.\nUse this when doing multiple trait assignments (init, config), to avoid\nrace conditions in trait notifiers requesting other trait values.\nAll trait notifications will fire after all values have been assigned.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.hold_trait_notifications",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.notify_change": {
    "name": "plotly_basewidget_BaseFigureWidget_notify_change",
    "description": "Called when a property has changed.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "change": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "change"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.notify_change",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.observe": {
    "name": "plotly_basewidget_BaseFigureWidget_observe",
    "description": "Setup a handler to be called when a trait changes.\nThis is used to setup dynamic notifications of trait changes.\nParameters\n----------\nhandler : callable\nA callable that is called when a trait changes. Its\nsignature should be ``handler(change)``, where ``change`` is a\ndictionary. The change dictionary at least holds a 'type' key.\n* ``type``: the type of notification.\nOther keys may be passed depending on the value of 'type'. In the\ncase where type is 'change', we also have the following keys:\n* ``owner`` : the HasTraits instance\n* ``old`` : the old value of the modified trait attribute\n* ``new`` : the new value of the modified trait attribute\n* ``name`` : the name of the modified trait attribute.\nnames : list, str, All\nIf names is All, the handler will apply to all traits.  If a list\nof str, handler will apply to all names in the list.  If a\nstr, the handler will apply just to that name.\ntype : str, All (default: 'change')\nThe type of notification to filter by. If equal to All, then all\nnotifications are passed to the observe handler.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "handler": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "names": {
          "type": "string",
          "default": "traitlets.All",
          "description": "类型从默认值推断: Sentinel"
        },
        "type": {
          "type": "string",
          "default": "change",
          "description": "类型从默认值推断: str"
        }
      },
      "required": [
        "handler"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.observe",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.on_displayed": {
    "name": "plotly_basewidget_BaseFigureWidget_on_displayed",
    "description": "(Un)Register a widget displayed callback.\nParameters\n----------\ncallback: method handler\nMust have a signature of::\ncallback(widget, **kwargs)\nkwargs from display are passed through without modification.\nremove: bool\nTrue if the callback should be unregistered.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "callback": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "remove": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "callback"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.on_displayed",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.on_edits_completed": {
    "name": "plotly_basewidget_BaseFigureWidget_on_edits_completed",
    "description": "Register a function to be called after all pending trace and layout\nedit operations have completed\nIf there are no pending edit operations then function is called\nimmediately\nParameters\n----------\nfn : callable\nFunction of zero arguments to be called when all pending edit\noperations have completed",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fn": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fn"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.on_edits_completed",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.on_msg": {
    "name": "plotly_basewidget_BaseFigureWidget_on_msg",
    "description": "(Un)Register a custom msg receive callback.\nParameters\n----------\ncallback: callable\ncallback will be passed three arguments when a message arrives::\ncallback(widget, content, buffers)\nremove: bool\nTrue if the callback should be unregistered.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "callback": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "remove": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "callback"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.on_msg",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.on_trait_change": {
    "name": "plotly_basewidget_BaseFigureWidget_on_trait_change",
    "description": "DEPRECATED: Setup a handler to be called when a trait changes.\nThis is used to setup dynamic notifications of trait changes.\nStatic handlers can be created by creating methods on a HasTraits\nsubclass with the naming convention '_[traitname]_changed'.  Thus,\nto create static handler for the trait 'a', create the method\n_a_changed(self, name, old, new) (fewer arguments can be used, see\nbelow).\nIf `remove` is True and `handler` is not specified, all change\nhandlers for the specified name are uninstalled.\nParameters\n----------\nhandler : callable, None\nA callable that is called when a trait changes.  Its\nsignature can be handler(), handler(name), handler(name, new),\nhandler(name, old, new), or handler(name, old, new, self).\nname : list, str, None\nIf None, the handler will apply to all traits.  If a list\nof str, handler will apply to all names in the list.  If a\nstr, the handler will apply just to that name.\nremove : bool\nIf False (the default), then install the handler.  If True\nthen unintall it.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "handler": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "name": {
          "type": "string",
          "description": "类型从参数名推断: name"
        },
        "remove": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.on_trait_change",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.on_widget_constructed": {
    "name": "plotly_basewidget_BaseFigureWidget_on_widget_constructed",
    "description": "Registers a callback to be called when a widget is constructed.\nThe callback must have the following signature:\ncallback(widget)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "callback": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "callback"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.on_widget_constructed",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.open": {
    "name": "plotly_basewidget_BaseFigureWidget_open",
    "description": "Open a comm to the frontend if one isn't already open.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.open",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.plotly_relayout": {
    "name": "plotly_basewidget_BaseFigureWidget_plotly_relayout",
    "description": "Perform a Plotly relayout operation on the figure's layout\nParameters\n----------\nrelayout_data : dict\nDict of layout updates\ndict keys are strings that specify the properties to be updated.\nNested properties are expressed by joining successive keys on\n'.' characters (e.g. 'xaxis.range')\ndict values are the values to use to update the layout.\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "relayout_data": {
          "type": "object",
          "description": "类型从参数名推断: relayout_data"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "relayout_data",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.plotly_relayout",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.plotly_restyle": {
    "name": "plotly_basewidget_BaseFigureWidget_plotly_restyle",
    "description": "Perform a Plotly restyle operation on the figure's traces\nParameters\n----------\nrestyle_data : dict\nDict of trace style updates.\nKeys are strings that specify the properties to be updated.\nNested properties are expressed by joining successive keys on\n'.' characters (e.g. 'marker.color').\nValues may be scalars or lists. When values are scalars,\nthat scalar value is applied to all traces specified by the\n`trace_indexes` parameter.  When values are lists,\nthe restyle operation will cycle through the elements\nof the list as it cycles through the traces specified by the\n`trace_indexes` parameter.\nCaution: To use plotly_restyle to update a list property (e.g.\nthe `x` property of the scatter trace), the property value\nshould be a scalar list containing the list to update with. For\nexample, the following command would be used to update the 'x'\nproperty of the first trace to the list [1, 2, 3]\n>>> import plotly.graph_objects as go\n>>> fig = go.Figure(go.Scatter(x=[2, 4, 6]))\n>>> fig.plotly_restyle({'x': [[1, 2, 3]]}, 0)\ntrace_indexes : int or list of int\nTrace index, or list of trace indexes, that the restyle operation\napplies to. Defaults to all trace indexes.\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "restyle_data": {
          "type": "object",
          "description": "类型从参数名推断: restyle_data"
        },
        "trace_indexes": {
          "type": "integer",
          "description": "类型从参数名推断: trace_indexes"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "restyle_data",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.plotly_restyle",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.plotly_update": {
    "name": "plotly_basewidget_BaseFigureWidget_plotly_update",
    "description": "Perform a Plotly update operation on the figure.\n\nNote: This operation both mutates and returns the figure\n\nParameters\n----------\nrestyle_data : dict\nTraces update specification. See the docstring for the\n`plotly_restyle` method for details\nrelayout_data : dict\nLayout update specification. See the docstring for the\n`plotly_relayout` method for details\ntrace_indexes :\nTrace index, or list of trace indexes, that the update operation\napplies to. Defaults to all trace indexes.\n\nReturns\n-------\nBaseFigure\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "restyle_data": {
          "type": "object",
          "description": "类型从参数名推断: restyle_data"
        },
        "relayout_data": {
          "type": "object",
          "description": "类型从参数名推断: relayout_data"
        },
        "trace_indexes": {
          "type": "integer",
          "description": "类型从参数名推断: trace_indexes"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.plotly_update",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.pop": {
    "name": "plotly_basewidget_BaseFigureWidget_pop",
    "description": "Remove the value associated with the specified key and return it\nParameters\n----------\nkey: str\nProperty name\ndflt\nThe default value to return if key was not found in figure\nReturns\n-------\nvalue\nThe removed value that was previously associated with key\nRaises\n------\nKeyError\nIf key is not in object and no dflt argument specified",
    "inputSchema": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "key",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.pop",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.print_grid": {
    "name": "plotly_basewidget_BaseFigureWidget_print_grid",
    "description": "Print a visual layout of the figure's axes arrangement.\nThis is only valid for figures that are created\nwith plotly.tools.make_subplots.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.print_grid",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.remove_class": {
    "name": "plotly_basewidget_BaseFigureWidget_remove_class",
    "description": "Removes a class from the top level element of the widget.\nDoesn't remove the class if it doesn't exist.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "className": {
          "type": "string",
          "description": "类型从参数名推断: className"
        }
      },
      "required": [
        "className"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.remove_class",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.select_traces": {
    "name": "plotly_basewidget_BaseFigureWidget_select_traces",
    "description": "Select traces from a particular subplot cell and/or traces\nthat satisfy custom selection criteria.\nParameters\n----------\nselector: dict, function, int, str or None (default None)\nDict to use as selection criteria.\nTraces will be selected if they contain properties corresponding\nto all of the dictionary's keys, with values that exactly match\nthe supplied values. If None (the default), all traces are\nselected. If a function, it must be a function accepting a single\nargument and returning a boolean. The function will be called on\neach trace and those for which the function returned True\nwill be in the selection. If an int N, the Nth trace matching row\nand col will be selected (N can be negative). If a string S, the selector\nis equivalent to dict(type=S).\nrow, col: int or None (default None)\nSubplot row and column index of traces to select.\nTo select traces by row and column, the Figure must have been\ncreated using plotly.subplots.make_subplots.  If None\n(the default), all traces are selected.\nsecondary_y: boolean or None (default None)\n* If True, only select traces associated with the secondary\ny-axis of the subplot.\n* If False, only select traces associated with the primary\ny-axis of the subplot.\n* If None (the default), do not filter traces based on secondary\ny-axis.\nTo select traces by secondary y-axis, the Figure must have been\ncreated using plotly.subplots.make_subplots. See the docstring\nfor the specs argument to make_subplots for more info on\ncreating subplots with secondary y-axes.\nReturns\n-------\ngenerator\nGenerator that iterates through all of the traces that satisfy\nall of the specified selection criteria",
    "inputSchema": {
      "type": "object",
      "properties": {
        "selector": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.select_traces",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.send": {
    "name": "plotly_basewidget_BaseFigureWidget_send",
    "description": "Sends a custom msg to the widget model in the front-end.\nParameters\n----------\ncontent : dict\nContent of the message to send.\nbuffers : list of binary buffers\nBinary buffers to send with message",
    "inputSchema": {
      "type": "object",
      "properties": {
        "content": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "buffers": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "content"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.send",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.send_state": {
    "name": "plotly_basewidget_BaseFigureWidget_send_state",
    "description": "Sends the widget state, or a piece of it, to the front-end, if it exists.\nParameters\n----------\nkey : unicode, or iterable (optional)\nA single property's name or iterable of property names to sync with the front-end.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.send_state",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.set_state": {
    "name": "plotly_basewidget_BaseFigureWidget_set_state",
    "description": "Called when a state is received from the front-end.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "sync_data": {
          "type": "object",
          "description": "类型从参数名推断: sync_data"
        }
      },
      "required": [
        "sync_data"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.set_state",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.set_subplots": {
    "name": "plotly_basewidget_BaseFigureWidget_set_subplots",
    "description": "Add subplots to this figure. If the figure already contains subplots,\nthen this throws an error. Accepts any keyword arguments that\nplotly.subplots.make_subplots accepts.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "rows": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "cols": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "make_subplots_args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "make_subplots_args"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.set_subplots",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.set_trait": {
    "name": "plotly_basewidget_BaseFigureWidget_set_trait",
    "description": "Forcibly sets trait attribute, including read-only attributes.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "类型从参数名推断: name"
        },
        "value": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "name",
        "value"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.set_trait",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.setup_instance": {
    "name": "plotly_basewidget_BaseFigureWidget_setup_instance",
    "description": "设置数据（BaseFigureWidget类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.setup_instance",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.show": {
    "name": "plotly_basewidget_BaseFigureWidget_show",
    "description": "Show a figure using either the default renderer(s) or the renderer(s)\nspecified by the renderer argument\nParameters\n----------\nrenderer: str or None (default None)\nA string containing the names of one or more registered renderers\n(separated by '+' characters) or None.  If None, then the default\nrenderers specified in plotly.io.renderers.default are used.\nvalidate: bool (default True)\nTrue if the figure should be validated before being shown,\nFalse otherwise.\nwidth: int or float\nAn integer or float that determines the number of pixels wide the\nplot is. The default is set in plotly.js.\nheight: int or float\nAn integer or float that determines the number of pixels wide the\nplot is. The default is set in plotly.js.\nconfig: dict\nA dict of parameters to configure the figure. The defaults are set\nin plotly.js.\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.show",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.to_dict": {
    "name": "plotly_basewidget_BaseFigureWidget_to_dict",
    "description": "Convert figure to a dictionary\n\nNote: the dictionary includes the properties explicitly set by the\nuser, it does not include default values of unspecified properties\n\nReturns\n-------\ndict",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.to_dict",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.to_html": {
    "name": "plotly_basewidget_BaseFigureWidget_to_html",
    "description": "Convert a figure to an HTML string representation.\nParameters\n----------\nconfig: dict or None (default None)\nPlotly.js figure config options\nauto_play: bool (default=True)\nWhether to automatically start the animation sequence on page load\nif the figure contains frames. Has no effect if the figure does not\ncontain frames.\ninclude_plotlyjs: bool or string (default True)\nSpecifies how the plotly.js library is included/loaded in the output\ndiv string.\nIf True, a script tag containing the plotly.js source code (~3MB)\nis included in the output.  HTML files generated with this option are\nfully self-contained and can be used offline.\nIf 'cdn', a script tag that references the plotly.js CDN is included\nin the output. HTML files generated with this option are about 3MB\nsmaller than those generated with include_plotlyjs=True, but they\nrequire an active internet connection in order to load the plotly.js\nlibrary.\nIf 'directory', a script tag is included that references an external\nplotly.min.js bundle that is assumed to reside in the same\ndirectory as the HTML file.\nIf 'require', Plotly.js is loaded using require.js.  This option\nassumes that require.js is globally available and that it has been\nglobally configured to know how to find Plotly.js as 'plotly'.\nThis option is not advised when full_html=True as it will result\nin a non-functional html file.\nIf a string that ends in '.js', a script tag is included that\nreferences the specified path. This approach can be used to point\nthe resulting HTML file to an alternative CDN or local bundle.\nIf False, no script tag referencing plotly.js is included. This is\nuseful when the resulting div string will be placed inside an HTML\ndocument that already loads plotly.js. This option is not advised\nwhen full_html=True as it will result in a non-functional html file.\ninclude_mathjax: bool or string (default False)\nSpecifies how the MathJax.js library is included in the output html\ndiv string.  MathJax is required in order to display labels\nwith LaTeX typesetting.\nIf False, no script tag referencing MathJax.js will be included in the\noutput.\nIf 'cdn', a script tag that references a MathJax CDN location will be\nincluded in the output.  HTML div strings generated with this option\nwill be able to display LaTeX typesetting as long as internet access\nis available.\nIf a string that ends in '.js', a script tag is included that\nreferences the specified path. This approach can be used to point the\nresulting HTML div string to an alternative CDN.\npost_script: str or list or None (default None)\nJavaScript snippet(s) to be included in the resulting div just after\nplot creation.  The string(s) may include '{plot_id}' placeholders\nthat will then be replaced by the `id` of the div element that the\nplotly.js figure is associated with.  One application for this script\nis to install custom plotly.js event handlers.\nfull_html: bool (default True)\nIf True, produce a string containing a complete HTML document\nstarting with an <html> tag.  If False, produce a string containing\na single <div> element.\nanimation_opts: dict or None (default None)\ndict of custom animation parameters to be passed to the function\nPlotly.animate in Plotly.js. See\nhttps://github.com/plotly/plotly.js/blob/master/src/plots/animation_attributes.js\nfor available options. Has no effect if the figure does not contain\nframes, or auto_play is False.\ndefault_width, default_height: number or str (default '100%')\nThe default figure width/height to use if the provided figure does not\nspecify its own layout.width/layout.height property.  May be\nspecified in pixels as an integer (e.g. 500), or as a css width style\nstring (e.g. '500px', '100%').\nvalidate: bool (default True)\nTrue if the figure should be validated before being converted to\nJSON, False otherwise.\ndiv_id: str (default None)\nIf provided, this is the value of the id attribute of the div tag. If None, the\nid attribute is a UUID.\nReturns\n-------\nstr\nRepresentation of figure as an HTML div string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.to_html",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.to_image": {
    "name": "plotly_basewidget_BaseFigureWidget_to_image",
    "description": "Convert a figure to a static image bytes string\nParameters\n----------\nformat: str or None\nThe desired image format. One of\n- 'png'\n- 'jpg' or 'jpeg'\n- 'webp'\n- 'svg'\n- 'pdf'\n- 'eps' (Requires the poppler library to be installed)\nIf not specified, will default to `plotly.io.config.default_format`\nwidth: int or None\nThe width of the exported image in layout pixels. If the `scale`\nproperty is 1.0, this will also be the width of the exported image\nin physical pixels.\nIf not specified, will default to `plotly.io.config.default_width`\nheight: int or None\nThe height of the exported image in layout pixels. If the `scale`\nproperty is 1.0, this will also be the height of the exported image\nin physical pixels.\nIf not specified, will default to `plotly.io.config.default_height`\nscale: int or float or None\nThe scale factor to use when exporting the figure. A scale factor\nlarger than 1.0 will increase the image resolution with respect\nto the figure's layout pixel dimensions. Whereas as scale factor of\nless than 1.0 will decrease the image resolution.\nIf not specified, will default to `plotly.io.config.default_scale`\nvalidate: bool\nTrue if the figure should be validated before being converted to\nan image, False otherwise.\nengine: str\nImage export engine to use:\n- \"kaleido\": Use Kaleido for image export\n- \"orca\": Use Orca for image export\n- \"auto\" (default): Use Kaleido if installed, otherwise use orca\nReturns\n-------\nbytes\nThe image data",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.to_image",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.to_json": {
    "name": "plotly_basewidget_BaseFigureWidget_to_json",
    "description": "Convert a figure to a JSON string representation\nParameters\n----------\nvalidate: bool (default True)\nTrue if the figure should be validated before being converted to\nJSON, False otherwise.\npretty: bool (default False)\nTrue if JSON representation should be pretty-printed, False if\nrepresentation should be as compact as possible.\nremove_uids: bool (default True)\nTrue if trace UIDs should be omitted from the JSON representation\nengine: str (default None)\nThe JSON encoding engine to use. One of:\n- \"json\" for an encoder based on the built-in Python json module\n- \"orjson\" for a fast encoder the requires the orjson package\nIf not specified, the default encoder is set to the current value of\nplotly.io.json.config.default_encoder.\nReturns\n-------\nstr\nRepresentation of figure as a JSON string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.to_json",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.to_ordered_dict": {
    "name": "plotly_basewidget_BaseFigureWidget_to_ordered_dict",
    "description": "执行to_ordered_dict操作（BaseFigureWidget类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skip_uid": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.to_ordered_dict",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.to_plotly_json": {
    "name": "plotly_basewidget_BaseFigureWidget_to_plotly_json",
    "description": "Convert figure to a JSON representation as a Python dict\n\nNote: May include some JSON-invalid data types, use the `PlotlyJSONEncoder` util\nor the `to_json` method to encode to a string.\n\nReturns\n-------\ndict",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.to_plotly_json",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.trait_defaults": {
    "name": "plotly_basewidget_BaseFigureWidget_trait_defaults",
    "description": "Return a trait's default value or a dictionary of them\nNotes\n-----\nDynamically generated default values may\ndepend on the current state of the object.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "names": {
          "type": "string",
          "description": "类型从参数名推断: names"
        },
        "metadata": {
          "type": "object",
          "description": "类型从参数名推断: metadata"
        }
      },
      "required": [
        "names",
        "metadata"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.trait_defaults",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.trait_has_value": {
    "name": "plotly_basewidget_BaseFigureWidget_trait_has_value",
    "description": "Returns True if the specified trait has a value.\nThis will return false even if ``getattr`` would return a\ndynamically generated default value. These default values\nwill be recognized as existing only after they have been\ngenerated.\nExample\n.. code-block:: python\nclass MyClass(HasTraits):\ni = Int()\nmc = MyClass()\nassert not mc.trait_has_value(\"i\")\nmc.i # generates a default value\nassert mc.trait_has_value(\"i\")",
    "inputSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "类型从参数名推断: name"
        }
      },
      "required": [
        "name"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.trait_has_value",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.trait_metadata": {
    "name": "plotly_basewidget_BaseFigureWidget_trait_metadata",
    "description": "Get metadata values for trait by key.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "traitname": {
          "type": "string",
          "description": "类型从参数名推断: traitname"
        },
        "key": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "default": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "traitname",
        "key"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.trait_metadata",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.trait_names": {
    "name": "plotly_basewidget_BaseFigureWidget_trait_names",
    "description": "Get a list of all the names of this class' traits.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "metadata": {
          "type": "object",
          "description": "类型从参数名推断: metadata"
        }
      },
      "required": [
        "metadata"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.trait_names",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.trait_values": {
    "name": "plotly_basewidget_BaseFigureWidget_trait_values",
    "description": "A ``dict`` of trait names and their values.\nThe metadata kwargs allow functions to be passed in which\nfilter traits based on metadata values.  The functions should\ntake a single value as an argument and return a boolean.  If\nany function returns False, then the trait is not included in\nthe output.  If a metadata key doesn't exist, None will be passed\nto the function.\nReturns\n-------\nA ``dict`` of trait names and their values.\nNotes\n-----\nTrait values are retrieved via ``getattr``, any exceptions raised\nby traits or the operations they may trigger will result in the\nabsence of a trait value in the result ``dict``.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "metadata": {
          "type": "object",
          "description": "类型从参数名推断: metadata"
        }
      },
      "required": [
        "metadata"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.trait_values",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.traits": {
    "name": "plotly_basewidget_BaseFigureWidget_traits",
    "description": "Get a ``dict`` of all the traits of this class.  The dictionary\nis keyed on the name and the values are the TraitType objects.\nThe TraitTypes returned don't know anything about the values\nthat the various HasTrait's instances are holding.\nThe metadata kwargs allow functions to be passed in which\nfilter traits based on metadata values.  The functions should\ntake a single value as an argument and return a boolean.  If\nany function returns False, then the trait is not included in\nthe output.  If a metadata key doesn't exist, None will be passed\nto the function.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "metadata": {
          "type": "object",
          "description": "类型从参数名推断: metadata"
        }
      },
      "required": [
        "metadata"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.traits",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.unobserve": {
    "name": "plotly_basewidget_BaseFigureWidget_unobserve",
    "description": "Remove a trait change handler.\nThis is used to unregister handlers to trait change notifications.\nParameters\n----------\nhandler : callable\nThe callable called when a trait attribute changes.\nnames : list, str, All (default: All)\nThe names of the traits for which the specified handler should be\nuninstalled. If names is All, the specified handler is uninstalled\nfrom the list of notifiers corresponding to all changes.\ntype : str or All (default: 'change')\nThe type of notification to filter by. If All, the specified handler\nis uninstalled from the list of notifiers corresponding to all types.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "handler": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "names": {
          "type": "string",
          "default": "traitlets.All",
          "description": "类型从默认值推断: Sentinel"
        },
        "type": {
          "type": "string",
          "default": "change",
          "description": "类型从默认值推断: str"
        }
      },
      "required": [
        "handler"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.unobserve",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.unobserve_all": {
    "name": "plotly_basewidget_BaseFigureWidget_unobserve_all",
    "description": "Remove trait change handlers of any type for the specified name.\nIf name is not specified, removes all trait notifiers.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "default": "traitlets.All",
          "description": "类型从默认值推断: Sentinel"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.unobserve_all",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.update": {
    "name": "plotly_basewidget_BaseFigureWidget_update",
    "description": "Update the properties of the figure with a dict and/or with\nkeyword arguments.\nThis recursively updates the structure of the figure\nobject with the values in the input dict / keyword arguments.\nParameters\n----------\ndict1 : dict\nDictionary of properties to be updated\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\nkwargs :\nKeyword/value pair of properties to be updated\nExamples\n--------\n>>> import plotly.graph_objs as go\n>>> fig = go.Figure(data=[{'y': [1, 2, 3]}])\n>>> fig.update(data=[{'y': [4, 5, 6]}]) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.to_plotly_json() # doctest: +SKIP\n{'data': [{'type': 'scatter',\n'uid': 'e86a7c7a-346a-11e8-8aa8-a0999b0c017b',\n'y': array([4, 5, 6], dtype=int32)}],\n'layout': {}}\n>>> fig = go.Figure(layout={'xaxis':\n...                         {'color': 'green',\n...                          'range': [0, 1]}})\n>>> fig.update({'layout': {'xaxis': {'color': 'pink'}}}) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.to_plotly_json() # doctest: +SKIP\n{'data': [],\n'layout': {'xaxis':\n{'color': 'pink',\n'range': [0, 1]}}}\nReturns\n-------\nBaseFigure\nUpdated figure",
    "inputSchema": {
      "type": "object",
      "properties": {
        "dict1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.update",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.update_layout": {
    "name": "plotly_basewidget_BaseFigureWidget_update_layout",
    "description": "Update the properties of the figure's layout with a dict and/or with\nkeyword arguments.\nThis recursively updates the structure of the original\nlayout with the values in the input dict / keyword arguments.\nParameters\n----------\ndict1 : dict\nDictionary of properties to be updated\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\nkwargs :\nKeyword/value pair of properties to be updated\nReturns\n-------\nBaseFigure\nThe Figure object that the update_layout method was called on",
    "inputSchema": {
      "type": "object",
      "properties": {
        "dict1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.update_layout",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.update_traces": {
    "name": "plotly_basewidget_BaseFigureWidget_update_traces",
    "description": "Perform a property update operation on all traces that satisfy the\nspecified selection criteria\nParameters\n----------\npatch: dict or None (default None)\nDictionary of property updates to be applied to all traces that\nsatisfy the selection criteria.\nselector: dict, function, int, str or None (default None)\nDict to use as selection criteria.\nTraces will be selected if they contain properties corresponding\nto all of the dictionary's keys, with values that exactly match\nthe supplied values. If None (the default), all traces are\nselected. If a function, it must be a function accepting a single\nargument and returning a boolean. The function will be called on\neach trace and those for which the function returned True\nwill be in the selection. If an int N, the Nth trace matching row\nand col will be selected (N can be negative). If a string S, the selector\nis equivalent to dict(type=S).\nrow, col: int or None (default None)\nSubplot row and column index of traces to select.\nTo select traces by row and column, the Figure must have been\ncreated using plotly.subplots.make_subplots.  If None\n(the default), all traces are selected.\nsecondary_y: boolean or None (default None)\n* If True, only select traces associated with the secondary\ny-axis of the subplot.\n* If False, only select traces associated with the primary\ny-axis of the subplot.\n* If None (the default), do not filter traces based on secondary\ny-axis.\nTo select traces by secondary y-axis, the Figure must have been\ncreated using plotly.subplots.make_subplots. See the docstring\nfor the specs argument to make_subplots for more info on\ncreating subplots with secondary y-axes.\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\n**kwargs\nAdditional property updates to apply to each selected trace. If\na property is specified in both patch and in **kwargs then the\none in **kwargs takes precedence.\nReturns\n-------\nself\nReturns the Figure object that the method was called on",
    "inputSchema": {
      "type": "object",
      "properties": {
        "patch": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "selector": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.update_traces",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.write_html": {
    "name": "plotly_basewidget_BaseFigureWidget_write_html",
    "description": "Write a figure to an HTML file representation\nParameters\n----------\nfile: str or writeable\nA string representing a local file path or a writeable object\n(e.g. a pathlib.Path object or an open file descriptor)\nconfig: dict or None (default None)\nPlotly.js figure config options\nauto_play: bool (default=True)\nWhether to automatically start the animation sequence on page load\nif the figure contains frames. Has no effect if the figure does not\ncontain frames.\ninclude_plotlyjs: bool or string (default True)\nSpecifies how the plotly.js library is included/loaded in the output\ndiv string.\nIf True, a script tag containing the plotly.js source code (~3MB)\nis included in the output.  HTML files generated with this option are\nfully self-contained and can be used offline.\nIf 'cdn', a script tag that references the plotly.js CDN is included\nin the output. HTML files generated with this option are about 3MB\nsmaller than those generated with include_plotlyjs=True, but they\nrequire an active internet connection in order to load the plotly.js\nlibrary.\nIf 'directory', a script tag is included that references an external\nplotly.min.js bundle that is assumed to reside in the same\ndirectory as the HTML file. If `file` is a string to a local file path\nand `full_html` is True then\nIf 'directory', a script tag is included that references an external\nplotly.min.js bundle that is assumed to reside in the same\ndirectory as the HTML file.  If `file` is a string to a local file\npath and `full_html` is True, then the plotly.min.js bundle is copied\ninto the directory of the resulting HTML file. If a file named\nplotly.min.js already exists in the output directory then this file\nis left unmodified and no copy is performed. HTML files generated\nwith this option can be used offline, but they require a copy of\nthe plotly.min.js bundle in the same directory. This option is\nuseful when many figures will be saved as HTML files in the same\ndirectory because the plotly.js source code will be included only\nonce per output directory, rather than once per output file.\nIf 'require', Plotly.js is loaded using require.js.  This option\nassumes that require.js is globally available and that it has been\nglobally configured to know how to find Plotly.js as 'plotly'.\nThis option is not advised when full_html=True as it will result\nin a non-functional html file.\nIf a string that ends in '.js', a script tag is included that\nreferences the specified path. This approach can be used to point\nthe resulting HTML file to an alternative CDN or local bundle.\nIf False, no script tag referencing plotly.js is included. This is\nuseful when the resulting div string will be placed inside an HTML\ndocument that already loads plotly.js.  This option is not advised\nwhen full_html=True as it will result in a non-functional html file.\ninclude_mathjax: bool or string (default False)\nSpecifies how the MathJax.js library is included in the output html\ndiv string.  MathJax is required in order to display labels\nwith LaTeX typesetting.\nIf False, no script tag referencing MathJax.js will be included in the\noutput.\nIf 'cdn', a script tag that references a MathJax CDN location will be\nincluded in the output.  HTML div strings generated with this option\nwill be able to display LaTeX typesetting as long as internet access\nis available.\nIf a string that ends in '.js', a script tag is included that\nreferences the specified path. This approach can be used to point the\nresulting HTML div string to an alternative CDN.\npost_script: str or list or None (default None)\nJavaScript snippet(s) to be included in the resulting div just after\nplot creation.  The string(s) may include '{plot_id}' placeholders\nthat will then be replaced by the `id` of the div element that the\nplotly.js figure is associated with.  One application for this script\nis to install custom plotly.js event handlers.\nfull_html: bool (default True)\nIf True, produce a string containing a complete HTML document\nstarting with an <html> tag.  If False, produce a string containing\na single <div> element.\nanimation_opts: dict or None (default None)\ndict of custom animation parameters to be passed to the function\nPlotly.animate in Plotly.js. See\nhttps://github.com/plotly/plotly.js/blob/master/src/plots/animation_attributes.js\nfor available options. Has no effect if the figure does not contain\nframes, or auto_play is False.\ndefault_width, default_height: number or str (default '100%')\nThe default figure width/height to use if the provided figure does not\nspecify its own layout.width/layout.height property.  May be\nspecified in pixels as an integer (e.g. 500), or as a css width style\nstring (e.g. '500px', '100%').\nvalidate: bool (default True)\nTrue if the figure should be validated before being converted to\nJSON, False otherwise.\nauto_open: bool (default True)\nIf True, open the saved file in a web browser after saving.\nThis argument only applies if `full_html` is True.\ndiv_id: str (default None)\nIf provided, this is the value of the id attribute of the div tag. If None, the\nid attribute is a UUID.\nReturns\n-------\nstr\nRepresentation of figure as an HTML div string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.write_html",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.write_image": {
    "name": "plotly_basewidget_BaseFigureWidget_write_image",
    "description": "Convert a figure to a static image and write it to a file or writeable\nobject\nParameters\n----------\nfile: str or writeable\nA string representing a local file path or a writeable object\n(e.g. a pathlib.Path object or an open file descriptor)\nformat: str or None\nThe desired image format. One of\n- 'png'\n- 'jpg' or 'jpeg'\n- 'webp'\n- 'svg'\n- 'pdf'\n- 'eps' (Requires the poppler library to be installed)\nIf not specified and `file` is a string then this will default to the\nfile extension. If not specified and `file` is not a string then this\nwill default to `plotly.io.config.default_format`\nwidth: int or None\nThe width of the exported image in layout pixels. If the `scale`\nproperty is 1.0, this will also be the width of the exported image\nin physical pixels.\nIf not specified, will default to `plotly.io.config.default_width`\nheight: int or None\nThe height of the exported image in layout pixels. If the `scale`\nproperty is 1.0, this will also be the height of the exported image\nin physical pixels.\nIf not specified, will default to `plotly.io.config.default_height`\nscale: int or float or None\nThe scale factor to use when exporting the figure. A scale factor\nlarger than 1.0 will increase the image resolution with respect\nto the figure's layout pixel dimensions. Whereas as scale factor of\nless than 1.0 will decrease the image resolution.\nIf not specified, will default to `plotly.io.config.default_scale`\nvalidate: bool\nTrue if the figure should be validated before being converted to\nan image, False otherwise.\nengine: str\nImage export engine to use:\n- \"kaleido\": Use Kaleido for image export\n- \"orca\": Use Orca for image export\n- \"auto\" (default): Use Kaleido if installed, otherwise use orca\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.write_image",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.basewidget.BaseFigureWidget.write_json": {
    "name": "plotly_basewidget_BaseFigureWidget_write_json",
    "description": "Convert a figure to JSON and write it to a file or writeable\nobject\nParameters\n----------\nfile: str or writeable\nA string representing a local file path or a writeable object\n(e.g. an open file descriptor)\npretty: bool (default False)\nTrue if JSON representation should be pretty-printed, False if\nrepresentation should be as compact as possible.\nremove_uids: bool (default True)\nTrue if trace UIDs should be omitted from the JSON representation\nengine: str (default None)\nThe JSON encoding engine to use. One of:\n- \"json\" for an encoder based on the built-in Python json module\n- \"orjson\" for a fast encoder the requires the orjson package\nIf not specified, the default encoder is set to the current value of\nplotly.io.json.config.default_encoder.\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.basewidget.BaseFigureWidget.write_json",
      "module": "plotly.basewidget",
      "class_name": "BaseFigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.conftest.pytest_ignore_collect": {
    "name": "plotly_conftest_pytest_ignore_collect",
    "description": "执行pytest_ignore_collect操作（plotly.conftest模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "path"
      ]
    },
    "metadata": {
      "source_function": "plotly.conftest.pytest_ignore_collect",
      "module": "plotly.conftest",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.data.carshare": {
    "name": "plotly_data_carshare",
    "description": "执行carshare操作，来自plotly.data模块",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.data.carshare",
      "module": "plotly.data",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.data.election": {
    "name": "plotly_data_election",
    "description": "执行election操作，来自plotly.data模块",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.data.election",
      "module": "plotly.data",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.data.election_geojson": {
    "name": "plotly_data_election_geojson",
    "description": "执行election_geojson操作，来自plotly.data模块",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.data.election_geojson",
      "module": "plotly.data",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.data.experiment": {
    "name": "plotly_data_experiment",
    "description": "执行experiment操作，来自plotly.data模块",
    "inputSchema": {
      "type": "object",
      "properties": {
        "indexed": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.data.experiment",
      "module": "plotly.data",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.data.gapminder": {
    "name": "plotly_data_gapminder",
    "description": "执行gapminder操作，来自plotly.data模块",
    "inputSchema": {
      "type": "object",
      "properties": {
        "datetimes": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "centroids": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "year": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "pretty_names": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.data.gapminder",
      "module": "plotly.data",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.data.iris": {
    "name": "plotly_data_iris",
    "description": "执行iris操作，来自plotly.data模块",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.data.iris",
      "module": "plotly.data",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.data.medals_long": {
    "name": "plotly_data_medals_long",
    "description": "执行medals_long操作，来自plotly.data模块",
    "inputSchema": {
      "type": "object",
      "properties": {
        "indexed": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.data.medals_long",
      "module": "plotly.data",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.data.medals_wide": {
    "name": "plotly_data_medals_wide",
    "description": "执行medals_wide操作，来自plotly.data模块",
    "inputSchema": {
      "type": "object",
      "properties": {
        "indexed": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.data.medals_wide",
      "module": "plotly.data",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.data.stocks": {
    "name": "plotly_data_stocks",
    "description": "执行stocks操作，来自plotly.data模块",
    "inputSchema": {
      "type": "object",
      "properties": {
        "indexed": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "datetimes": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.data.stocks",
      "module": "plotly.data",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.data.tips": {
    "name": "plotly_data_tips",
    "description": "执行tips操作，来自plotly.data模块",
    "inputSchema": {
      "type": "object",
      "properties": {
        "pretty_names": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.data.tips",
      "module": "plotly.data",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.data.wind": {
    "name": "plotly_data_wind",
    "description": "执行wind操作，来自plotly.data模块",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.data.wind",
      "module": "plotly.data",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.express.imshow_utils.intensity_range": {
    "name": "plotly_express_imshow_utils_intensity_range",
    "description": "Return image intensity range (min, max) based on desired value type.\n\nParameters\n----------\nimage : array\nInput image.\nrange_values : str or 2-tuple, optional\nThe image intensity range is configured by this parameter.\nThe possible values for this parameter are enumerated below.\n\n'image'\nReturn image min/max as the range.\n'dtype'\nReturn min/max of the image's dtype as the range.\ndtype-name\nReturn intensity range based on desired `dtype`. Must be valid key\nin `DTYPE_RANGE`. Note: `image` is ignored for this range type.\n2-tuple\nReturn `range_values` as min/max intensities. Note that there's no\nreason to use this function if you just want to specify the\nintensity range explicitly. This option is included for functions\nthat use `intensity_range` to support all desired range types.\n\nclip_negative : bool, optional\nIf True, clip the negative range (i.e. return 0 for min intensity)\neven if the image dtype allows negative values.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "image": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "range_values": {
          "type": "string",
          "default": "image",
          "description": "类型从默认值推断: str"
        },
        "clip_negative": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "image"
      ]
    },
    "metadata": {
      "source_function": "plotly.express.imshow_utils.intensity_range",
      "module": "plotly.express.imshow_utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.express.imshow_utils.rescale_intensity": {
    "name": "plotly_express_imshow_utils_rescale_intensity",
    "description": "Return image after stretching or shrinking its intensity levels.\nThe desired intensity range of the input and output, `in_range` and\n`out_range` respectively, are used to stretch or shrink the intensity range\nof the input image. See examples below.\nParameters\n----------\nimage : array\nImage array.\nin_range, out_range : str or 2-tuple, optional\nMin and max intensity values of input and output image.\nThe possible values for this parameter are enumerated below.\n'image'\nUse image min/max as the intensity range.\n'dtype'\nUse min/max of the image's dtype as the intensity range.\ndtype-name\nUse intensity range based on desired `dtype`. Must be valid key\nin `DTYPE_RANGE`.\n2-tuple\nUse `range_values` as explicit min/max intensities.\nReturns\n-------\nout : array\nImage array after rescaling its intensity. This image is the same dtype\nas the input image.\nNotes\n-----\n.. versionchanged:: 0.17\nThe dtype of the output array has changed to match the output dtype, or\nfloat if the output range is specified by a pair of floats.\nSee Also\n--------\nequalize_hist\nExamples\n--------\nBy default, the min/max intensities of the input image are stretched to\nthe limits allowed by the image's dtype, since `in_range` defaults to\n'image' and `out_range` defaults to 'dtype':\n>>> image = np.array([51, 102, 153], dtype=np.uint8)\n>>> rescale_intensity(image)\narray([  0, 127, 255], dtype=uint8)\nIt's easy to accidentally convert an image dtype from uint8 to float:\n>>> 1.0 * image\narray([ 51., 102., 153.])\nUse `rescale_intensity` to rescale to the proper range for float dtypes:\n>>> image_float = 1.0 * image\n>>> rescale_intensity(image_float)\narray([0. , 0.5, 1. ])\nTo maintain the low contrast of the original, use the `in_range` parameter:\n>>> rescale_intensity(image_float, in_range=(0, 255))\narray([0.2, 0.4, 0.6])\nIf the min/max value of `in_range` is more/less than the min/max image\nintensity, then the intensity levels are clipped:\n>>> rescale_intensity(image_float, in_range=(0, 102))\narray([0.5, 1. , 1. ])\nIf you have an image with signed integers but want to rescale the image to\njust the positive range, use the `out_range` parameter. In that case, the\noutput dtype will be float:\n>>> image = np.array([-10, 0, 10], dtype=np.int8)\n>>> rescale_intensity(image, out_range=(0, 127))\narray([  0. ,  63.5, 127. ])\nTo get the desired range with a specific dtype, use ``.astype()``:\n>>> rescale_intensity(image, out_range=(0, 127)).astype(np.int8)\narray([  0,  63, 127], dtype=int8)\nIf the input image is constant, the output will be clipped directly to the\noutput range:\n>>> image = np.array([130, 130, 130], dtype=np.int32)\n>>> rescale_intensity(image, out_range=(0, 127)).astype(np.int32)\narray([127, 127, 127], dtype=int32)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "image": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "in_range": {
          "type": "string",
          "default": "image",
          "description": "类型从默认值推断: str"
        },
        "out_range": {
          "type": "string",
          "default": "dtype",
          "description": "类型从默认值推断: str"
        }
      },
      "required": [
        "image"
      ]
    },
    "metadata": {
      "source_function": "plotly.express.imshow_utils.rescale_intensity",
      "module": "plotly.express.imshow_utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.express.trendline_functions.ewm": {
    "name": "plotly_express_trendline_functions_ewm",
    "description": "Exponentially Weighted Moment (EWM) trendline function\nThe value of the `function` key of the `trendline_options` dict is the function to\nuse (defaults to `mean`) and the value of the `function_args` key are taken to be\nits arguments as a dict. The remainder of  the `trendline_options` dict is passed as\nkeyword arguments into the `pandas.Series.ewm` function.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "trendline_options": {
          "type": "object",
          "description": "类型从参数名推断: trendline_options"
        },
        "x_raw": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "x": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "x_label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y_label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "non_missing": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "trendline_options",
        "x_raw",
        "x",
        "y",
        "x_label",
        "y_label",
        "non_missing"
      ]
    },
    "metadata": {
      "source_function": "plotly.express.trendline_functions.ewm",
      "module": "plotly.express.trendline_functions",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.express.trendline_functions.expanding": {
    "name": "plotly_express_trendline_functions_expanding",
    "description": "Expanding trendline function\nThe value of the `function` key of the `trendline_options` dict is the function to\nuse (defaults to `mean`) and the value of the `function_args` key are taken to be\nits arguments as a dict. The remainder of  the `trendline_options` dict is passed as\nkeyword arguments into the `pandas.Series.expanding` function.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "trendline_options": {
          "type": "object",
          "description": "类型从参数名推断: trendline_options"
        },
        "x_raw": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "x": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "x_label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y_label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "non_missing": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "trendline_options",
        "x_raw",
        "x",
        "y",
        "x_label",
        "y_label",
        "non_missing"
      ]
    },
    "metadata": {
      "source_function": "plotly.express.trendline_functions.expanding",
      "module": "plotly.express.trendline_functions",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.express.trendline_functions.lowess": {
    "name": "plotly_express_trendline_functions_lowess",
    "description": "LOcally WEighted Scatterplot Smoothing (LOWESS) trendline function\nRequires `statsmodels` to be installed.\nValid keys for the `trendline_options` dict are:\n- `frac` (`float`, default `0.6666666`): the `frac` parameter from the\n`statsmodels.api.nonparametric.lowess` function",
    "inputSchema": {
      "type": "object",
      "properties": {
        "trendline_options": {
          "type": "object",
          "description": "类型从参数名推断: trendline_options"
        },
        "x_raw": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "x": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "x_label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y_label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "non_missing": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "trendline_options",
        "x_raw",
        "x",
        "y",
        "x_label",
        "y_label",
        "non_missing"
      ]
    },
    "metadata": {
      "source_function": "plotly.express.trendline_functions.lowess",
      "module": "plotly.express.trendline_functions",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.express.trendline_functions.ols": {
    "name": "plotly_express_trendline_functions_ols",
    "description": "Ordinary Least Squares (OLS) trendline function\nRequires `statsmodels` to be installed.\nThis trendline function causes fit results to be stored within the figure,\naccessible via the `plotly.express.get_trendline_results` function. The fit results\nare the output of the `statsmodels.api.OLS` function.\nValid keys for the `trendline_options` dict are:\n- `add_constant` (`bool`, default `True`): if `False`, the trendline passes through\nthe origin but if `True` a y-intercept is fitted.\n- `log_x` and `log_y` (`bool`, default `False`): if `True` the OLS is computed with\nrespect to the base 10 logarithm of the input. Note that this means no zeros can\nbe present in the input.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "trendline_options": {
          "type": "object",
          "description": "类型从参数名推断: trendline_options"
        },
        "x_raw": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "x": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "x_label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y_label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "non_missing": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "trendline_options",
        "x_raw",
        "x",
        "y",
        "x_label",
        "y_label",
        "non_missing"
      ]
    },
    "metadata": {
      "source_function": "plotly.express.trendline_functions.ols",
      "module": "plotly.express.trendline_functions",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.express.trendline_functions.rolling": {
    "name": "plotly_express_trendline_functions_rolling",
    "description": "Rolling trendline function\nThe value of the `function` key of the `trendline_options` dict is the function to\nuse (defaults to `mean`) and the value of the `function_args` key are taken to be\nits arguments as a dict. The remainder of  the `trendline_options` dict is passed as\nkeyword arguments into the `pandas.Series.rolling` function.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "trendline_options": {
          "type": "object",
          "description": "类型从参数名推断: trendline_options"
        },
        "x_raw": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "x": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "x_label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y_label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "non_missing": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "trendline_options",
        "x_raw",
        "x",
        "y",
        "x_label",
        "y_label",
        "non_missing"
      ]
    },
    "metadata": {
      "source_function": "plotly.express.trendline_functions.rolling",
      "module": "plotly.express.trendline_functions",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.figure_factory.utils.annotation_dict_for_label": {
    "name": "plotly_figure_factory_utils_annotation_dict_for_label",
    "description": "Returns annotation dict for label of n labels of a 1xn or nx1 subplot.\n\nvertical_spacing params in your plotly.tools.make_subplots() call.\ncolumns.\nhorizontally if set to True and row_col='row', or if False and\nrow_col='col'.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string",
          "description": "类型从参数名推断: text"
        },
        "lane": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "num_of_lanes": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "subplot_spacing": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row_col": {
          "type": "string",
          "default": "col",
          "description": "类型从默认值推断: str"
        },
        "flipped": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "right_side": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "text_color": {
          "type": "string",
          "default": "#0f0f0f",
          "description": "类型从默认值推断: str"
        }
      },
      "required": [
        "text",
        "lane",
        "num_of_lanes",
        "subplot_spacing"
      ]
    },
    "metadata": {
      "source_function": "plotly.figure_factory.utils.annotation_dict_for_label",
      "module": "plotly.figure_factory.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.figure_factory.utils.endpts_to_intervals": {
    "name": "plotly_figure_factory_utils_endpts_to_intervals",
    "description": "Returns a list of intervals for categorical colormaps\n\nAccepts a list or tuple of sequentially increasing numbers and returns\na list representation of the mathematical intervals with these numbers\nas endpoints. For example, [1, 6] returns [[-inf, 1], [1, 6], [6, inf]]\n\nprevious one in the sequence",
    "inputSchema": {
      "type": "object",
      "properties": {
        "endpts": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "endpts"
      ]
    },
    "metadata": {
      "source_function": "plotly.figure_factory.utils.endpts_to_intervals",
      "module": "plotly.figure_factory.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.figure_factory.utils.flatten": {
    "name": "plotly_figure_factory_utils_flatten",
    "description": "Uses list comprehension to flatten array",
    "inputSchema": {
      "type": "object",
      "properties": {
        "array": {
          "type": "array",
          "description": "类型从参数名推断: array"
        }
      },
      "required": [
        "array"
      ]
    },
    "metadata": {
      "source_function": "plotly.figure_factory.utils.flatten",
      "module": "plotly.figure_factory.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.figure_factory.utils.is_sequence": {
    "name": "plotly_figure_factory_utils_is_sequence",
    "description": "执行is_sequence操作（plotly.figure_factory.utils模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "obj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "obj"
      ]
    },
    "metadata": {
      "source_function": "plotly.figure_factory.utils.is_sequence",
      "module": "plotly.figure_factory.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    },
    "outputSchema": {
      "type": "boolean"
    }
  },
  "plotly.figure_factory.utils.list_of_options": {
    "name": "plotly_figure_factory_utils_list_of_options",
    "description": "Returns an English listing of objects seperated by commas ','\nFor example, ['foo', 'bar', 'baz'] becomes 'foo, bar and baz'\nif the conjunction 'and' is selected.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "iterable": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "conj": {
          "type": "string",
          "default": "and",
          "description": "类型从默认值推断: str"
        },
        "period": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "iterable"
      ]
    },
    "metadata": {
      "source_function": "plotly.figure_factory.utils.list_of_options",
      "module": "plotly.figure_factory.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    },
    "outputSchema": {
      "type": "array"
    }
  },
  "plotly.figure_factory.utils.validate_dataframe": {
    "name": "plotly_figure_factory_utils_validate_dataframe",
    "description": "Validates all strings or numbers in each dataframe column\n\ntypes differ",
    "inputSchema": {
      "type": "object",
      "properties": {
        "array": {
          "type": "array",
          "description": "类型从参数名推断: array"
        }
      },
      "required": [
        "array"
      ]
    },
    "metadata": {
      "source_function": "plotly.figure_factory.utils.validate_dataframe",
      "module": "plotly.figure_factory.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.figure_factory.utils.validate_equal_length": {
    "name": "plotly_figure_factory_utils_validate_equal_length",
    "description": "Validates that data lists or ndarrays are the same length.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.figure_factory.utils.validate_equal_length",
      "module": "plotly.figure_factory.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.figure_factory.utils.validate_index": {
    "name": "plotly_figure_factory_utils_validate_index",
    "description": "Validates if a list contains all numbers or all strings\n\ntypes differ",
    "inputSchema": {
      "type": "object",
      "properties": {
        "index_vals": {
          "type": "integer",
          "description": "类型从参数名推断: index_vals"
        }
      },
      "required": [
        "index_vals"
      ]
    },
    "metadata": {
      "source_function": "plotly.figure_factory.utils.validate_index",
      "module": "plotly.figure_factory.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.figure_factory.utils.validate_positive_scalars": {
    "name": "plotly_figure_factory_utils_validate_positive_scalars",
    "description": "Validates that all values given in key/val pairs are positive.\n\nAccepts kwargs to improve Exception messages.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.figure_factory.utils.validate_positive_scalars",
      "module": "plotly.figure_factory.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.exporter.Exporter.crawl_ax": {
    "name": "plotly_matplotlylib_mplexporter_exporter_Exporter_crawl_ax",
    "description": "Crawl the axes and process all elements within",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.exporter.Exporter.crawl_ax",
      "module": "plotly.matplotlylib.mplexporter.exporter",
      "class_name": "Exporter",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.exporter.Exporter.crawl_fig": {
    "name": "plotly_matplotlylib_mplexporter_exporter_Exporter_crawl_fig",
    "description": "Crawl the figure and process all axes",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.exporter.Exporter.crawl_fig",
      "module": "plotly.matplotlylib.mplexporter.exporter",
      "class_name": "Exporter",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.exporter.Exporter.crawl_legend": {
    "name": "plotly_matplotlylib_mplexporter_exporter_Exporter_crawl_legend",
    "description": "Recursively look through objects in legend children",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "legend"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.exporter.Exporter.crawl_legend",
      "module": "plotly.matplotlylib.mplexporter.exporter",
      "class_name": "Exporter",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.exporter.Exporter.draw_collection": {
    "name": "plotly_matplotlylib_mplexporter_exporter_Exporter_draw_collection",
    "description": "Process a matplotlib collection and call renderer.draw_collection",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "collection": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "force_pathtrans": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "force_offsettrans": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "collection"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.exporter.Exporter.draw_collection",
      "module": "plotly.matplotlylib.mplexporter.exporter",
      "class_name": "Exporter",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.exporter.Exporter.draw_image": {
    "name": "plotly_matplotlylib_mplexporter_exporter_Exporter_draw_image",
    "description": "Process a matplotlib image object and call renderer.draw_image",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "image": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "image"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.exporter.Exporter.draw_image",
      "module": "plotly.matplotlylib.mplexporter.exporter",
      "class_name": "Exporter",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.exporter.Exporter.draw_line": {
    "name": "plotly_matplotlylib_mplexporter_exporter_Exporter_draw_line",
    "description": "Process a matplotlib line and call renderer.draw_line",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "line": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "force_trans": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "line"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.exporter.Exporter.draw_line",
      "module": "plotly.matplotlylib.mplexporter.exporter",
      "class_name": "Exporter",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.exporter.Exporter.draw_patch": {
    "name": "plotly_matplotlylib_mplexporter_exporter_Exporter_draw_patch",
    "description": "Process a matplotlib patch object and call renderer.draw_path",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "patch": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "force_trans": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "patch"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.exporter.Exporter.draw_patch",
      "module": "plotly.matplotlylib.mplexporter.exporter",
      "class_name": "Exporter",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.exporter.Exporter.draw_text": {
    "name": "plotly_matplotlylib_mplexporter_exporter_Exporter_draw_text",
    "description": "Process a matplotlib text object and call renderer.draw_text",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "text": {
          "type": "string",
          "description": "类型从参数名推断: text"
        },
        "force_trans": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "text_type": {
          "type": "string",
          "description": "类型从参数名推断: text_type"
        }
      },
      "required": [
        "ax",
        "text"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.exporter.Exporter.draw_text",
      "module": "plotly.matplotlylib.mplexporter.exporter",
      "class_name": "Exporter",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.exporter.Exporter.process_transform": {
    "name": "plotly_matplotlylib_mplexporter_exporter_Exporter_process_transform",
    "description": "Process the transform and convert data to figure or data coordinates\nParameters\n----------\ntransform : matplotlib Transform object\nThe transform applied to the data\nax : matplotlib Axes object (optional)\nThe axes the data is associated with\ndata : ndarray (optional)\nThe array of data to be transformed.\nreturn_trans : bool (optional)\nIf true, return the final transform of the data\nforce_trans : matplotlib.transform instance (optional)\nIf supplied, first force the data to this transform\nReturns\n-------\ncode : string\nCode is either \"data\", \"axes\", \"figure\", or \"display\", indicating\nthe type of coordinates output.\ntransform : matplotlib transform\nthe transform used to map input data to output data.\nReturned only if return_trans is True\nnew_data : ndarray\nData transformed to match the given coordinate code.\nReturned only if data is specified",
    "inputSchema": {
      "type": "object",
      "properties": {
        "transform": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "return_trans": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "force_trans": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "transform"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.exporter.Exporter.process_transform",
      "module": "plotly.matplotlylib.mplexporter.exporter",
      "class_name": "Exporter",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.exporter.Exporter.run": {
    "name": "plotly_matplotlylib_mplexporter_exporter_Exporter_run",
    "description": "Run the exporter on the given figure\nParmeters\n---------\nfig : matplotlib.Figure instance\nThe figure to export",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.exporter.Exporter.run",
      "module": "plotly.matplotlylib.mplexporter.exporter",
      "class_name": "Exporter",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.ax_has_xgrid": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_ax_has_xgrid",
    "description": "执行ax_has_xgrid操作（Renderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.ax_has_xgrid",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.ax_has_ygrid": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_ax_has_ygrid",
    "description": "执行ax_has_ygrid操作（Renderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.ax_has_ygrid",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.ax_zoomable": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_ax_zoomable",
    "description": "执行ax_zoomable操作（Renderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.ax_zoomable",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.close_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_close_axes",
    "description": "Finish commands for a particular axes.\nParameters\n----------\nax : matplotlib.Axes\nThe Axes which is finished being drawn.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.close_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.close_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_close_figure",
    "description": "Finish commands for a particular figure.\nParameters\n----------\nfig : matplotlib.Figure\nThe figure which is finished being drawn.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.close_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.close_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_close_legend",
    "description": "Finish commands for a particular legend.\nParameters\n----------\nlegend : matplotlib.legend.Legend\nThe Legend which is finished being drawn",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.close_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_draw_axes",
    "description": "执行draw_axes操作（Renderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_draw_figure",
    "description": "执行draw_figure操作（Renderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_image": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_draw_image",
    "description": "Draw an image.\nParameters\n----------\nimdata : string\nbase64 encoded png representation of the image\nextent : list\nthe axes extent of the image: [xmin, xmax, ymin, ymax]\ncoordinates: string\nA string code, which should be either 'data' for data coordinates,\nor 'figure' for figure (pixel) coordinates.\nstyle : dictionary\na dictionary specifying the appearance of the image\nmplobj : matplotlib object\nthe matplotlib plot object which generated this image",
    "inputSchema": {
      "type": "object",
      "properties": {
        "imdata": {
          "type": "object",
          "description": "类型从参数名推断: imdata"
        },
        "extent": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "imdata",
        "extent",
        "coordinates",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_image",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_draw_legend",
    "description": "执行draw_legend操作（Renderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_line": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_draw_line",
    "description": "Draw a line. By default, draw the line via the draw_path() command.\nSome renderers might wish to override this and provide more\nfine-grained behavior.\nIn matplotlib, lines are generally created via the plt.plot() command,\nthough this command also can create marker collections.\nParameters\n----------\ndata : array_like\nA shape (N, 2) array of datapoints.\ncoordinates : string\nA string code, which should be either 'data' for data coordinates,\nor 'figure' for figure (pixel) coordinates.\nstyle : dictionary\na dictionary specifying the appearance of the line.\nmplobj : matplotlib object\nthe matplotlib plot element which generated this line",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "style",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_line",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_marked_line": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_draw_marked_line",
    "description": "Draw a line that also has markers.\nIf this isn't reimplemented by a renderer object, by default, it will\nmake a call to BOTH draw_line and draw_markers when both markerstyle\nand linestyle are not None in the same Line2D object.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "linestyle": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "markerstyle": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "linestyle",
        "markerstyle",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_marked_line",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_markers": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_draw_markers",
    "description": "Draw a set of markers. By default, this is done by repeatedly\ncalling draw_path(), but renderers should generally overload\nthis method to provide a more efficient implementation.\nIn matplotlib, markers are created using the plt.plot() command.\nParameters\n----------\ndata : array_like\nA shape (N, 2) array of datapoints.\ncoordinates : string\nA string code, which should be either 'data' for data coordinates,\nor 'figure' for figure (pixel) coordinates.\nstyle : dictionary\na dictionary specifying the appearance of the markers.\nmplobj : matplotlib object\nthe matplotlib plot element which generated this marker collection",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "style",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_markers",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_path": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_draw_path",
    "description": "Draw a path.\nIn matplotlib, paths are created by filled regions, histograms,\ncontour plots, patches, etc.\nParameters\n----------\ndata : array_like\nA shape (N, 2) array of datapoints.\ncoordinates : string\nA string code, which should be either 'data' for data coordinates,\n'figure' for figure (pixel) coordinates, or \"points\" for raw\npoint coordinates (useful in conjunction with offsets, below).\npathcodes : list\nA list of single-character SVG pathcodes associated with the data.\nPath codes are one of ['M', 'm', 'L', 'l', 'Q', 'q', 'T', 't',\n'S', 's', 'C', 'c', 'Z', 'z']\nSee the SVG specification for details.  Note that some path codes\nconsume more than one datapoint (while 'Z' consumes none), so\nin general, the length of the pathcodes list will not be the same\nas that of the data array.\nstyle : dictionary\na dictionary specifying the appearance of the line.\noffset : list (optional)\nthe (x, y) offset of the path. If not given, no offset will\nbe used.\noffset_coordinates : string (optional)\nA string code, which should be either 'data' for data coordinates,\nor 'figure' for figure (pixel) coordinates.\nmplobj : matplotlib object\nthe matplotlib plot element which generated this path",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "pathcodes": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_coordinates": {
          "type": "string",
          "default": "data",
          "description": "类型从默认值推断: str"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "pathcodes",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_path",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_path_collection": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_draw_path_collection",
    "description": "Draw a collection of paths. The paths, offsets, and styles are all\niterables, and the number of paths is max(len(paths), len(offsets)).\nBy default, this is implemented via multiple calls to the draw_path()\nfunction. For efficiency, Renderers may choose to customize this\nimplementation.\nExamples of path collections created by matplotlib are scatter plots,\nhistograms, contour plots, and many others.\nParameters\n----------\npaths : list\nlist of tuples, where each tuple has two elements:\n(data, pathcodes).  See draw_path() for a description of these.\npath_coordinates: string\nthe coordinates code for the paths, which should be either\n'data' for data coordinates, or 'figure' for figure (pixel)\ncoordinates.\npath_transforms: array_like\nan array of shape (*, 3, 3), giving a series of 2D Affine\ntransforms for the paths. These encode translations, rotations,\nand scalings in the standard way.\noffsets: array_like\nAn array of offsets of shape (N, 2)\noffset_coordinates : string\nthe coordinates code for the offsets, which should be either\n'data' for data coordinates, or 'figure' for figure (pixel)\ncoordinates.\noffset_order : string\neither \"before\" or \"after\". This specifies whether the offset\nis applied before the path transform, or after.  The matplotlib\nbackend equivalent is \"before\"->\"data\", \"after\"->\"screen\".\nstyles: dictionary\nA dictionary in which each value is a list of length N, containing\nthe style(s) for the paths.\nmplobj : matplotlib object\nthe matplotlib plot element which generated this collection",
    "inputSchema": {
      "type": "object",
      "properties": {
        "paths": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "path_coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "path_transforms": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offsets": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_order": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "styles": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "paths",
        "path_coordinates",
        "path_transforms",
        "offsets",
        "offset_coordinates",
        "offset_order",
        "styles"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_path_collection",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_text": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_draw_text",
    "description": "Draw text on the image.\nParameters\n----------\ntext : string\nThe text to draw\nposition : tuple\nThe (x, y) position of the text\ncoordinates : string\nA string code, which should be either 'data' for data coordinates,\nor 'figure' for figure (pixel) coordinates.\nstyle : dictionary\na dictionary specifying the appearance of the text.\ntext_type : string or None\nif specified, a type of text such as \"xlabel\", \"ylabel\", \"title\"\nmplobj : matplotlib object\nthe matplotlib plot element which generated this text",
    "inputSchema": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string",
          "description": "类型从参数名推断: text"
        },
        "position": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "text_type": {
          "type": "string",
          "description": "类型从参数名推断: text_type"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "text",
        "position",
        "coordinates",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.draw_text",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.open_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_open_axes",
    "description": "Begin commands for a particular axes.\nParameters\n----------\nax : matplotlib.Axes\nThe Axes which will contain the ensuing axes and elements\nprops : dictionary\nThe dictionary of axes properties",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.open_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.open_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_open_figure",
    "description": "Begin commands for a particular figure.\nParameters\n----------\nfig : matplotlib.Figure\nThe Figure which will contain the ensuing axes and elements\nprops : dictionary\nThe dictionary of figure properties",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.open_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.base.Renderer.open_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_base_Renderer_open_legend",
    "description": "Beging commands for a particular legend.\nParameters\n----------\nlegend : matplotlib.legend.Legend\nThe Legend that will contain the ensuing elements\nprops : dictionary\nThe dictionary of legend properties",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.base.Renderer.open_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.base",
      "class_name": "Renderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.ax_has_xgrid": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_ax_has_xgrid",
    "description": "执行ax_has_xgrid操作（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.ax_has_xgrid",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.ax_has_ygrid": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_ax_has_ygrid",
    "description": "执行ax_has_ygrid操作（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.ax_has_ygrid",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.ax_zoomable": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_ax_zoomable",
    "description": "执行ax_zoomable操作（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.ax_zoomable",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.close_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_close_axes",
    "description": "关闭数据（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.close_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.close_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_close_figure",
    "description": "关闭数据（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.close_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.close_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_close_legend",
    "description": "关闭数据（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.close_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_draw_axes",
    "description": "执行draw_axes操作（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_draw_figure",
    "description": "执行draw_figure操作（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_image": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_draw_image",
    "description": "执行draw_image操作（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "imdata": {
          "type": "object",
          "description": "类型从参数名推断: imdata"
        },
        "extent": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "imdata",
        "extent",
        "coordinates",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_image",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_draw_legend",
    "description": "执行draw_legend操作（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_line": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_draw_line",
    "description": "Draw a line. By default, draw the line via the draw_path() command.\nSome renderers might wish to override this and provide more\nfine-grained behavior.\nIn matplotlib, lines are generally created via the plt.plot() command,\nthough this command also can create marker collections.\nParameters\n----------\ndata : array_like\nA shape (N, 2) array of datapoints.\ncoordinates : string\nA string code, which should be either 'data' for data coordinates,\nor 'figure' for figure (pixel) coordinates.\nstyle : dictionary\na dictionary specifying the appearance of the line.\nmplobj : matplotlib object\nthe matplotlib plot element which generated this line",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "style",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_line",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_marked_line": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_draw_marked_line",
    "description": "Draw a line that also has markers.\nIf this isn't reimplemented by a renderer object, by default, it will\nmake a call to BOTH draw_line and draw_markers when both markerstyle\nand linestyle are not None in the same Line2D object.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "linestyle": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "markerstyle": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "linestyle",
        "markerstyle",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_marked_line",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_markers": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_draw_markers",
    "description": "Draw a set of markers. By default, this is done by repeatedly\ncalling draw_path(), but renderers should generally overload\nthis method to provide a more efficient implementation.\nIn matplotlib, markers are created using the plt.plot() command.\nParameters\n----------\ndata : array_like\nA shape (N, 2) array of datapoints.\ncoordinates : string\nA string code, which should be either 'data' for data coordinates,\nor 'figure' for figure (pixel) coordinates.\nstyle : dictionary\na dictionary specifying the appearance of the markers.\nmplobj : matplotlib object\nthe matplotlib plot element which generated this marker collection",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "style",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_markers",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_path": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_draw_path",
    "description": "执行draw_path操作（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "pathcodes": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_coordinates": {
          "type": "string",
          "default": "data",
          "description": "类型从默认值推断: str"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "pathcodes",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_path",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_path_collection": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_draw_path_collection",
    "description": "Draw a collection of paths. The paths, offsets, and styles are all\niterables, and the number of paths is max(len(paths), len(offsets)).\nBy default, this is implemented via multiple calls to the draw_path()\nfunction. For efficiency, Renderers may choose to customize this\nimplementation.\nExamples of path collections created by matplotlib are scatter plots,\nhistograms, contour plots, and many others.\nParameters\n----------\npaths : list\nlist of tuples, where each tuple has two elements:\n(data, pathcodes).  See draw_path() for a description of these.\npath_coordinates: string\nthe coordinates code for the paths, which should be either\n'data' for data coordinates, or 'figure' for figure (pixel)\ncoordinates.\npath_transforms: array_like\nan array of shape (*, 3, 3), giving a series of 2D Affine\ntransforms for the paths. These encode translations, rotations,\nand scalings in the standard way.\noffsets: array_like\nAn array of offsets of shape (N, 2)\noffset_coordinates : string\nthe coordinates code for the offsets, which should be either\n'data' for data coordinates, or 'figure' for figure (pixel)\ncoordinates.\noffset_order : string\neither \"before\" or \"after\". This specifies whether the offset\nis applied before the path transform, or after.  The matplotlib\nbackend equivalent is \"before\"->\"data\", \"after\"->\"screen\".\nstyles: dictionary\nA dictionary in which each value is a list of length N, containing\nthe style(s) for the paths.\nmplobj : matplotlib object\nthe matplotlib plot element which generated this collection",
    "inputSchema": {
      "type": "object",
      "properties": {
        "paths": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "path_coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "path_transforms": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offsets": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_order": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "styles": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "paths",
        "path_coordinates",
        "path_transforms",
        "offsets",
        "offset_coordinates",
        "offset_order",
        "styles"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_path_collection",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_text": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_draw_text",
    "description": "执行draw_text操作（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string",
          "description": "类型从参数名推断: text"
        },
        "position": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "text_type": {
          "type": "string",
          "description": "类型从参数名推断: text_type"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "text",
        "position",
        "coordinates",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.draw_text",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.open_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_open_axes",
    "description": "打开数据（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.open_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.open_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_open_figure",
    "description": "打开数据（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.open_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.open_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FakeRenderer_open_legend",
    "description": "打开数据（FakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FakeRenderer.open_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.ax_has_xgrid": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_ax_has_xgrid",
    "description": "执行ax_has_xgrid操作（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.ax_has_xgrid",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.ax_has_ygrid": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_ax_has_ygrid",
    "description": "执行ax_has_ygrid操作（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.ax_has_ygrid",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.ax_zoomable": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_ax_zoomable",
    "description": "执行ax_zoomable操作（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.ax_zoomable",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.close_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_close_axes",
    "description": "关闭数据（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.close_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.close_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_close_figure",
    "description": "关闭数据（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.close_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.close_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_close_legend",
    "description": "关闭数据（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.close_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_draw_axes",
    "description": "执行draw_axes操作（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_draw_figure",
    "description": "执行draw_figure操作（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_image": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_draw_image",
    "description": "执行draw_image操作（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "imdata": {
          "type": "object",
          "description": "类型从参数名推断: imdata"
        },
        "extent": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "imdata",
        "extent",
        "coordinates",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_image",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_draw_legend",
    "description": "执行draw_legend操作（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_line": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_draw_line",
    "description": "执行draw_line操作（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "style",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_line",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_marked_line": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_draw_marked_line",
    "description": "Draw a line that also has markers.\nIf this isn't reimplemented by a renderer object, by default, it will\nmake a call to BOTH draw_line and draw_markers when both markerstyle\nand linestyle are not None in the same Line2D object.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "linestyle": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "markerstyle": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "linestyle",
        "markerstyle",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_marked_line",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_markers": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_draw_markers",
    "description": "执行draw_markers操作（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "style",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_markers",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_path": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_draw_path",
    "description": "执行draw_path操作（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "pathcodes": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_coordinates": {
          "type": "string",
          "default": "data",
          "description": "类型从默认值推断: str"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "pathcodes",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_path",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_path_collection": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_draw_path_collection",
    "description": "执行draw_path_collection操作（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "paths": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "path_coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "path_transforms": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offsets": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_order": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "styles": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "paths",
        "path_coordinates",
        "path_transforms",
        "offsets",
        "offset_coordinates",
        "offset_order",
        "styles"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_path_collection",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_text": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_draw_text",
    "description": "执行draw_text操作（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string",
          "description": "类型从参数名推断: text"
        },
        "position": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "text_type": {
          "type": "string",
          "description": "类型从参数名推断: text_type"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "text",
        "position",
        "coordinates",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.draw_text",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.open_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_open_axes",
    "description": "打开数据（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.open_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.open_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_open_figure",
    "description": "打开数据（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.open_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.open_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_fake_renderer_FullFakeRenderer_open_legend",
    "description": "打开数据（FullFakeRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.fake_renderer.FullFakeRenderer.open_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.fake_renderer",
      "class_name": "FullFakeRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.fig_to_vega": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_fig_to_vega",
    "description": "Convert a matplotlib figure to vega dictionary\nif notebook=True, then return an object which will display in a notebook\notherwise, return an HTML string.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "notebook": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.fig_to_vega",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaHTML.html": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaHTML_html",
    "description": "Build the HTML representation for IPython.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaHTML.html",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaHTML",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.ax_has_xgrid": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_ax_has_xgrid",
    "description": "执行ax_has_xgrid操作（VegaRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.ax_has_xgrid",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.ax_has_ygrid": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_ax_has_ygrid",
    "description": "执行ax_has_ygrid操作（VegaRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.ax_has_ygrid",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.ax_zoomable": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_ax_zoomable",
    "description": "执行ax_zoomable操作（VegaRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.ax_zoomable",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.close_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_close_axes",
    "description": "Finish commands for a particular axes.\nParameters\n----------\nax : matplotlib.Axes\nThe Axes which is finished being drawn.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.close_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.close_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_close_figure",
    "description": "Finish commands for a particular figure.\nParameters\n----------\nfig : matplotlib.Figure\nThe figure which is finished being drawn.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.close_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.close_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_close_legend",
    "description": "Finish commands for a particular legend.\nParameters\n----------\nlegend : matplotlib.legend.Legend\nThe Legend which is finished being drawn",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.close_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_draw_axes",
    "description": "执行draw_axes操作（VegaRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_draw_figure",
    "description": "执行draw_figure操作（VegaRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_image": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_draw_image",
    "description": "Draw an image.\nParameters\n----------\nimdata : string\nbase64 encoded png representation of the image\nextent : list\nthe axes extent of the image: [xmin, xmax, ymin, ymax]\ncoordinates: string\nA string code, which should be either 'data' for data coordinates,\nor 'figure' for figure (pixel) coordinates.\nstyle : dictionary\na dictionary specifying the appearance of the image\nmplobj : matplotlib object\nthe matplotlib plot object which generated this image",
    "inputSchema": {
      "type": "object",
      "properties": {
        "imdata": {
          "type": "object",
          "description": "类型从参数名推断: imdata"
        },
        "extent": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "imdata",
        "extent",
        "coordinates",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_image",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_draw_legend",
    "description": "执行draw_legend操作（VegaRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_line": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_draw_line",
    "description": "执行draw_line操作（VegaRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "style",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_line",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_marked_line": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_draw_marked_line",
    "description": "Draw a line that also has markers.\nIf this isn't reimplemented by a renderer object, by default, it will\nmake a call to BOTH draw_line and draw_markers when both markerstyle\nand linestyle are not None in the same Line2D object.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "linestyle": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "markerstyle": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "linestyle",
        "markerstyle",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_marked_line",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_markers": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_draw_markers",
    "description": "执行draw_markers操作（VegaRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "style",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_markers",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_path": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_draw_path",
    "description": "Draw a path.\nIn matplotlib, paths are created by filled regions, histograms,\ncontour plots, patches, etc.\nParameters\n----------\ndata : array_like\nA shape (N, 2) array of datapoints.\ncoordinates : string\nA string code, which should be either 'data' for data coordinates,\n'figure' for figure (pixel) coordinates, or \"points\" for raw\npoint coordinates (useful in conjunction with offsets, below).\npathcodes : list\nA list of single-character SVG pathcodes associated with the data.\nPath codes are one of ['M', 'm', 'L', 'l', 'Q', 'q', 'T', 't',\n'S', 's', 'C', 'c', 'Z', 'z']\nSee the SVG specification for details.  Note that some path codes\nconsume more than one datapoint (while 'Z' consumes none), so\nin general, the length of the pathcodes list will not be the same\nas that of the data array.\nstyle : dictionary\na dictionary specifying the appearance of the line.\noffset : list (optional)\nthe (x, y) offset of the path. If not given, no offset will\nbe used.\noffset_coordinates : string (optional)\nA string code, which should be either 'data' for data coordinates,\nor 'figure' for figure (pixel) coordinates.\nmplobj : matplotlib object\nthe matplotlib plot element which generated this path",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "pathcodes": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_coordinates": {
          "type": "string",
          "default": "data",
          "description": "类型从默认值推断: str"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "pathcodes",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_path",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_path_collection": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_draw_path_collection",
    "description": "Draw a collection of paths. The paths, offsets, and styles are all\niterables, and the number of paths is max(len(paths), len(offsets)).\nBy default, this is implemented via multiple calls to the draw_path()\nfunction. For efficiency, Renderers may choose to customize this\nimplementation.\nExamples of path collections created by matplotlib are scatter plots,\nhistograms, contour plots, and many others.\nParameters\n----------\npaths : list\nlist of tuples, where each tuple has two elements:\n(data, pathcodes).  See draw_path() for a description of these.\npath_coordinates: string\nthe coordinates code for the paths, which should be either\n'data' for data coordinates, or 'figure' for figure (pixel)\ncoordinates.\npath_transforms: array_like\nan array of shape (*, 3, 3), giving a series of 2D Affine\ntransforms for the paths. These encode translations, rotations,\nand scalings in the standard way.\noffsets: array_like\nAn array of offsets of shape (N, 2)\noffset_coordinates : string\nthe coordinates code for the offsets, which should be either\n'data' for data coordinates, or 'figure' for figure (pixel)\ncoordinates.\noffset_order : string\neither \"before\" or \"after\". This specifies whether the offset\nis applied before the path transform, or after.  The matplotlib\nbackend equivalent is \"before\"->\"data\", \"after\"->\"screen\".\nstyles: dictionary\nA dictionary in which each value is a list of length N, containing\nthe style(s) for the paths.\nmplobj : matplotlib object\nthe matplotlib plot element which generated this collection",
    "inputSchema": {
      "type": "object",
      "properties": {
        "paths": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "path_coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "path_transforms": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offsets": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_order": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "styles": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "paths",
        "path_coordinates",
        "path_transforms",
        "offsets",
        "offset_coordinates",
        "offset_order",
        "styles"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_path_collection",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_text": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_draw_text",
    "description": "执行draw_text操作（VegaRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string",
          "description": "类型从参数名推断: text"
        },
        "position": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "text_type": {
          "type": "string",
          "description": "类型从参数名推断: text_type"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "text",
        "position",
        "coordinates",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.draw_text",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.open_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_open_axes",
    "description": "打开数据（VegaRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.open_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.open_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_open_figure",
    "description": "打开数据（VegaRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.open_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.open_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vega_renderer_VegaRenderer_open_legend",
    "description": "Beging commands for a particular legend.\nParameters\n----------\nlegend : matplotlib.legend.Legend\nThe Legend that will contain the ensuing elements\nprops : dictionary\nThe dictionary of legend properties",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vega_renderer.VegaRenderer.open_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.vega_renderer",
      "class_name": "VegaRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.fig_to_vincent": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_fig_to_vincent",
    "description": "Convert a matplotlib figure to a vincent object",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.fig_to_vincent",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.ax_has_xgrid": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_ax_has_xgrid",
    "description": "执行ax_has_xgrid操作（VincentRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.ax_has_xgrid",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.ax_has_ygrid": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_ax_has_ygrid",
    "description": "执行ax_has_ygrid操作（VincentRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.ax_has_ygrid",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.ax_zoomable": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_ax_zoomable",
    "description": "执行ax_zoomable操作（VincentRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.ax_zoomable",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.close_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_close_axes",
    "description": "Finish commands for a particular axes.\nParameters\n----------\nax : matplotlib.Axes\nThe Axes which is finished being drawn.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.close_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.close_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_close_figure",
    "description": "Finish commands for a particular figure.\nParameters\n----------\nfig : matplotlib.Figure\nThe figure which is finished being drawn.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.close_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.close_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_close_legend",
    "description": "Finish commands for a particular legend.\nParameters\n----------\nlegend : matplotlib.legend.Legend\nThe Legend which is finished being drawn",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.close_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_draw_axes",
    "description": "执行draw_axes操作（VincentRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_draw_figure",
    "description": "执行draw_figure操作（VincentRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_image": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_draw_image",
    "description": "Draw an image.\nParameters\n----------\nimdata : string\nbase64 encoded png representation of the image\nextent : list\nthe axes extent of the image: [xmin, xmax, ymin, ymax]\ncoordinates: string\nA string code, which should be either 'data' for data coordinates,\nor 'figure' for figure (pixel) coordinates.\nstyle : dictionary\na dictionary specifying the appearance of the image\nmplobj : matplotlib object\nthe matplotlib plot object which generated this image",
    "inputSchema": {
      "type": "object",
      "properties": {
        "imdata": {
          "type": "object",
          "description": "类型从参数名推断: imdata"
        },
        "extent": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "imdata",
        "extent",
        "coordinates",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_image",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_draw_legend",
    "description": "执行draw_legend操作（VincentRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_line": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_draw_line",
    "description": "执行draw_line操作（VincentRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "style",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_line",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_marked_line": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_draw_marked_line",
    "description": "Draw a line that also has markers.\nIf this isn't reimplemented by a renderer object, by default, it will\nmake a call to BOTH draw_line and draw_markers when both markerstyle\nand linestyle are not None in the same Line2D object.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "linestyle": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "markerstyle": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "linestyle",
        "markerstyle",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_marked_line",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_markers": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_draw_markers",
    "description": "执行draw_markers操作（VincentRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "style",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_markers",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_path": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_draw_path",
    "description": "Draw a path.\nIn matplotlib, paths are created by filled regions, histograms,\ncontour plots, patches, etc.\nParameters\n----------\ndata : array_like\nA shape (N, 2) array of datapoints.\ncoordinates : string\nA string code, which should be either 'data' for data coordinates,\n'figure' for figure (pixel) coordinates, or \"points\" for raw\npoint coordinates (useful in conjunction with offsets, below).\npathcodes : list\nA list of single-character SVG pathcodes associated with the data.\nPath codes are one of ['M', 'm', 'L', 'l', 'Q', 'q', 'T', 't',\n'S', 's', 'C', 'c', 'Z', 'z']\nSee the SVG specification for details.  Note that some path codes\nconsume more than one datapoint (while 'Z' consumes none), so\nin general, the length of the pathcodes list will not be the same\nas that of the data array.\nstyle : dictionary\na dictionary specifying the appearance of the line.\noffset : list (optional)\nthe (x, y) offset of the path. If not given, no offset will\nbe used.\noffset_coordinates : string (optional)\nA string code, which should be either 'data' for data coordinates,\nor 'figure' for figure (pixel) coordinates.\nmplobj : matplotlib object\nthe matplotlib plot element which generated this path",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "pathcodes": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_coordinates": {
          "type": "string",
          "default": "data",
          "description": "类型从默认值推断: str"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "pathcodes",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_path",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_path_collection": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_draw_path_collection",
    "description": "Draw a collection of paths. The paths, offsets, and styles are all\niterables, and the number of paths is max(len(paths), len(offsets)).\nBy default, this is implemented via multiple calls to the draw_path()\nfunction. For efficiency, Renderers may choose to customize this\nimplementation.\nExamples of path collections created by matplotlib are scatter plots,\nhistograms, contour plots, and many others.\nParameters\n----------\npaths : list\nlist of tuples, where each tuple has two elements:\n(data, pathcodes).  See draw_path() for a description of these.\npath_coordinates: string\nthe coordinates code for the paths, which should be either\n'data' for data coordinates, or 'figure' for figure (pixel)\ncoordinates.\npath_transforms: array_like\nan array of shape (*, 3, 3), giving a series of 2D Affine\ntransforms for the paths. These encode translations, rotations,\nand scalings in the standard way.\noffsets: array_like\nAn array of offsets of shape (N, 2)\noffset_coordinates : string\nthe coordinates code for the offsets, which should be either\n'data' for data coordinates, or 'figure' for figure (pixel)\ncoordinates.\noffset_order : string\neither \"before\" or \"after\". This specifies whether the offset\nis applied before the path transform, or after.  The matplotlib\nbackend equivalent is \"before\"->\"data\", \"after\"->\"screen\".\nstyles: dictionary\nA dictionary in which each value is a list of length N, containing\nthe style(s) for the paths.\nmplobj : matplotlib object\nthe matplotlib plot element which generated this collection",
    "inputSchema": {
      "type": "object",
      "properties": {
        "paths": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "path_coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "path_transforms": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offsets": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "offset_order": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "styles": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "paths",
        "path_coordinates",
        "path_transforms",
        "offsets",
        "offset_coordinates",
        "offset_order",
        "styles"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_path_collection",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_text": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_draw_text",
    "description": "Draw text on the image.\nParameters\n----------\ntext : string\nThe text to draw\nposition : tuple\nThe (x, y) position of the text\ncoordinates : string\nA string code, which should be either 'data' for data coordinates,\nor 'figure' for figure (pixel) coordinates.\nstyle : dictionary\na dictionary specifying the appearance of the text.\ntext_type : string or None\nif specified, a type of text such as \"xlabel\", \"ylabel\", \"title\"\nmplobj : matplotlib object\nthe matplotlib plot element which generated this text",
    "inputSchema": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string",
          "description": "类型从参数名推断: text"
        },
        "position": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "text_type": {
          "type": "string",
          "description": "类型从参数名推断: text_type"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "text",
        "position",
        "coordinates",
        "style"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.draw_text",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.open_axes": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_open_axes",
    "description": "Begin commands for a particular axes.\nParameters\n----------\nax : matplotlib.Axes\nThe Axes which will contain the ensuing axes and elements\nprops : dictionary\nThe dictionary of axes properties",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.open_axes",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.open_figure": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_open_figure",
    "description": "打开数据（VincentRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.open_figure",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.open_legend": {
    "name": "plotly_matplotlylib_mplexporter_renderers_vincent_renderer_VincentRenderer_open_legend",
    "description": "Beging commands for a particular legend.\nParameters\n----------\nlegend : matplotlib.legend.Legend\nThe Legend that will contain the ensuing elements\nprops : dictionary\nThe dictionary of legend properties",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer.VincentRenderer.open_legend",
      "module": "plotly.matplotlylib.mplexporter.renderers.vincent_renderer",
      "class_name": "VincentRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.tools.ipynb_vega_init": {
    "name": "plotly_matplotlylib_mplexporter_tools_ipynb_vega_init",
    "description": "Initialize the IPython notebook display elements\nThis function borrows heavily from the excellent vincent package:\nhttp://github.com/wrobstory/vincent",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.tools.ipynb_vega_init",
      "module": "plotly.matplotlylib.mplexporter.tools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.utils.SVG_path": {
    "name": "plotly_matplotlylib_mplexporter_utils_SVG_path",
    "description": "Construct the vertices and SVG codes for the path\nParameters\n----------\npath : matplotlib.Path object\ntransform : matplotlib transform (optional)\nif specified, the path will be transformed before computing the output.\nReturns\n-------\nvertices : array\nThe shape (M, 2) array of vertices of the Path. Note that some Path\ncodes require multiple vertices, so the length of these vertices may\nbe longer than the list of path codes.\npath_codes : list\nA length N list of single-character path codes, N <= M. Each code is\na single character, in ['L','M','S','C','Z']. See the standard SVG\npath specification for a description of these.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "transform": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "simplify": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "path"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.utils.SVG_path",
      "module": "plotly.matplotlylib.mplexporter.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.utils.export_color": {
    "name": "plotly_matplotlylib_mplexporter_utils_export_color",
    "description": "Convert matplotlib color code to hex color or RGBA color",
    "inputSchema": {
      "type": "object",
      "properties": {
        "color": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "color"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.utils.export_color",
      "module": "plotly.matplotlylib.mplexporter.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.utils.get_axes_properties": {
    "name": "plotly_matplotlylib_mplexporter_utils_get_axes_properties",
    "description": "获取数据（plotly.matplotlylib.mplexporter.utils模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.utils.get_axes_properties",
      "module": "plotly.matplotlylib.mplexporter.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.utils.get_axis_properties": {
    "name": "plotly_matplotlylib_mplexporter_utils_get_axis_properties",
    "description": "Return the property dictionary for a matplotlib.Axis instance",
    "inputSchema": {
      "type": "object",
      "properties": {
        "axis": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "axis"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.utils.get_axis_properties",
      "module": "plotly.matplotlylib.mplexporter.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.utils.get_dasharray": {
    "name": "plotly_matplotlylib_mplexporter_utils_get_dasharray",
    "description": "Get an SVG dash array for the given matplotlib linestyle\nParameters\n----------\nobj : matplotlib object\nThe matplotlib line or path object, which must have a get_linestyle()\nmethod which returns a valid matplotlib line code\nReturns\n-------\ndasharray : string\nThe HTML/SVG dasharray code associated with the object.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "obj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "obj"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.utils.get_dasharray",
      "module": "plotly.matplotlylib.mplexporter.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.utils.get_figure_properties": {
    "name": "plotly_matplotlylib_mplexporter_utils_get_figure_properties",
    "description": "获取数据（plotly.matplotlylib.mplexporter.utils模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.utils.get_figure_properties",
      "module": "plotly.matplotlylib.mplexporter.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.utils.get_grid_style": {
    "name": "plotly_matplotlylib_mplexporter_utils_get_grid_style",
    "description": "获取数据（plotly.matplotlylib.mplexporter.utils模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "axis": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "axis"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.utils.get_grid_style",
      "module": "plotly.matplotlylib.mplexporter.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.utils.get_legend_properties": {
    "name": "plotly_matplotlylib_mplexporter_utils_get_legend_properties",
    "description": "获取数据（plotly.matplotlylib.mplexporter.utils模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "legend"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.utils.get_legend_properties",
      "module": "plotly.matplotlylib.mplexporter.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.utils.get_line_style": {
    "name": "plotly_matplotlylib_mplexporter_utils_get_line_style",
    "description": "Get the style dictionary for matplotlib line objects",
    "inputSchema": {
      "type": "object",
      "properties": {
        "line": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "line"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.utils.get_line_style",
      "module": "plotly.matplotlylib.mplexporter.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.utils.get_marker_style": {
    "name": "plotly_matplotlylib_mplexporter_utils_get_marker_style",
    "description": "Get the style dictionary for matplotlib marker objects",
    "inputSchema": {
      "type": "object",
      "properties": {
        "line": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "line"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.utils.get_marker_style",
      "module": "plotly.matplotlylib.mplexporter.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.utils.get_path_style": {
    "name": "plotly_matplotlylib_mplexporter_utils_get_path_style",
    "description": "Get the style dictionary for matplotlib path objects",
    "inputSchema": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "fill": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "path"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.utils.get_path_style",
      "module": "plotly.matplotlylib.mplexporter.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.utils.get_text_style": {
    "name": "plotly_matplotlylib_mplexporter_utils_get_text_style",
    "description": "Return the text style dict for a text instance",
    "inputSchema": {
      "type": "object",
      "properties": {
        "text": {
          "type": "string",
          "description": "类型从参数名推断: text"
        }
      },
      "required": [
        "text"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.utils.get_text_style",
      "module": "plotly.matplotlylib.mplexporter.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.utils.image_to_base64": {
    "name": "plotly_matplotlylib_mplexporter_utils_image_to_base64",
    "description": "Convert a matplotlib image to a base64 png representation\nParameters\n----------\nimage : matplotlib image object\nThe image to be converted.\nReturns\n-------\nimage_base64 : string\nThe UTF8-encoded base64 string representation of the png image.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "image": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "image"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.utils.image_to_base64",
      "module": "plotly.matplotlylib.mplexporter.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mplexporter.utils.iter_all_children": {
    "name": "plotly_matplotlylib_mplexporter_utils_iter_all_children",
    "description": "Returns an iterator over all childen and nested children using\nobj's get_children() method\nif skipContainers is true, only childless objects are returned.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "obj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "skipContainers": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "obj"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mplexporter.utils.iter_all_children",
      "module": "plotly.matplotlylib.mplexporter.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.check_bar_match": {
    "name": "plotly_matplotlylib_mpltools_check_bar_match",
    "description": "Check if two bars belong in the same collection (bar chart).\nPositional arguments:\nold_bar -- a previously sorted bar dictionary.\nnew_bar -- a new bar dictionary that needs to be sorted.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "old_bar": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "new_bar": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "old_bar",
        "new_bar"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.check_bar_match",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.check_corners": {
    "name": "plotly_matplotlylib_mpltools_check_corners",
    "description": "执行check_corners操作（plotly.matplotlylib.mpltools模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "inner_obj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "outer_obj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "inner_obj",
        "outer_obj"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.check_corners",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.convert_dash": {
    "name": "plotly_matplotlylib_mpltools_convert_dash",
    "description": "Convert mpl line symbol to plotly line symbol and return symbol.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "mpl_dash": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "mpl_dash"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.convert_dash",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.convert_linewidth_array": {
    "name": "plotly_matplotlylib_mpltools_convert_linewidth_array",
    "description": "转换数据（plotly.matplotlylib.mpltools模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "width_array": {
          "type": "integer",
          "description": "类型从参数名推断: width_array"
        }
      },
      "required": [
        "width_array"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.convert_linewidth_array",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.convert_path": {
    "name": "plotly_matplotlylib_mpltools_convert_path",
    "description": "转换数据（plotly.matplotlylib.mpltools模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "path"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.convert_path",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.convert_path_array": {
    "name": "plotly_matplotlylib_mpltools_convert_path_array",
    "description": "转换数据（plotly.matplotlylib.mpltools模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "path_array": {
          "type": "array",
          "description": "类型从参数名推断: path_array"
        }
      },
      "required": [
        "path_array"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.convert_path_array",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.convert_rgba_array": {
    "name": "plotly_matplotlylib_mpltools_convert_rgba_array",
    "description": "转换数据（plotly.matplotlylib.mpltools模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "color_list": {
          "type": "array",
          "description": "类型从参数名推断: color_list"
        }
      },
      "required": [
        "color_list"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.convert_rgba_array",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.convert_size_array": {
    "name": "plotly_matplotlylib_mpltools_convert_size_array",
    "description": "转换数据（plotly.matplotlylib.mpltools模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "size_array": {
          "type": "integer",
          "description": "类型从参数名推断: size_array"
        }
      },
      "required": [
        "size_array"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.convert_size_array",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.convert_symbol": {
    "name": "plotly_matplotlylib_mpltools_convert_symbol",
    "description": "Convert mpl marker symbol to plotly symbol and return symbol.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "mpl_symbol": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "mpl_symbol"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.convert_symbol",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.convert_va": {
    "name": "plotly_matplotlylib_mpltools_convert_va",
    "description": "Convert mpl vertical alignment word to equivalent HTML word.\nText alignment specifiers from mpl differ very slightly from those used\nin HTML. See the VA_MAP for more details.\nPositional arguments:\nmpl_va -- vertical mpl text alignment spec.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "mpl_va": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "mpl_va"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.convert_va",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.convert_x_domain": {
    "name": "plotly_matplotlylib_mpltools_convert_x_domain",
    "description": "Map x dimension of current plot to plotly's domain space.\nThe bbox used to locate an axes object in mpl differs from the\nmethod used to locate axes in plotly. The mpl version locates each\naxes in the figure so that axes in a single-plot figure might have\nthe bounds, [0.125, 0.125, 0.775, 0.775] (x0, y0, width, height),\nin mpl's figure coordinates. However, the axes all share one space in\nplotly such that the domain will always be [0, 0, 1, 1]\n(x0, y0, x1, y1). To convert between the two, the mpl figure bounds\nneed to be mapped to a [0, 1] domain for x and y. The margins set\nupon opening a new figure will appropriately match the mpl margins.\nOptionally, setting margins=0 and simply copying the domains from\nmpl to plotly would place axes appropriately. However,\nthis would throw off axis and title labeling.\nPositional arguments:\nmpl_plot_bounds -- the (x0, y0, width, height) params for current ax **\nmpl_max_x_bounds -- overall (x0, x1) bounds for all axes **\n** these are all specified in mpl figure coordinates",
    "inputSchema": {
      "type": "object",
      "properties": {
        "mpl_plot_bounds": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mpl_max_x_bounds": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "mpl_plot_bounds",
        "mpl_max_x_bounds"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.convert_x_domain",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.convert_y_domain": {
    "name": "plotly_matplotlylib_mpltools_convert_y_domain",
    "description": "Map y dimension of current plot to plotly's domain space.\nThe bbox used to locate an axes object in mpl differs from the\nmethod used to locate axes in plotly. The mpl version locates each\naxes in the figure so that axes in a single-plot figure might have\nthe bounds, [0.125, 0.125, 0.775, 0.775] (x0, y0, width, height),\nin mpl's figure coordinates. However, the axes all share one space in\nplotly such that the domain will always be [0, 0, 1, 1]\n(x0, y0, x1, y1). To convert between the two, the mpl figure bounds\nneed to be mapped to a [0, 1] domain for x and y. The margins set\nupon opening a new figure will appropriately match the mpl margins.\nOptionally, setting margins=0 and simply copying the domains from\nmpl to plotly would place axes appropriately. However,\nthis would throw off axis and title labeling.\nPositional arguments:\nmpl_plot_bounds -- the (x0, y0, width, height) params for current ax **\nmpl_max_y_bounds -- overall (y0, y1) bounds for all axes **\n** these are all specified in mpl figure coordinates",
    "inputSchema": {
      "type": "object",
      "properties": {
        "mpl_plot_bounds": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mpl_max_y_bounds": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "mpl_plot_bounds",
        "mpl_max_y_bounds"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.convert_y_domain",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.display_to_paper": {
    "name": "plotly_matplotlylib_mpltools_display_to_paper",
    "description": "Convert mpl display coordinates to plotly paper coordinates.\nPlotly references object positions with an (x, y) coordinate pair in either\n'data' or 'paper' coordinates which reference actual data in a plot or\nthe entire plotly axes space where the bottom-left of the bottom-left\nplot has the location (x, y) = (0, 0) and the top-right of the top-right\nplot has the location (x, y) = (1, 1). Display coordinates in mpl reference\nobjects with an (x, y) pair in pixel coordinates, where the bottom-left\ncorner is at the location (x, y) = (0, 0) and the top-right corner is at\nthe location (x, y) = (figwidth*dpi, figheight*dpi). Here, figwidth and\nfigheight are in inches and dpi are the dots per inch resolution.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "x": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "layout": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "x",
        "y",
        "layout"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.display_to_paper",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.get_axes_bounds": {
    "name": "plotly_matplotlylib_mpltools_get_axes_bounds",
    "description": "Return the entire axes space for figure.\nAn axes object in mpl is specified by its relation to the figure where\n(0,0) corresponds to the bottom-left part of the figure and (1,1)\ncorresponds to the top-right. Margins exist in matplotlib because axes\nobjects normally don't go to the edges of the figure.\nIn plotly, the axes area (where all subplots go) is always specified with\nthe domain [0,1] for both x and y. This function finds the smallest box,\nspecified by two points, that all of the mpl axes objects fit into. This\nbox is then used to map mpl axes domains to plotly axes domains.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.get_axes_bounds",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.get_axis_mirror": {
    "name": "plotly_matplotlylib_mpltools_get_axis_mirror",
    "description": "获取数据（plotly.matplotlylib.mpltools模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "main_spine": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mirror_spine": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "main_spine",
        "mirror_spine"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.get_axis_mirror",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.get_bar_gap": {
    "name": "plotly_matplotlylib_mpltools_get_bar_gap",
    "description": "获取数据（plotly.matplotlylib.mpltools模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "bar_starts": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "bar_ends": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "tol": {
          "type": "number",
          "default": 1e-10,
          "description": "类型从默认值推断: float"
        }
      },
      "required": [
        "bar_starts",
        "bar_ends"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.get_bar_gap",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.get_markerstyle_from_collection": {
    "name": "plotly_matplotlylib_mpltools_get_markerstyle_from_collection",
    "description": "获取数据（plotly.matplotlylib.mpltools模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.get_markerstyle_from_collection",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.get_rect_xmax": {
    "name": "plotly_matplotlylib_mpltools_get_rect_xmax",
    "description": "Find maximum x value from four (x,y) vertices.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        }
      },
      "required": [
        "data"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.get_rect_xmax",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.get_rect_xmin": {
    "name": "plotly_matplotlylib_mpltools_get_rect_xmin",
    "description": "Find minimum x value from four (x,y) vertices.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        }
      },
      "required": [
        "data"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.get_rect_xmin",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.get_rect_ymax": {
    "name": "plotly_matplotlylib_mpltools_get_rect_ymax",
    "description": "Find maximum y value from four (x,y) vertices.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        }
      },
      "required": [
        "data"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.get_rect_ymax",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.get_rect_ymin": {
    "name": "plotly_matplotlylib_mpltools_get_rect_ymin",
    "description": "Find minimum y value from four (x,y) vertices.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        }
      },
      "required": [
        "data"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.get_rect_ymin",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.get_spine_visible": {
    "name": "plotly_matplotlylib_mpltools_get_spine_visible",
    "description": "Return some spine parameters for the spine, `spine_key`.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "spine_key": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "spine_key"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.get_spine_visible",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.hex_to_rgb": {
    "name": "plotly_matplotlylib_mpltools_hex_to_rgb",
    "description": "Change a hex color to an rgb tuple\n\n\nExample:\n\n'#FFFFFF' --> (255, 255, 255)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "value"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.hex_to_rgb",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.is_bar": {
    "name": "plotly_matplotlylib_mpltools_is_bar",
    "description": "A test to decide whether a path is a bar from a vertical bar chart.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "bar_containers": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "bar_containers",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.is_bar",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    },
    "outputSchema": {
      "type": "boolean"
    }
  },
  "plotly.matplotlylib.mpltools.make_bar": {
    "name": "plotly_matplotlylib_mpltools_make_bar",
    "description": "Make an intermediate bar dictionary.\nThis creates a bar dictionary which aids in the comparison of new bars to\nold bars from other bar chart (patch) collections. This is not the\ndictionary that needs to get passed to plotly as a data dictionary. That\nhappens in PlotlyRenderer in that class's draw_bar method. In other\nwords, this dictionary describes a SINGLE bar, whereas, plotly will\nrequire a set of bars to be passed in a data dictionary.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.make_bar",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.merge_color_and_opacity": {
    "name": "plotly_matplotlylib_mpltools_merge_color_and_opacity",
    "description": "Merge hex color with an alpha (opacity) to get an rgba tuple.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "color": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "opacity": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "color",
        "opacity"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.merge_color_and_opacity",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.mpl_dates_to_datestrings": {
    "name": "plotly_matplotlylib_mpltools_mpl_dates_to_datestrings",
    "description": "Convert matplotlib dates to iso-formatted-like time strings.\nPlotly's accepted format: \"YYYY-MM-DD HH:MM:SS\" (e.g., 2001-01-01 00:00:00)\nInfo on mpl dates: http://matplotlib.org/api/dates_api.html",
    "inputSchema": {
      "type": "object",
      "properties": {
        "dates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mpl_formatter": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "dates",
        "mpl_formatter"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.mpl_dates_to_datestrings",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.prep_ticks": {
    "name": "plotly_matplotlylib_mpltools_prep_ticks",
    "description": "Prepare axis obj belonging to axes obj.\npositional arguments:\nax - the mpl axes instance\nindex - the index of the axis in `props`\nax_type - 'x' or 'y' (for now)\nprops - an mplexporter poperties dictionary",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "index": {
          "type": "integer",
          "description": "类型从参数名推断: index"
        },
        "ax_type": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "index",
        "ax_type",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.prep_ticks",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.mpltools.prep_xy_axis": {
    "name": "plotly_matplotlylib_mpltools_prep_xy_axis",
    "description": "执行prep_xy_axis操作（plotly.matplotlylib.mpltools模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "x_bounds": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y_bounds": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "props",
        "x_bounds",
        "y_bounds"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.mpltools.prep_xy_axis",
      "module": "plotly.matplotlylib.mpltools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.warning_on_one_line": {
    "name": "plotly_matplotlylib_renderer_warning_on_one_line",
    "description": "执行warning_on_one_line操作（plotly.matplotlylib.renderer模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "msg": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "category": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "filename": {
          "type": "string",
          "description": "类型从参数名推断: filename"
        },
        "lineno": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "file": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "line": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "msg",
        "category",
        "filename",
        "lineno"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.warning_on_one_line",
      "module": "plotly.matplotlylib.renderer",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.ax_has_xgrid": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_ax_has_xgrid",
    "description": "执行ax_has_xgrid操作（PlotlyRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.ax_has_xgrid",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.ax_has_ygrid": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_ax_has_ygrid",
    "description": "执行ax_has_ygrid操作（PlotlyRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.ax_has_ygrid",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.ax_zoomable": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_ax_zoomable",
    "description": "执行ax_zoomable操作（PlotlyRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.ax_zoomable",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.close_axes": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_close_axes",
    "description": "Close the axes object and clean up.\nBars from bar charts are given to PlotlyRenderer one-by-one,\nthus they need to be taken care of at the close of each axes object.\nThe self.current_bars variable should be empty unless a bar\nchart has been created.\nPositional arguments:\nax -- an mpl axes object, not required at this time.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.close_axes",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.close_figure": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_close_figure",
    "description": "Closes figure by cleaning up data and layout dictionaries.\nThe PlotlyRenderer's job is to create an appropriate set of data and\nlayout dictionaries. When the figure is closed, some cleanup and\nrepair is necessary. This method removes inappropriate dictionary\nentries, freeing up Plotly to use defaults and best judgements to\ncomplete the entries. This method is called by an Exporter object.\nPositional arguments:\nfig -- a matplotlib.figure.Figure object.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.close_figure",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.close_legend": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_close_legend",
    "description": "Finish commands for a particular legend.\nParameters\n----------\nlegend : matplotlib.legend.Legend\nThe Legend which is finished being drawn",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.close_legend",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_axes": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_axes",
    "description": "执行draw_axes操作（PlotlyRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_axes",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_bar": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_bar",
    "description": "Draw a collection of similar patches as a bar chart.\nAfter bars are sorted, an appropriate data dictionary must be created\nto tell plotly about this data. Just like draw_line or draw_markers,\ndraw_bar translates patch/path information into something plotly\nunderstands.\nPositional arguments:\npatch_coll -- a collection of patches to be drawn as a bar chart.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "coll": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "coll"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_bar",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_bars": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_bars",
    "description": "执行draw_bars操作（PlotlyRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "bars": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "bars"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_bars",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_figure": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_figure",
    "description": "执行draw_figure操作（PlotlyRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_figure",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_image": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_image",
    "description": "Draw image.\nNot implemented yet!",
    "inputSchema": {
      "type": "object",
      "properties": {
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_image",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_legend": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_legend",
    "description": "执行draw_legend操作（PlotlyRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_legend",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_legend_shapes": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_legend_shapes",
    "description": "Create a shape that matches lines or markers in legends.\nMain issue is that path for circles do not render, so we have to use 'circle'\ninstead of 'path'.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "mode": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "shape": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "mode",
        "shape",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_legend_shapes",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_line": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_line",
    "description": "Draw a line. By default, draw the line via the draw_path() command.\nSome renderers might wish to override this and provide more\nfine-grained behavior.\nIn matplotlib, lines are generally created via the plt.plot() command,\nthough this command also can create marker collections.\nParameters\n----------\ndata : array_like\nA shape (N, 2) array of datapoints.\ncoordinates : string\nA string code, which should be either 'data' for data coordinates,\nor 'figure' for figure (pixel) coordinates.\nstyle : dictionary\na dictionary specifying the appearance of the line.\nmplobj : matplotlib object\nthe matplotlib plot element which generated this line",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "style",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_line",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_marked_line": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_marked_line",
    "description": "Create a data dict for a line obj.\nThis will draw 'lines', 'markers', or 'lines+markers'. For legend elements,\nthis will use layout.shapes, so they can be positioned with paper refs.\nprops.keys() -- [\n'coordinates',  ('data', 'axes', 'figure', or 'display')\n'data',         (a list of xy pairs)\n'mplobj',       (the matplotlib.lines.Line2D obj being rendered)\n'label',        (the name of the Line2D obj being rendered)\n'linestyle',    (linestyle dict, can be None, see below)\n'markerstyle',  (markerstyle dict, can be None, see below)\n]\nprops['linestyle'].keys() -- [\n'alpha',        (opacity of Line2D obj)\n'color',        (color of the line if it exists, not the marker)\n'linewidth',\n'dasharray',    (code for linestyle, see DASH_MAP in mpltools.py)\n'zorder',       (viewing precedence when stacked with other objects)\n]\nprops['markerstyle'].keys() -- [\n'alpha',        (opacity of Line2D obj)\n'marker',       (the mpl marker symbol, see SYMBOL_MAP in mpltools.py)\n'facecolor',    (color of the marker face)\n'edgecolor',    (color of the marker edge)\n'edgewidth',    (width of marker edge)\n'markerpath',   (an SVG path for drawing the specified marker)\n'zorder',       (viewing precedence when stacked with other objects)\n]",
    "inputSchema": {
      "type": "object",
      "properties": {
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_marked_line",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_markers": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_markers",
    "description": "Draw a set of markers. By default, this is done by repeatedly\ncalling draw_path(), but renderers should generally overload\nthis method to provide a more efficient implementation.\nIn matplotlib, markers are created using the plt.plot() command.\nParameters\n----------\ndata : array_like\nA shape (N, 2) array of datapoints.\ncoordinates : string\nA string code, which should be either 'data' for data coordinates,\nor 'figure' for figure (pixel) coordinates.\nstyle : dictionary\na dictionary specifying the appearance of the markers.\nmplobj : matplotlib object\nthe matplotlib plot element which generated this marker collection",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "coordinates": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "style": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "label": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "mplobj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "data",
        "coordinates",
        "style",
        "label"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_markers",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_path": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_path",
    "description": "Draw path, currently only attempts to draw bar charts.\nThis function attempts to sort a given path into a collection of\nhorizontal or vertical bar charts. Most of the actual code takes\nplace in functions from mpltools.py.\nprops.keys() -- [\n'data',         (a list of verticies for the path)\n'coordinates',  ('data', 'axes', 'figure', or 'display')\n'pathcodes',    (code for the path, structure: ['M', 'L', 'Z', etc.])\n'style',        (style dict, see below)\n'mplobj'        (the mpl path object)\n]\nprops['style'].keys() -- [\n'alpha',        (opacity of path obj)\n'edgecolor',\n'facecolor',\n'edgewidth',\n'dasharray',    (style for path's enclosing line)\n'zorder'        (precedence of obj when stacked)\n]",
    "inputSchema": {
      "type": "object",
      "properties": {
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_path",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_path_collection": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_path_collection",
    "description": "Add a path collection to data list as a scatter plot.\nCurrent implementation defaults such collections as scatter plots.\nMatplotlib supports collections that have many of the same parameters\nin common like color, size, path, etc. However, they needn't all be\nthe same. Plotly does not currently support such functionality and\ntherefore, the style for the first object is taken and used to define\nthe remaining paths in the collection.\nprops.keys() -- [\n'paths',                (structure: [vertices, path_code])\n'path_coordinates',     ('data', 'axes', 'figure', or 'display')\n'path_transforms',      (mpl transform, including Affine2D matrix)\n'offsets',              (offset from axes, helpful if in 'data')\n'offset_coordinates',   ('data', 'axes', 'figure', or 'display')\n'offset_order',\n'styles',               (style dict, see below)\n'mplobj'                (the collection obj being drawn)\n]\nprops['styles'].keys() -- [\n'linewidth',            (one or more linewidths)\n'facecolor',            (one or more facecolors for path)\n'edgecolor',            (one or more edgecolors for path)\n'alpha',                (one or more opacites for path)\n'zorder',               (precedence when stacked)\n]",
    "inputSchema": {
      "type": "object",
      "properties": {
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_path_collection",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_text": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_text",
    "description": "Create an annotation dict for a text obj.\nCurrently, plotly uses either 'page' or 'data' to reference\nannotation locations. These refer to 'display' and 'data',\nrespectively for the 'coordinates' key used in the Exporter.\nAppropriate measures are taken to transform text locations to\nreference one of these two options.\nprops.keys() -- [\n'text',         (actual content string, not the text obj)\n'position',     (an x, y pair, not an mpl Bbox)\n'coordinates',  ('data', 'axes', 'figure', 'display')\n'text_type',    ('title', 'xlabel', or 'ylabel')\n'style',        (style dict, see below)\n'mplobj'        (actual mpl text object)\n]\nprops['style'].keys() -- [\n'alpha',        (opacity of text)\n'fontsize',     (size in points of text)\n'color',        (hex color)\n'halign',       (horizontal alignment, 'left', 'center', or 'right')\n'valign',       (vertical alignment, 'baseline', 'center', or 'top')\n'rotation',\n'zorder',       (precedence of text when stacked with other objs)\n]",
    "inputSchema": {
      "type": "object",
      "properties": {
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_text",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_title": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_title",
    "description": "Add a title to the current subplot in layout dictionary.\nIf there exists more than a single plot in the figure, titles revert\nto 'page'-referenced annotations.\nprops.keys() -- [\n'text',         (actual content string, not the text obj)\n'position',     (an x, y pair, not an mpl Bbox)\n'coordinates',  ('data', 'axes', 'figure', 'display')\n'text_type',    ('title', 'xlabel', or 'ylabel')\n'style',        (style dict, see below)\n'mplobj'        (actual mpl text object)\n]\nprops['style'].keys() -- [\n'alpha',        (opacity of text)\n'fontsize',     (size in points of text)\n'color',        (hex color)\n'halign',       (horizontal alignment, 'left', 'center', or 'right')\n'valign',       (vertical alignment, 'baseline', 'center', or 'top')\n'rotation',\n'zorder',       (precedence of text when stacked with other objs)\n]",
    "inputSchema": {
      "type": "object",
      "properties": {
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_title",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_xlabel": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_xlabel",
    "description": "Add an xaxis label to the current subplot in layout dictionary.\nprops.keys() -- [\n'text',         (actual content string, not the text obj)\n'position',     (an x, y pair, not an mpl Bbox)\n'coordinates',  ('data', 'axes', 'figure', 'display')\n'text_type',    ('title', 'xlabel', or 'ylabel')\n'style',        (style dict, see below)\n'mplobj'        (actual mpl text object)\n]\nprops['style'].keys() -- [\n'alpha',        (opacity of text)\n'fontsize',     (size in points of text)\n'color',        (hex color)\n'halign',       (horizontal alignment, 'left', 'center', or 'right')\n'valign',       (vertical alignment, 'baseline', 'center', or 'top')\n'rotation',\n'zorder',       (precedence of text when stacked with other objs)\n]",
    "inputSchema": {
      "type": "object",
      "properties": {
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_xlabel",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.draw_ylabel": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_draw_ylabel",
    "description": "Add a yaxis label to the current subplot in layout dictionary.\nprops.keys() -- [\n'text',         (actual content string, not the text obj)\n'position',     (an x, y pair, not an mpl Bbox)\n'coordinates',  ('data', 'axes', 'figure', 'display')\n'text_type',    ('title', 'xlabel', or 'ylabel')\n'style',        (style dict, see below)\n'mplobj'        (actual mpl text object)\n]\nprops['style'].keys() -- [\n'alpha',        (opacity of text)\n'fontsize',     (size in points of text)\n'color',        (hex color)\n'halign',       (horizontal alignment, 'left', 'center', or 'right')\n'valign',       (vertical alignment, 'baseline', 'center', or 'top')\n'rotation',\n'zorder',       (precedence of text when stacked with other objs)\n]",
    "inputSchema": {
      "type": "object",
      "properties": {
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.draw_ylabel",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.open_axes": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_open_axes",
    "description": "Setup a new axes object (subplot in plotly).\nPlotly stores information about subplots in different 'xaxis' and\n'yaxis' objects which are numbered. These are just dictionaries\nincluded in the layout dictionary. This function takes information\nfrom the Exporter, fills in appropriate dictionary entries,\nand updates the layout dictionary. PlotlyRenderer keeps track of the\nnumber of plots by incrementing the axis_ct attribute.\nSetting the proper plot domain in plotly is a bit tricky. Refer to\nthe documentation for mpltools.convert_x_domain and\nmpltools.convert_y_domain.\nPositional arguments:\nax -- an mpl axes object. This will become a subplot in plotly.\nprops.keys() -- [\n'axesbg',           (background color for axes obj)\n'axesbgalpha',      (alpha, or opacity for background)\n'bounds',           ((x0, y0, width, height) for axes)\n'dynamic',          (zoom/pan-able?)\n'axes',             (list: [xaxis, yaxis])\n'xscale',           (log, linear, or date)\n'yscale',\n'xlim',             (range limits for x)\n'ylim',\n'xdomain'           (xdomain=xlim, unless it's a date)\n'ydomain'\n]",
    "inputSchema": {
      "type": "object",
      "properties": {
        "ax": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "ax",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.open_axes",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.open_figure": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_open_figure",
    "description": "Creates a new figure by beginning to fill out layout dict.\nThe 'autosize' key is set to false so that the figure will mirror\nsizes set by mpl. The 'hovermode' key controls what shows up when you\nmouse around a figure in plotly, it's set to show the 'closest' point.\nPositional agurments:\nfig -- a matplotlib.figure.Figure object.\nprops.keys(): [\n'figwidth',\n'figheight',\n'dpi'\n]",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fig",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.open_figure",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.open_legend": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_open_legend",
    "description": "Beging commands for a particular legend.\nParameters\n----------\nlegend : matplotlib.legend.Legend\nThe Legend that will contain the ensuing elements\nprops : dictionary\nThe dictionary of legend properties",
    "inputSchema": {
      "type": "object",
      "properties": {
        "legend": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "props": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "legend",
        "props"
      ]
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.open_legend",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.resize": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_resize",
    "description": "Revert figure layout to allow plotly to resize.\nBy default, PlotlyRenderer tries its hardest to precisely mimic an\nmpl figure. However, plotly is pretty good with aesthetics. By\nrunning PlotlyRenderer.resize(), layout parameters are deleted. This\nlets plotly choose them instead of mpl.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.resize",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.matplotlylib.renderer.PlotlyRenderer.strip_style": {
    "name": "plotly_matplotlylib_renderer_PlotlyRenderer_strip_style",
    "description": "执行strip_style操作（PlotlyRenderer类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.matplotlylib.renderer.PlotlyRenderer.strip_style",
      "module": "plotly.matplotlylib.renderer",
      "class_name": "PlotlyRenderer",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.add_hline": {
    "name": "plotly_missing_ipywidgets_FigureWidget_add_hline",
    "description": "Add a horizontal line to a plot or subplot that extends infinitely in the\nx-dimension.\nParameters\n----------\ny: float or int\nA number representing the y coordinate of the horizontal line.\nexclude_empty_subplots: Boolean\nIf True (default) do not place the shape on subplots that have no data\nplotted on them.\nrow: None, int or 'all'\nSubplot row for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\ncol: None, int or 'all'\nSubplot column for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\nannotation: dict or plotly.graph_objects.layout.Annotation. If dict(),\nit is interpreted as describing an annotation. The annotation is\nplaced relative to the shape based on annotation_position (see\nbelow) unless its x or y value has been specified for the annotation\npassed here. xref and yref are always the same as for the added\nshape and cannot be overridden.\nannotation_position: a string containing optionally [\"top\", \"bottom\"]\nand [\"left\", \"right\"] specifying where the text should be anchored\nto on the line. Example positions are \"bottom left\", \"right top\",\n\"right\", \"bottom\". If an annotation is added but annotation_position is\nnot specified, this defaults to \"top right\".\nannotation_*: any parameters to go.layout.Annotation can be passed as\nkeywords by prefixing them with \"annotation_\". For example, to specify the\nannotation text \"example\" you can pass annotation_text=\"example\" as a\nkeyword argument.\n**kwargs:\nAny named function parameters that can be passed to 'add_shape',\nexcept for x0, x1, y0, y1 or type.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "col": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "annotation": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "y",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.add_hline",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.add_hrect": {
    "name": "plotly_missing_ipywidgets_FigureWidget_add_hrect",
    "description": "Add a rectangle to a plot or subplot that extends infinitely in the\nx-dimension.\nParameters\n----------\ny0: float or int\nA number representing the y coordinate of one side of the rectangle.\ny1: float or int\nA number representing the y coordinate of the other side of the rectangle.\nexclude_empty_subplots: Boolean\nIf True (default) do not place the shape on subplots that have no data\nplotted on them.\nrow: None, int or 'all'\nSubplot row for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\ncol: None, int or 'all'\nSubplot column for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\nannotation: dict or plotly.graph_objects.layout.Annotation. If dict(),\nit is interpreted as describing an annotation. The annotation is\nplaced relative to the shape based on annotation_position (see\nbelow) unless its x or y value has been specified for the annotation\npassed here. xref and yref are always the same as for the added\nshape and cannot be overridden.\nannotation_position: a string containing optionally [\"inside\", \"outside\"], [\"top\", \"bottom\"]\nand [\"left\", \"right\"] specifying where the text should be anchored\nto on the rectangle. Example positions are \"outside top left\", \"inside\nbottom\", \"right\", \"inside left\", \"inside\" (\"outside\" is not supported). If\nan annotation is added but annotation_position is not specified this\ndefaults to \"inside top right\".\nannotation_*: any parameters to go.layout.Annotation can be passed as\nkeywords by prefixing them with \"annotation_\". For example, to specify the\nannotation text \"example\" you can pass annotation_text=\"example\" as a\nkeyword argument.\n**kwargs:\nAny named function parameters that can be passed to 'add_shape',\nexcept for x0, x1, y0, y1 or type.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "y0": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "y1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "col": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "annotation": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "y0",
        "y1",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.add_hrect",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.add_trace": {
    "name": "plotly_missing_ipywidgets_FigureWidget_add_trace",
    "description": "Add a trace to the figure\nParameters\n----------\ntrace : BaseTraceType or dict\nEither:\n- An instances of a trace classe from the plotly.graph_objs\npackage (e.g plotly.graph_objs.Scatter, plotly.graph_objs.Bar)\n- or a dicts where:\n- The 'type' property specifies the trace type (e.g.\n'scatter', 'bar', 'area', etc.). If the dict has no 'type'\nproperty then 'scatter' is assumed.\n- All remaining properties are passed to the constructor\nof the specified trace type.\nrow : 'all', int or None (default)\nSubplot row index (starting from 1) for the trace to be\nadded. Only valid if figure was created using\n`plotly.tools.make_subplots`.\nIf 'all', addresses all rows in the specified column(s).\ncol : 'all', int or None (default)\nSubplot col index (starting from 1) for the trace to be\nadded. Only valid if figure was created using\n`plotly.tools.make_subplots`.\nIf 'all', addresses all columns in the specified row(s).\nsecondary_y: boolean or None (default None)\nIf True, associate this trace with the secondary y-axis of the\nsubplot at the specified row and col. Only valid if all of the\nfollowing conditions are satisfied:\n* The figure was created using `plotly.subplots.make_subplots`.\n* The row and col arguments are not None\n* The subplot at the specified row and col has type xy\n(which is the default) and secondary_y True.  These\nproperties are specified in the specs argument to\nmake_subplots. See the make_subplots docstring for more info.\n* The trace argument is a 2D cartesian trace\n(scatter, bar, etc.)\nexclude_empty_subplots: boolean\nIf True, the trace will not be added to subplots that don't already\nhave traces.\nReturns\n-------\nBaseFigure\nThe Figure that add_trace was called on\nExamples\n--------\n>>> from plotly import subplots\n>>> import plotly.graph_objs as go\nAdd two Scatter traces to a figure\n>>> fig = go.Figure()\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2])) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2])) # doctest: +ELLIPSIS\nFigure(...)\nAdd two Scatter traces to vertically stacked subplots\n>>> fig = subplots.make_subplots(rows=2)\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=1, col=1) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=2, col=1) # doctest: +ELLIPSIS\nFigure(...)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "trace": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "trace"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.add_trace",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.add_traces": {
    "name": "plotly_missing_ipywidgets_FigureWidget_add_traces",
    "description": "Add traces to the figure\nParameters\n----------\ndata : list[BaseTraceType or dict]\nA list of trace specifications to be added.\nTrace specifications may be either:\n- Instances of trace classes from the plotly.graph_objs\npackage (e.g plotly.graph_objs.Scatter, plotly.graph_objs.Bar)\n- Dicts where:\n- The 'type' property specifies the trace type (e.g.\n'scatter', 'bar', 'area', etc.). If the dict has no 'type'\nproperty then 'scatter' is assumed.\n- All remaining properties are passed to the constructor\nof the specified trace type.\nrows : None, list[int], or int (default None)\nList of subplot row indexes (starting from 1) for the traces to be\nadded. Only valid if figure was created using\n`plotly.tools.make_subplots`\nIf a single integer is passed, all traces will be added to row number\ncols : None or list[int] (default None)\nList of subplot column indexes (starting from 1) for the traces\nto be added. Only valid if figure was created using\n`plotly.tools.make_subplots`\nIf a single integer is passed, all traces will be added to column number\nsecondary_ys: None or list[boolean] (default None)\nList of secondary_y booleans for traces to be added. See the\ndocstring for `add_trace` for more info.\nexclude_empty_subplots: boolean\nIf True, the trace will not be added to subplots that don't already\nhave traces.\nReturns\n-------\nBaseFigure\nThe Figure that add_traces was called on\nExamples\n--------\n>>> from plotly import subplots\n>>> import plotly.graph_objs as go\nAdd two Scatter traces to a figure\n>>> fig = go.Figure()\n>>> fig.add_traces([go.Scatter(x=[1,2,3], y=[2,1,2]),\n...                 go.Scatter(x=[1,2,3], y=[2,1,2])]) # doctest: +ELLIPSIS\nFigure(...)\nAdd two Scatter traces to vertically stacked subplots\n>>> fig = subplots.make_subplots(rows=2)\n>>> fig.add_traces([go.Scatter(x=[1,2,3], y=[2,1,2]),\n...                 go.Scatter(x=[1,2,3], y=[2,1,2])],\n...                 rows=[1, 2], cols=[1, 1]) # doctest: +ELLIPSIS\nFigure(...)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "data": {
          "type": "object",
          "description": "类型从参数名推断: data"
        },
        "rows": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "cols": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_ys": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "data"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.add_traces",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.add_vline": {
    "name": "plotly_missing_ipywidgets_FigureWidget_add_vline",
    "description": "Add a vertical line to a plot or subplot that extends infinitely in the\ny-dimension.\nParameters\n----------\nx: float or int\nA number representing the x coordinate of the vertical line.\nexclude_empty_subplots: Boolean\nIf True (default) do not place the shape on subplots that have no data\nplotted on them.\nrow: None, int or 'all'\nSubplot row for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\ncol: None, int or 'all'\nSubplot column for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\nannotation: dict or plotly.graph_objects.layout.Annotation. If dict(),\nit is interpreted as describing an annotation. The annotation is\nplaced relative to the shape based on annotation_position (see\nbelow) unless its x or y value has been specified for the annotation\npassed here. xref and yref are always the same as for the added\nshape and cannot be overridden.\nannotation_position: a string containing optionally [\"top\", \"bottom\"]\nand [\"left\", \"right\"] specifying where the text should be anchored\nto on the line. Example positions are \"bottom left\", \"right top\",\n\"right\", \"bottom\". If an annotation is added but annotation_position is\nnot specified, this defaults to \"top right\".\nannotation_*: any parameters to go.layout.Annotation can be passed as\nkeywords by prefixing them with \"annotation_\". For example, to specify the\nannotation text \"example\" you can pass annotation_text=\"example\" as a\nkeyword argument.\n**kwargs:\nAny named function parameters that can be passed to 'add_shape',\nexcept for x0, x1, y0, y1 or type.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "x": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "col": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "annotation": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "x",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.add_vline",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.add_vrect": {
    "name": "plotly_missing_ipywidgets_FigureWidget_add_vrect",
    "description": "Add a rectangle to a plot or subplot that extends infinitely in the\ny-dimension.\nParameters\n----------\nx0: float or int\nA number representing the x coordinate of one side of the rectangle.\nx1: float or int\nA number representing the x coordinate of the other side of the rectangle.\nexclude_empty_subplots: Boolean\nIf True (default) do not place the shape on subplots that have no data\nplotted on them.\nrow: None, int or 'all'\nSubplot row for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\ncol: None, int or 'all'\nSubplot column for shape indexed starting at 1. If 'all', addresses all rows in\nthe specified column(s). If both row and col are None, addresses the\nfirst subplot if subplots exist, or the only plot. By default is \"all\".\nannotation: dict or plotly.graph_objects.layout.Annotation. If dict(),\nit is interpreted as describing an annotation. The annotation is\nplaced relative to the shape based on annotation_position (see\nbelow) unless its x or y value has been specified for the annotation\npassed here. xref and yref are always the same as for the added\nshape and cannot be overridden.\nannotation_position: a string containing optionally [\"inside\", \"outside\"], [\"top\", \"bottom\"]\nand [\"left\", \"right\"] specifying where the text should be anchored\nto on the rectangle. Example positions are \"outside top left\", \"inside\nbottom\", \"right\", \"inside left\", \"inside\" (\"outside\" is not supported). If\nan annotation is added but annotation_position is not specified this\ndefaults to \"inside top right\".\nannotation_*: any parameters to go.layout.Annotation can be passed as\nkeywords by prefixing them with \"annotation_\". For example, to specify the\nannotation text \"example\" you can pass annotation_text=\"example\" as a\nkeyword argument.\n**kwargs:\nAny named function parameters that can be passed to 'add_shape',\nexcept for x0, x1, y0, y1 or type.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "x0": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "x1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "col": {
          "type": "string",
          "default": "all",
          "description": "类型从默认值推断: str"
        },
        "exclude_empty_subplots": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "annotation": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "x0",
        "x1",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.add_vrect",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.append_trace": {
    "name": "plotly_missing_ipywidgets_FigureWidget_append_trace",
    "description": "Add a trace to the figure bound to axes at the specified row,\ncol index.\nA row, col index grid is generated for figures created with\nplotly.tools.make_subplots, and can be viewed with the `print_grid`\nmethod\nParameters\n----------\ntrace\nThe data trace to be bound\nrow: int\nSubplot row index (see Figure.print_grid)\ncol: int\nSubplot column index (see Figure.print_grid)\nExamples\n--------\n>>> from plotly import tools\n>>> import plotly.graph_objs as go\n>>> # stack two subplots vertically\n>>> fig = tools.make_subplots(rows=2)\nThis is the format of your plot grid:\n[ (1,1) x1,y1 ]\n[ (2,1) x2,y2 ]\n>>> fig.append_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=1, col=1)\n>>> fig.append_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=2, col=1)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "trace": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "trace",
        "row",
        "col"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.append_trace",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.batch_animate": {
    "name": "plotly_missing_ipywidgets_FigureWidget_batch_animate",
    "description": "Context manager to animate trace / layout updates\nParameters\n----------\nduration : number\nThe duration of the transition, in milliseconds.\nIf equal to zero, updates are synchronous.\neasing : string\nThe easing function used for the transition.\nOne of:\n- linear\n- quad\n- cubic\n- sin\n- exp\n- circle\n- elastic\n- back\n- bounce\n- linear-in\n- quad-in\n- cubic-in\n- sin-in\n- exp-in\n- circle-in\n- elastic-in\n- back-in\n- bounce-in\n- linear-out\n- quad-out\n- cubic-out\n- sin-out\n- exp-out\n- circle-out\n- elastic-out\n- back-out\n- bounce-out\n- linear-in-out\n- quad-in-out\n- cubic-in-out\n- sin-in-out\n- exp-in-out\n- circle-in-out\n- elastic-in-out\n- back-in-out\n- bounce-in-out\nExamples\n--------\nSuppose we have a figure widget, `fig`, with a single trace.\n>>> import plotly.graph_objs as go\n>>> fig = go.FigureWidget(data=[{'y': [3, 4, 2]}])\n1) Animate a change in the xaxis and yaxis ranges using default\nduration and easing parameters.\n>>> with fig.batch_animate():\n...     fig.layout.xaxis.range = [0, 5]\n...     fig.layout.yaxis.range = [0, 10]\n2) Animate a change in the size and color of the trace's markers\nover 2 seconds using the elastic-in-out easing method\n>>> with fig.batch_animate(duration=2000, easing='elastic-in-out'):\n...     fig.data[0].marker.color = 'green'\n...     fig.data[0].marker.size = 20",
    "inputSchema": {
      "type": "object",
      "properties": {
        "duration": {
          "type": "integer",
          "default": 500,
          "description": "类型从默认值推断: int"
        },
        "easing": {
          "type": "string",
          "default": "cubic-in-out",
          "description": "类型从默认值推断: str"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.batch_animate",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.batch_update": {
    "name": "plotly_missing_ipywidgets_FigureWidget_batch_update",
    "description": "A context manager that batches up trace and layout assignment\noperations into a singe plotly_update message that is executed when\nthe context exits.\nExamples\n--------\nFor example, suppose we have a figure widget, `fig`, with a single\ntrace.\n>>> import plotly.graph_objs as go\n>>> fig = go.FigureWidget(data=[{'y': [3, 4, 2]}])\nIf we want to update the xaxis range, the yaxis range, and the\nmarker color, we could do so using a series of three property\nassignments as follows:\n>>> fig.layout.xaxis.range = [0, 5]\n>>> fig.layout.yaxis.range = [0, 10]\n>>> fig.data[0].marker.color = 'green'\nThis will work, however it will result in three messages being\nsent to the front end (two relayout messages for the axis range\nupdates followed by one restyle message for the marker color\nupdate). This can cause the plot to appear to stutter as the\nthree updates are applied incrementally.\nWe can avoid this problem by performing these three assignments in a\n`batch_update` context as follows:\n>>> with fig.batch_update():\n...     fig.layout.xaxis.range = [0, 5]\n...     fig.layout.yaxis.range = [0, 10]\n...     fig.data[0].marker.color = 'green'\nNow, these three property updates will be sent to the frontend in a\nsingle update message, and they will be applied by the front end\nsimultaneously.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.batch_update",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.for_each_trace": {
    "name": "plotly_missing_ipywidgets_FigureWidget_for_each_trace",
    "description": "Apply a function to all traces that satisfy the specified selection\ncriteria\nParameters\n----------\nfn:\nFunction that inputs a single trace object.\nselector: dict, function, int, str or None (default None)\nDict to use as selection criteria.\nTraces will be selected if they contain properties corresponding\nto all of the dictionary's keys, with values that exactly match\nthe supplied values. If None (the default), all traces are\nselected. If a function, it must be a function accepting a single\nargument and returning a boolean. The function will be called on\neach trace and those for which the function returned True\nwill be in the selection. If an int N, the Nth trace matching row\nand col will be selected (N can be negative). If a string S, the selector\nis equivalent to dict(type=S).\nrow, col: int or None (default None)\nSubplot row and column index of traces to select.\nTo select traces by row and column, the Figure must have been\ncreated using plotly.subplots.make_subplots.  If None\n(the default), all traces are selected.\nsecondary_y: boolean or None (default None)\n* If True, only select traces associated with the secondary\ny-axis of the subplot.\n* If False, only select traces associated with the primary\ny-axis of the subplot.\n* If None (the default), do not filter traces based on secondary\ny-axis.\nTo select traces by secondary y-axis, the Figure must have been\ncreated using plotly.subplots.make_subplots. See the docstring\nfor the specs argument to make_subplots for more info on\ncreating subplots with secondary y-axes.\nReturns\n-------\nself\nReturns the Figure object that the method was called on",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fn": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "selector": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "fn"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.for_each_trace",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.full_figure_for_development": {
    "name": "plotly_missing_ipywidgets_FigureWidget_full_figure_for_development",
    "description": "Compute default values for all attributes not specified in the input figure and\nreturns the output as a \"full\" figure. This function calls Plotly.js via Kaleido\nto populate unspecified attributes. This function is intended for interactive use\nduring development to learn more about how Plotly.js computes default values and is\nnot generally necessary or recommended for production use.\nParameters\n----------\nfig:\nFigure object or dict representing a figure\nwarn: bool\nIf False, suppress warnings about not using this in production.\nas_dict: bool\nIf True, output is a dict with some keys that go.Figure can't parse.\nIf False, output is a go.Figure with unparseable keys skipped.\nReturns\n-------\nplotly.graph_objects.Figure or dict\nThe full figure",
    "inputSchema": {
      "type": "object",
      "properties": {
        "warn": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "as_dict": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.full_figure_for_development",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.get_subplot": {
    "name": "plotly_missing_ipywidgets_FigureWidget_get_subplot",
    "description": "Return an object representing the subplot at the specified row\nand column.  May only be used on Figures created using\nplotly.tools.make_subplots\nParameters\n----------\nrow: int\n1-based index of subplot row\ncol: int\n1-based index of subplot column\nsecondary_y: bool\nIf True, select the subplot that consists of the x-axis and the\nsecondary y-axis at the specified row/col. Only valid if the\nsubplot at row/col is an 2D cartesian subplot that was created\nwith a secondary y-axis.  See the docstring for the specs argument\nto make_subplots for more info on creating a subplot with a\nsecondary y-axis.\nReturns\n-------\nsubplot\n* None: if subplot is empty\n* plotly.graph_objs.layout.Scene: if subplot type is 'scene'\n* plotly.graph_objs.layout.Polar: if subplot type is 'polar'\n* plotly.graph_objs.layout.Ternary: if subplot type is 'ternary'\n* plotly.graph_objs.layout.Mapbox: if subplot type is 'ternary'\n* SubplotDomain namedtuple with `x` and `y` fields:\nif subplot type is 'domain'.\n- x: length 2 list of the subplot start and stop width\n- y: length 2 list of the subplot start and stop height\n* SubplotXY namedtuple with `xaxis` and `yaxis` fields:\nif subplot type is 'xy'.\n- xaxis: plotly.graph_objs.layout.XAxis instance for subplot\n- yaxis: plotly.graph_objs.layout.YAxis instance for subplot",
    "inputSchema": {
      "type": "object",
      "properties": {
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "row",
        "col"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.get_subplot",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.plotly_relayout": {
    "name": "plotly_missing_ipywidgets_FigureWidget_plotly_relayout",
    "description": "Perform a Plotly relayout operation on the figure's layout\nParameters\n----------\nrelayout_data : dict\nDict of layout updates\ndict keys are strings that specify the properties to be updated.\nNested properties are expressed by joining successive keys on\n'.' characters (e.g. 'xaxis.range')\ndict values are the values to use to update the layout.\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "relayout_data": {
          "type": "object",
          "description": "类型从参数名推断: relayout_data"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "relayout_data",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.plotly_relayout",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.plotly_restyle": {
    "name": "plotly_missing_ipywidgets_FigureWidget_plotly_restyle",
    "description": "Perform a Plotly restyle operation on the figure's traces\nParameters\n----------\nrestyle_data : dict\nDict of trace style updates.\nKeys are strings that specify the properties to be updated.\nNested properties are expressed by joining successive keys on\n'.' characters (e.g. 'marker.color').\nValues may be scalars or lists. When values are scalars,\nthat scalar value is applied to all traces specified by the\n`trace_indexes` parameter.  When values are lists,\nthe restyle operation will cycle through the elements\nof the list as it cycles through the traces specified by the\n`trace_indexes` parameter.\nCaution: To use plotly_restyle to update a list property (e.g.\nthe `x` property of the scatter trace), the property value\nshould be a scalar list containing the list to update with. For\nexample, the following command would be used to update the 'x'\nproperty of the first trace to the list [1, 2, 3]\n>>> import plotly.graph_objects as go\n>>> fig = go.Figure(go.Scatter(x=[2, 4, 6]))\n>>> fig.plotly_restyle({'x': [[1, 2, 3]]}, 0)\ntrace_indexes : int or list of int\nTrace index, or list of trace indexes, that the restyle operation\napplies to. Defaults to all trace indexes.\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "restyle_data": {
          "type": "object",
          "description": "类型从参数名推断: restyle_data"
        },
        "trace_indexes": {
          "type": "integer",
          "description": "类型从参数名推断: trace_indexes"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "restyle_data",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.plotly_restyle",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.plotly_update": {
    "name": "plotly_missing_ipywidgets_FigureWidget_plotly_update",
    "description": "Perform a Plotly update operation on the figure.\n\nNote: This operation both mutates and returns the figure\n\nParameters\n----------\nrestyle_data : dict\nTraces update specification. See the docstring for the\n`plotly_restyle` method for details\nrelayout_data : dict\nLayout update specification. See the docstring for the\n`plotly_relayout` method for details\ntrace_indexes :\nTrace index, or list of trace indexes, that the update operation\napplies to. Defaults to all trace indexes.\n\nReturns\n-------\nBaseFigure\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "restyle_data": {
          "type": "object",
          "description": "类型从参数名推断: restyle_data"
        },
        "relayout_data": {
          "type": "object",
          "description": "类型从参数名推断: relayout_data"
        },
        "trace_indexes": {
          "type": "integer",
          "description": "类型从参数名推断: trace_indexes"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.plotly_update",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.pop": {
    "name": "plotly_missing_ipywidgets_FigureWidget_pop",
    "description": "Remove the value associated with the specified key and return it\nParameters\n----------\nkey: str\nProperty name\ndflt\nThe default value to return if key was not found in figure\nReturns\n-------\nvalue\nThe removed value that was previously associated with key\nRaises\n------\nKeyError\nIf key is not in object and no dflt argument specified",
    "inputSchema": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "key",
        "args"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.pop",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.print_grid": {
    "name": "plotly_missing_ipywidgets_FigureWidget_print_grid",
    "description": "Print a visual layout of the figure's axes arrangement.\nThis is only valid for figures that are created\nwith plotly.tools.make_subplots.",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.print_grid",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.select_traces": {
    "name": "plotly_missing_ipywidgets_FigureWidget_select_traces",
    "description": "Select traces from a particular subplot cell and/or traces\nthat satisfy custom selection criteria.\nParameters\n----------\nselector: dict, function, int, str or None (default None)\nDict to use as selection criteria.\nTraces will be selected if they contain properties corresponding\nto all of the dictionary's keys, with values that exactly match\nthe supplied values. If None (the default), all traces are\nselected. If a function, it must be a function accepting a single\nargument and returning a boolean. The function will be called on\neach trace and those for which the function returned True\nwill be in the selection. If an int N, the Nth trace matching row\nand col will be selected (N can be negative). If a string S, the selector\nis equivalent to dict(type=S).\nrow, col: int or None (default None)\nSubplot row and column index of traces to select.\nTo select traces by row and column, the Figure must have been\ncreated using plotly.subplots.make_subplots.  If None\n(the default), all traces are selected.\nsecondary_y: boolean or None (default None)\n* If True, only select traces associated with the secondary\ny-axis of the subplot.\n* If False, only select traces associated with the primary\ny-axis of the subplot.\n* If None (the default), do not filter traces based on secondary\ny-axis.\nTo select traces by secondary y-axis, the Figure must have been\ncreated using plotly.subplots.make_subplots. See the docstring\nfor the specs argument to make_subplots for more info on\ncreating subplots with secondary y-axes.\nReturns\n-------\ngenerator\nGenerator that iterates through all of the traces that satisfy\nall of the specified selection criteria",
    "inputSchema": {
      "type": "object",
      "properties": {
        "selector": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.select_traces",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.set_subplots": {
    "name": "plotly_missing_ipywidgets_FigureWidget_set_subplots",
    "description": "Add subplots to this figure. If the figure already contains subplots,\nthen this throws an error. Accepts any keyword arguments that\nplotly.subplots.make_subplots accepts.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "rows": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "cols": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "make_subplots_args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "make_subplots_args"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.set_subplots",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.show": {
    "name": "plotly_missing_ipywidgets_FigureWidget_show",
    "description": "Show a figure using either the default renderer(s) or the renderer(s)\nspecified by the renderer argument\nParameters\n----------\nrenderer: str or None (default None)\nA string containing the names of one or more registered renderers\n(separated by '+' characters) or None.  If None, then the default\nrenderers specified in plotly.io.renderers.default are used.\nvalidate: bool (default True)\nTrue if the figure should be validated before being shown,\nFalse otherwise.\nwidth: int or float\nAn integer or float that determines the number of pixels wide the\nplot is. The default is set in plotly.js.\nheight: int or float\nAn integer or float that determines the number of pixels wide the\nplot is. The default is set in plotly.js.\nconfig: dict\nA dict of parameters to configure the figure. The defaults are set\nin plotly.js.\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.show",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.to_dict": {
    "name": "plotly_missing_ipywidgets_FigureWidget_to_dict",
    "description": "Convert figure to a dictionary\n\nNote: the dictionary includes the properties explicitly set by the\nuser, it does not include default values of unspecified properties\n\nReturns\n-------\ndict",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.to_dict",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.to_html": {
    "name": "plotly_missing_ipywidgets_FigureWidget_to_html",
    "description": "Convert a figure to an HTML string representation.\nParameters\n----------\nconfig: dict or None (default None)\nPlotly.js figure config options\nauto_play: bool (default=True)\nWhether to automatically start the animation sequence on page load\nif the figure contains frames. Has no effect if the figure does not\ncontain frames.\ninclude_plotlyjs: bool or string (default True)\nSpecifies how the plotly.js library is included/loaded in the output\ndiv string.\nIf True, a script tag containing the plotly.js source code (~3MB)\nis included in the output.  HTML files generated with this option are\nfully self-contained and can be used offline.\nIf 'cdn', a script tag that references the plotly.js CDN is included\nin the output. HTML files generated with this option are about 3MB\nsmaller than those generated with include_plotlyjs=True, but they\nrequire an active internet connection in order to load the plotly.js\nlibrary.\nIf 'directory', a script tag is included that references an external\nplotly.min.js bundle that is assumed to reside in the same\ndirectory as the HTML file.\nIf 'require', Plotly.js is loaded using require.js.  This option\nassumes that require.js is globally available and that it has been\nglobally configured to know how to find Plotly.js as 'plotly'.\nThis option is not advised when full_html=True as it will result\nin a non-functional html file.\nIf a string that ends in '.js', a script tag is included that\nreferences the specified path. This approach can be used to point\nthe resulting HTML file to an alternative CDN or local bundle.\nIf False, no script tag referencing plotly.js is included. This is\nuseful when the resulting div string will be placed inside an HTML\ndocument that already loads plotly.js. This option is not advised\nwhen full_html=True as it will result in a non-functional html file.\ninclude_mathjax: bool or string (default False)\nSpecifies how the MathJax.js library is included in the output html\ndiv string.  MathJax is required in order to display labels\nwith LaTeX typesetting.\nIf False, no script tag referencing MathJax.js will be included in the\noutput.\nIf 'cdn', a script tag that references a MathJax CDN location will be\nincluded in the output.  HTML div strings generated with this option\nwill be able to display LaTeX typesetting as long as internet access\nis available.\nIf a string that ends in '.js', a script tag is included that\nreferences the specified path. This approach can be used to point the\nresulting HTML div string to an alternative CDN.\npost_script: str or list or None (default None)\nJavaScript snippet(s) to be included in the resulting div just after\nplot creation.  The string(s) may include '{plot_id}' placeholders\nthat will then be replaced by the `id` of the div element that the\nplotly.js figure is associated with.  One application for this script\nis to install custom plotly.js event handlers.\nfull_html: bool (default True)\nIf True, produce a string containing a complete HTML document\nstarting with an <html> tag.  If False, produce a string containing\na single <div> element.\nanimation_opts: dict or None (default None)\ndict of custom animation parameters to be passed to the function\nPlotly.animate in Plotly.js. See\nhttps://github.com/plotly/plotly.js/blob/master/src/plots/animation_attributes.js\nfor available options. Has no effect if the figure does not contain\nframes, or auto_play is False.\ndefault_width, default_height: number or str (default '100%')\nThe default figure width/height to use if the provided figure does not\nspecify its own layout.width/layout.height property.  May be\nspecified in pixels as an integer (e.g. 500), or as a css width style\nstring (e.g. '500px', '100%').\nvalidate: bool (default True)\nTrue if the figure should be validated before being converted to\nJSON, False otherwise.\ndiv_id: str (default None)\nIf provided, this is the value of the id attribute of the div tag. If None, the\nid attribute is a UUID.\nReturns\n-------\nstr\nRepresentation of figure as an HTML div string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.to_html",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.to_image": {
    "name": "plotly_missing_ipywidgets_FigureWidget_to_image",
    "description": "Convert a figure to a static image bytes string\nParameters\n----------\nformat: str or None\nThe desired image format. One of\n- 'png'\n- 'jpg' or 'jpeg'\n- 'webp'\n- 'svg'\n- 'pdf'\n- 'eps' (Requires the poppler library to be installed)\nIf not specified, will default to `plotly.io.config.default_format`\nwidth: int or None\nThe width of the exported image in layout pixels. If the `scale`\nproperty is 1.0, this will also be the width of the exported image\nin physical pixels.\nIf not specified, will default to `plotly.io.config.default_width`\nheight: int or None\nThe height of the exported image in layout pixels. If the `scale`\nproperty is 1.0, this will also be the height of the exported image\nin physical pixels.\nIf not specified, will default to `plotly.io.config.default_height`\nscale: int or float or None\nThe scale factor to use when exporting the figure. A scale factor\nlarger than 1.0 will increase the image resolution with respect\nto the figure's layout pixel dimensions. Whereas as scale factor of\nless than 1.0 will decrease the image resolution.\nIf not specified, will default to `plotly.io.config.default_scale`\nvalidate: bool\nTrue if the figure should be validated before being converted to\nan image, False otherwise.\nengine: str\nImage export engine to use:\n- \"kaleido\": Use Kaleido for image export\n- \"orca\": Use Orca for image export\n- \"auto\" (default): Use Kaleido if installed, otherwise use orca\nReturns\n-------\nbytes\nThe image data",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.to_image",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.to_json": {
    "name": "plotly_missing_ipywidgets_FigureWidget_to_json",
    "description": "Convert a figure to a JSON string representation\nParameters\n----------\nvalidate: bool (default True)\nTrue if the figure should be validated before being converted to\nJSON, False otherwise.\npretty: bool (default False)\nTrue if JSON representation should be pretty-printed, False if\nrepresentation should be as compact as possible.\nremove_uids: bool (default True)\nTrue if trace UIDs should be omitted from the JSON representation\nengine: str (default None)\nThe JSON encoding engine to use. One of:\n- \"json\" for an encoder based on the built-in Python json module\n- \"orjson\" for a fast encoder the requires the orjson package\nIf not specified, the default encoder is set to the current value of\nplotly.io.json.config.default_encoder.\nReturns\n-------\nstr\nRepresentation of figure as a JSON string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.to_json",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.to_ordered_dict": {
    "name": "plotly_missing_ipywidgets_FigureWidget_to_ordered_dict",
    "description": "执行to_ordered_dict操作（FigureWidget类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "skip_uid": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.to_ordered_dict",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.to_plotly_json": {
    "name": "plotly_missing_ipywidgets_FigureWidget_to_plotly_json",
    "description": "Convert figure to a JSON representation as a Python dict\n\nNote: May include some JSON-invalid data types, use the `PlotlyJSONEncoder` util\nor the `to_json` method to encode to a string.\n\nReturns\n-------\ndict",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.to_plotly_json",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.update": {
    "name": "plotly_missing_ipywidgets_FigureWidget_update",
    "description": "Update the properties of the figure with a dict and/or with\nkeyword arguments.\nThis recursively updates the structure of the figure\nobject with the values in the input dict / keyword arguments.\nParameters\n----------\ndict1 : dict\nDictionary of properties to be updated\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\nkwargs :\nKeyword/value pair of properties to be updated\nExamples\n--------\n>>> import plotly.graph_objs as go\n>>> fig = go.Figure(data=[{'y': [1, 2, 3]}])\n>>> fig.update(data=[{'y': [4, 5, 6]}]) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.to_plotly_json() # doctest: +SKIP\n{'data': [{'type': 'scatter',\n'uid': 'e86a7c7a-346a-11e8-8aa8-a0999b0c017b',\n'y': array([4, 5, 6], dtype=int32)}],\n'layout': {}}\n>>> fig = go.Figure(layout={'xaxis':\n...                         {'color': 'green',\n...                          'range': [0, 1]}})\n>>> fig.update({'layout': {'xaxis': {'color': 'pink'}}}) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.to_plotly_json() # doctest: +SKIP\n{'data': [],\n'layout': {'xaxis':\n{'color': 'pink',\n'range': [0, 1]}}}\nReturns\n-------\nBaseFigure\nUpdated figure",
    "inputSchema": {
      "type": "object",
      "properties": {
        "dict1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.update",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.update_layout": {
    "name": "plotly_missing_ipywidgets_FigureWidget_update_layout",
    "description": "Update the properties of the figure's layout with a dict and/or with\nkeyword arguments.\nThis recursively updates the structure of the original\nlayout with the values in the input dict / keyword arguments.\nParameters\n----------\ndict1 : dict\nDictionary of properties to be updated\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\nkwargs :\nKeyword/value pair of properties to be updated\nReturns\n-------\nBaseFigure\nThe Figure object that the update_layout method was called on",
    "inputSchema": {
      "type": "object",
      "properties": {
        "dict1": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.update_layout",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.update_traces": {
    "name": "plotly_missing_ipywidgets_FigureWidget_update_traces",
    "description": "Perform a property update operation on all traces that satisfy the\nspecified selection criteria\nParameters\n----------\npatch: dict or None (default None)\nDictionary of property updates to be applied to all traces that\nsatisfy the selection criteria.\nselector: dict, function, int, str or None (default None)\nDict to use as selection criteria.\nTraces will be selected if they contain properties corresponding\nto all of the dictionary's keys, with values that exactly match\nthe supplied values. If None (the default), all traces are\nselected. If a function, it must be a function accepting a single\nargument and returning a boolean. The function will be called on\neach trace and those for which the function returned True\nwill be in the selection. If an int N, the Nth trace matching row\nand col will be selected (N can be negative). If a string S, the selector\nis equivalent to dict(type=S).\nrow, col: int or None (default None)\nSubplot row and column index of traces to select.\nTo select traces by row and column, the Figure must have been\ncreated using plotly.subplots.make_subplots.  If None\n(the default), all traces are selected.\nsecondary_y: boolean or None (default None)\n* If True, only select traces associated with the secondary\ny-axis of the subplot.\n* If False, only select traces associated with the primary\ny-axis of the subplot.\n* If None (the default), do not filter traces based on secondary\ny-axis.\nTo select traces by secondary y-axis, the Figure must have been\ncreated using plotly.subplots.make_subplots. See the docstring\nfor the specs argument to make_subplots for more info on\ncreating subplots with secondary y-axes.\noverwrite: bool\nIf True, overwrite existing properties. If False, apply updates\nto existing properties recursively, preserving existing\nproperties that are not specified in the update operation.\n**kwargs\nAdditional property updates to apply to each selected trace. If\na property is specified in both patch and in **kwargs then the\none in **kwargs takes precedence.\nReturns\n-------\nself\nReturns the Figure object that the method was called on",
    "inputSchema": {
      "type": "object",
      "properties": {
        "patch": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "selector": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "row": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "col": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "secondary_y": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "overwrite": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.update_traces",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.write_html": {
    "name": "plotly_missing_ipywidgets_FigureWidget_write_html",
    "description": "Write a figure to an HTML file representation\nParameters\n----------\nfile: str or writeable\nA string representing a local file path or a writeable object\n(e.g. a pathlib.Path object or an open file descriptor)\nconfig: dict or None (default None)\nPlotly.js figure config options\nauto_play: bool (default=True)\nWhether to automatically start the animation sequence on page load\nif the figure contains frames. Has no effect if the figure does not\ncontain frames.\ninclude_plotlyjs: bool or string (default True)\nSpecifies how the plotly.js library is included/loaded in the output\ndiv string.\nIf True, a script tag containing the plotly.js source code (~3MB)\nis included in the output.  HTML files generated with this option are\nfully self-contained and can be used offline.\nIf 'cdn', a script tag that references the plotly.js CDN is included\nin the output. HTML files generated with this option are about 3MB\nsmaller than those generated with include_plotlyjs=True, but they\nrequire an active internet connection in order to load the plotly.js\nlibrary.\nIf 'directory', a script tag is included that references an external\nplotly.min.js bundle that is assumed to reside in the same\ndirectory as the HTML file. If `file` is a string to a local file path\nand `full_html` is True then\nIf 'directory', a script tag is included that references an external\nplotly.min.js bundle that is assumed to reside in the same\ndirectory as the HTML file.  If `file` is a string to a local file\npath and `full_html` is True, then the plotly.min.js bundle is copied\ninto the directory of the resulting HTML file. If a file named\nplotly.min.js already exists in the output directory then this file\nis left unmodified and no copy is performed. HTML files generated\nwith this option can be used offline, but they require a copy of\nthe plotly.min.js bundle in the same directory. This option is\nuseful when many figures will be saved as HTML files in the same\ndirectory because the plotly.js source code will be included only\nonce per output directory, rather than once per output file.\nIf 'require', Plotly.js is loaded using require.js.  This option\nassumes that require.js is globally available and that it has been\nglobally configured to know how to find Plotly.js as 'plotly'.\nThis option is not advised when full_html=True as it will result\nin a non-functional html file.\nIf a string that ends in '.js', a script tag is included that\nreferences the specified path. This approach can be used to point\nthe resulting HTML file to an alternative CDN or local bundle.\nIf False, no script tag referencing plotly.js is included. This is\nuseful when the resulting div string will be placed inside an HTML\ndocument that already loads plotly.js.  This option is not advised\nwhen full_html=True as it will result in a non-functional html file.\ninclude_mathjax: bool or string (default False)\nSpecifies how the MathJax.js library is included in the output html\ndiv string.  MathJax is required in order to display labels\nwith LaTeX typesetting.\nIf False, no script tag referencing MathJax.js will be included in the\noutput.\nIf 'cdn', a script tag that references a MathJax CDN location will be\nincluded in the output.  HTML div strings generated with this option\nwill be able to display LaTeX typesetting as long as internet access\nis available.\nIf a string that ends in '.js', a script tag is included that\nreferences the specified path. This approach can be used to point the\nresulting HTML div string to an alternative CDN.\npost_script: str or list or None (default None)\nJavaScript snippet(s) to be included in the resulting div just after\nplot creation.  The string(s) may include '{plot_id}' placeholders\nthat will then be replaced by the `id` of the div element that the\nplotly.js figure is associated with.  One application for this script\nis to install custom plotly.js event handlers.\nfull_html: bool (default True)\nIf True, produce a string containing a complete HTML document\nstarting with an <html> tag.  If False, produce a string containing\na single <div> element.\nanimation_opts: dict or None (default None)\ndict of custom animation parameters to be passed to the function\nPlotly.animate in Plotly.js. See\nhttps://github.com/plotly/plotly.js/blob/master/src/plots/animation_attributes.js\nfor available options. Has no effect if the figure does not contain\nframes, or auto_play is False.\ndefault_width, default_height: number or str (default '100%')\nThe default figure width/height to use if the provided figure does not\nspecify its own layout.width/layout.height property.  May be\nspecified in pixels as an integer (e.g. 500), or as a css width style\nstring (e.g. '500px', '100%').\nvalidate: bool (default True)\nTrue if the figure should be validated before being converted to\nJSON, False otherwise.\nauto_open: bool (default True)\nIf True, open the saved file in a web browser after saving.\nThis argument only applies if `full_html` is True.\ndiv_id: str (default None)\nIf provided, this is the value of the id attribute of the div tag. If None, the\nid attribute is a UUID.\nReturns\n-------\nstr\nRepresentation of figure as an HTML div string",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.write_html",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.write_image": {
    "name": "plotly_missing_ipywidgets_FigureWidget_write_image",
    "description": "Convert a figure to a static image and write it to a file or writeable\nobject\nParameters\n----------\nfile: str or writeable\nA string representing a local file path or a writeable object\n(e.g. a pathlib.Path object or an open file descriptor)\nformat: str or None\nThe desired image format. One of\n- 'png'\n- 'jpg' or 'jpeg'\n- 'webp'\n- 'svg'\n- 'pdf'\n- 'eps' (Requires the poppler library to be installed)\nIf not specified and `file` is a string then this will default to the\nfile extension. If not specified and `file` is not a string then this\nwill default to `plotly.io.config.default_format`\nwidth: int or None\nThe width of the exported image in layout pixels. If the `scale`\nproperty is 1.0, this will also be the width of the exported image\nin physical pixels.\nIf not specified, will default to `plotly.io.config.default_width`\nheight: int or None\nThe height of the exported image in layout pixels. If the `scale`\nproperty is 1.0, this will also be the height of the exported image\nin physical pixels.\nIf not specified, will default to `plotly.io.config.default_height`\nscale: int or float or None\nThe scale factor to use when exporting the figure. A scale factor\nlarger than 1.0 will increase the image resolution with respect\nto the figure's layout pixel dimensions. Whereas as scale factor of\nless than 1.0 will decrease the image resolution.\nIf not specified, will default to `plotly.io.config.default_scale`\nvalidate: bool\nTrue if the figure should be validated before being converted to\nan image, False otherwise.\nengine: str\nImage export engine to use:\n- \"kaleido\": Use Kaleido for image export\n- \"orca\": Use Orca for image export\n- \"auto\" (default): Use Kaleido if installed, otherwise use orca\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.write_image",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.missing_ipywidgets.FigureWidget.write_json": {
    "name": "plotly_missing_ipywidgets_FigureWidget_write_json",
    "description": "Convert a figure to JSON and write it to a file or writeable\nobject\nParameters\n----------\nfile: str or writeable\nA string representing a local file path or a writeable object\n(e.g. an open file descriptor)\npretty: bool (default False)\nTrue if JSON representation should be pretty-printed, False if\nrepresentation should be as compact as possible.\nremove_uids: bool (default True)\nTrue if trace UIDs should be omitted from the JSON representation\nengine: str (default None)\nThe JSON encoding engine to use. One of:\n- \"json\" for an encoder based on the built-in Python json module\n- \"orjson\" for a fast encoder the requires the orjson package\nIf not specified, the default encoder is set to the current value of\nplotly.io.json.config.default_encoder.\nReturns\n-------\nNone",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.missing_ipywidgets.FigureWidget.write_json",
      "module": "plotly.missing_ipywidgets",
      "class_name": "FigureWidget",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.offline.offline.build_save_image_post_script": {
    "name": "plotly_offline_offline_build_save_image_post_script",
    "description": "执行build_save_image_post_script操作（plotly.offline.offline模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "image": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "image_filename": {
          "type": "string",
          "description": "类型从参数名推断: image_filename"
        },
        "image_height": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "image_width": {
          "type": "integer",
          "description": "类型从参数名推断: image_width"
        },
        "caller": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "image",
        "image_filename",
        "image_height",
        "image_width",
        "caller"
      ]
    },
    "metadata": {
      "source_function": "plotly.offline.offline.build_save_image_post_script",
      "module": "plotly.offline.offline",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.offline.offline.download_plotlyjs": {
    "name": "plotly_offline_offline_download_plotlyjs",
    "description": "执行download_plotlyjs操作（plotly.offline.offline模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "download_url": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "download_url"
      ]
    },
    "metadata": {
      "source_function": "plotly.offline.offline.download_plotlyjs",
      "module": "plotly.offline.offline",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.offline.offline.enable_mpl_offline": {
    "name": "plotly_offline_offline_enable_mpl_offline",
    "description": "Convert mpl plots to locally hosted HTML documents.\nThis function should be used with the inline matplotlib backend\nthat ships with IPython that can be enabled with `%pylab inline`\nor `%matplotlib inline`. This works by adding an HTML formatter\nfor Figure objects; the existing SVG/PNG formatters will remain\nenabled.\n(idea taken from `mpld3._display.enable_notebook`)\nExample:\n```\nfrom plotly.offline import enable_mpl_offline\nimport matplotlib.pyplot as plt\nenable_mpl_offline()\nfig = plt.figure()\nx = [10, 15, 20, 25, 30]\ny = [100, 250, 200, 150, 300]\nplt.plot(x, y, \"o\")\nfig\n```",
    "inputSchema": {
      "type": "object",
      "properties": {
        "resize": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "strip_style": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "verbose": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "show_link": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "link_text": {
          "type": "string",
          "default": "Export to plot.ly",
          "description": "类型从默认值推断: str"
        },
        "validate": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.offline.offline.enable_mpl_offline",
      "module": "plotly.offline.offline",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.offline.offline.get_image_download_script": {
    "name": "plotly_offline_offline_get_image_download_script",
    "description": "This function will return a script that will download an image of a Plotly\nplot.\n\nKeyword Arguments:\ncaller ('plot', 'iplot') -- specifies which function made the call for the\ndownload script. If `iplot`, then an extra condition is added into the\ndownload script to ensure that download prompts aren't initiated on\npage reloads.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "caller": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "caller"
      ]
    },
    "metadata": {
      "source_function": "plotly.offline.offline.get_image_download_script",
      "module": "plotly.offline.offline",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.offline.offline.get_plotlyjs": {
    "name": "plotly_offline_offline_get_plotlyjs",
    "description": "Return the contents of the minified plotly.js library as a string.\nThis may be useful when building standalone HTML reports.\nReturns\n-------\nstr\nContents of the minified plotly.js library as a string\nExamples\n--------\nHere is an example of creating a standalone HTML report that contains\ntwo plotly figures, each in their own div.  The include_plotlyjs argument\nis set to False when creating the divs so that we don't include multiple\ncopies of the plotly.js library in the output.  Instead, a single copy\nof plotly.js is included in a script tag in the html head element.\n>>> import plotly.graph_objs as go\n>>> from plotly.offline import plot, get_plotlyjs\n>>> fig1 = go.Figure(data=[{'type': 'bar', 'y': [1, 3, 2]}],\n...                 layout={'height': 400})\n>>> fig2 = go.Figure(data=[{'type': 'scatter', 'y': [1, 3, 2]}],\n...                  layout={'height': 400})\n>>> div1 = plot(fig1, output_type='div', include_plotlyjs=False)\n>>> div2 = plot(fig2, output_type='div', include_plotlyjs=False)\n>>> html = '''\n... <html>\n...     <head>\n...         <script type=\"text/javascript\">{plotlyjs}</script>\n...     </head>\n...     <body>\n...        {div1}\n...        {div2}\n...     </body>\n... </html>\n... '''.format(plotlyjs=get_plotlyjs(), div1=div1, div2=div2)\n>>> with open('multi_plot.html', 'w') as f:\n...      f.write(html) # doctest: +SKIP",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.offline.offline.get_plotlyjs",
      "module": "plotly.offline.offline",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.offline.offline.get_plotlyjs_version": {
    "name": "plotly_offline_offline_get_plotlyjs_version",
    "description": "Returns the version of plotly.js that is bundled with plotly.py.\nReturns\n-------\nstr\nPlotly.js version string",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.offline.offline.get_plotlyjs_version",
      "module": "plotly.offline.offline",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.offline.offline.init_notebook_mode": {
    "name": "plotly_offline_offline_init_notebook_mode",
    "description": "Initialize plotly.js in the browser if it hasn't been loaded into the DOM\nyet. This is an idempotent method and can and should be called from any\noffline methods that require plotly.js to be loaded into the notebook dom.\nKeyword arguments:\nconnected (default=False) -- If True, the plotly.js library will be loaded\nfrom an online CDN. If False, the plotly.js library will be loaded locally\nfrom the plotly python package\nUse `connected=True` if you want your notebooks to have smaller file sizes.\nIn the case where `connected=False`, the entirety of the plotly.js library\nwill be loaded into the notebook, which will result in a file-size increase\nof a couple megabytes. Additionally, because the library will be downloaded\nfrom the web, you and your viewers must be connected to the internet to be\nable to view charts within this notebook.\nUse `connected=False` if you want you and your collaborators to be able to\ncreate and view these charts regardless of the availability of an internet\nconnection. This is the default option since it is the most predictable.\nNote that under this setting the library will be included inline inside\nyour notebook, resulting in much larger notebook sizes compared to the case\nwhere `connected=True`.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "connected": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": []
    },
    "metadata": {
      "source_function": "plotly.offline.offline.init_notebook_mode",
      "module": "plotly.offline.offline",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.offline.offline.iplot": {
    "name": "plotly_offline_offline_iplot",
    "description": "Draw plotly graphs inside an IPython or Jupyter notebook\nfigure_or_data -- a plotly.graph_objs.Figure or plotly.graph_objs.Data or\ndict or list that describes a Plotly graph.\nSee https://plot.ly/python/ for examples of\ngraph descriptions.\nKeyword arguments:\nshow_link (default=False) -- display a link in the bottom-right corner of\nof the chart that will export the chart to\nPlotly Cloud or Plotly Enterprise\nlink_text (default='Export to plot.ly') -- the text of export link\nvalidate (default=True) -- validate that all of the keys in the figure\nare valid? omit if your version of plotly.js\nhas become outdated with your version of\ngraph_reference.json or if you need to include\nextra, unnecessary keys in your figure.\nimage (default=None |'png' |'jpeg' |'svg' |'webp') -- This parameter sets\nthe format of the image to be downloaded, if we choose to download an\nimage. This parameter has a default value of None indicating that no\nimage should be downloaded. Please note: for higher resolution images\nand more export options, consider using plotly.io.write_image. See\nhttps://plot.ly/python/static-image-export/ for more details.\nfilename (default='plot') -- Sets the name of the file your image\nwill be saved to. The extension should not be included.\nimage_height (default=600) -- Specifies the height of the image in `px`.\nimage_width (default=800) -- Specifies the width of the image in `px`.\nconfig (default=None) -- Plot view options dictionary. Keyword arguments\n`show_link` and `link_text` set the associated options in this\ndictionary if it doesn't contain them already.\nauto_play (default=True) -- Whether to automatically start the animation\nsequence on page load, if the figure contains frames. Has no effect if\nthe figure does not contain frames.\nanimation_opts (default=None) -- Dict of custom animation parameters that\nare used for the automatically started animation on page load. This\ndict is passed to the function Plotly.animate in Plotly.js. See\nhttps://github.com/plotly/plotly.js/blob/master/src/plots/animation_attributes.js\nfor available options. Has no effect if the figure\ndoes not contain frames, or auto_play is False.\nExample:\n```\nfrom plotly.offline import init_notebook_mode, iplot\ninit_notebook_mode()\niplot([{'x': [1, 2, 3], 'y': [5, 2, 7]}])\n# We can also download an image of the plot by setting the image to the\nformat you want. e.g. `image='png'`\niplot([{'x': [1, 2, 3], 'y': [5, 2, 7]}], image='png')\n```\nanimation_opts Example:\n```\nfrom plotly.offline import iplot\nfigure = {'data': [{'x': [0, 1], 'y': [0, 1]}],\n'layout': {'xaxis': {'range': [0, 5], 'autorange': False},\n'yaxis': {'range': [0, 5], 'autorange': False},\n'title': 'Start Title'},\n'frames': [{'data': [{'x': [1, 2], 'y': [1, 2]}]},\n{'data': [{'x': [1, 4], 'y': [1, 4]}]},\n{'data': [{'x': [3, 4], 'y': [3, 4]}],\n'layout': {'title': 'End Title'}}]}\niplot(figure, animation_opts={'frame': {'duration': 1}})\n```",
    "inputSchema": {
      "type": "object",
      "properties": {
        "figure_or_data": {
          "type": "object",
          "description": "类型从参数名推断: figure_or_data"
        },
        "show_link": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "link_text": {
          "type": "string",
          "default": "Export to plot.ly",
          "description": "类型从默认值推断: str"
        },
        "validate": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "image": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "filename": {
          "type": "string",
          "default": "plot_image",
          "description": "类型从默认值推断: str"
        },
        "image_width": {
          "type": "integer",
          "default": 800,
          "description": "类型从默认值推断: int"
        },
        "image_height": {
          "type": "integer",
          "default": 600,
          "description": "类型从默认值推断: int"
        },
        "config": {
          "type": "object",
          "description": "类型从参数名推断: config"
        },
        "auto_play": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "animation_opts": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "figure_or_data"
      ]
    },
    "metadata": {
      "source_function": "plotly.offline.offline.iplot",
      "module": "plotly.offline.offline",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.offline.offline.iplot_mpl": {
    "name": "plotly_offline_offline_iplot_mpl",
    "description": "Convert a matplotlib figure to a plotly graph and plot inside an IPython\nnotebook without connecting to an external server.\nTo save the chart to Plotly Cloud or Plotly Enterprise, use\n`plotly.plotly.plot_mpl`.\nFor more information on converting matplotlib visualizations to plotly\ngraphs call `help(plotly.tools.mpl_to_plotly)`\nFor more information on plotting plotly charts offline in an Ipython\nnotebook call `help(plotly.offline.iplot)`\nmpl_fig -- a matplotlib.figure to convert to a plotly graph\nKeyword arguments:\nresize (default=False) -- allow plotly to choose the figure size.\nstrip_style (default=False) -- allow plotly to choose style options.\nverbose (default=False) -- print message.\nshow_link (default=False) -- display a link in the bottom-right corner of\nof the chart that will export the chart to\nPlotly Cloud or Plotly Enterprise\nlink_text (default='Export to plot.ly') -- the text of export link\nvalidate (default=True) -- validate that all of the keys in the figure\nare valid? omit if your version of plotly.js\nhas become outdated with your version of\ngraph_reference.json or if you need to include\nextra, unnecessary keys in your figure.\nimage (default=None |'png' |'jpeg' |'svg' |'webp') -- This parameter sets\nthe format of the image to be downloaded, if we choose to download an\nimage. This parameter has a default value of None indicating that no\nimage should be downloaded.\nimage_filename (default='plot_image') -- Sets the name of the file your\nimage will be saved to. The extension should not be included.\nimage_height (default=600) -- Specifies the height of the image in `px`.\nimage_width (default=800) -- Specifies the width of the image in `px`.\nExample:\n```\nfrom plotly.offline import init_notebook_mode, iplot_mpl\nimport matplotlib.pyplot as plt\nfig = plt.figure()\nx = [10, 15, 20, 25, 30]\ny = [100, 250, 200, 150, 300]\nplt.plot(x, y, \"o\")\ninit_notebook_mode()\niplot_mpl(fig)\n# and if you want to download an image of the figure as well\niplot_mpl(fig, image='jpeg')\n```",
    "inputSchema": {
      "type": "object",
      "properties": {
        "mpl_fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "resize": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "strip_style": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "verbose": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "show_link": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "link_text": {
          "type": "string",
          "default": "Export to plot.ly",
          "description": "类型从默认值推断: str"
        },
        "validate": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "image": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "image_filename": {
          "type": "string",
          "default": "plot_image",
          "description": "类型从默认值推断: str"
        },
        "image_height": {
          "type": "integer",
          "default": 600,
          "description": "类型从默认值推断: int"
        },
        "image_width": {
          "type": "integer",
          "default": 800,
          "description": "类型从默认值推断: int"
        }
      },
      "required": [
        "mpl_fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.offline.offline.iplot_mpl",
      "module": "plotly.offline.offline",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.offline.offline.plot": {
    "name": "plotly_offline_offline_plot",
    "description": "Create a plotly graph locally as an HTML document or string.\nExample:\n```\nfrom plotly.offline import plot\nimport plotly.graph_objs as go\nplot([go.Scatter(x=[1, 2, 3], y=[3, 2, 6])], filename='my-graph.html')\n# We can also download an image of the plot by setting the image parameter\n# to the image format we want\nplot([go.Scatter(x=[1, 2, 3], y=[3, 2, 6])], filename='my-graph.html',\nimage='jpeg')\n```\nMore examples below.\nfigure_or_data -- a plotly.graph_objs.Figure or plotly.graph_objs.Data or\ndict or list that describes a Plotly graph.\nSee https://plot.ly/python/ for examples of\ngraph descriptions.\nKeyword arguments:\nshow_link (default=False) -- display a link in the bottom-right corner of\nof the chart that will export the chart to Plotly Cloud or\nPlotly Enterprise\nlink_text (default='Export to plot.ly') -- the text of export link\nvalidate (default=True) -- validate that all of the keys in the figure\nare valid? omit if your version of plotly.js has become outdated\nwith your version of graph_reference.json or if you need to include\nextra, unnecessary keys in your figure.\noutput_type ('file' | 'div' - default 'file') -- if 'file', then\nthe graph is saved as a standalone HTML file and `plot`\nreturns None.\nIf 'div', then `plot` returns a string that just contains the\nHTML <div> that contains the graph and the script to generate the\ngraph.\nUse 'file' if you want to save and view a single graph at a time\nin a standalone HTML file.\nUse 'div' if you are embedding these graphs in an HTML file with\nother graphs or HTML markup, like a HTML report or an website.\ninclude_plotlyjs (True | False | 'cdn' | 'directory' | path - default=True)\nSpecifies how the plotly.js library is included in the output html\nfile or div string.\nIf True, a script tag containing the plotly.js source code (~3MB)\nis included in the output.  HTML files generated with this option are\nfully self-contained and can be used offline.\nIf 'cdn', a script tag that references the plotly.js CDN is included\nin the output. HTML files generated with this option are about 3MB\nsmaller than those generated with include_plotlyjs=True, but they\nrequire an active internet connection in order to load the plotly.js\nlibrary.\nIf 'directory', a script tag is included that references an external\nplotly.min.js bundle that is assumed to reside in the same\ndirectory as the HTML file.  If output_type='file' then the\nplotly.min.js bundle is copied into the directory of the resulting\nHTML file. If a file named plotly.min.js already exists in the output\ndirectory then this file is left unmodified and no copy is performed.\nHTML files generated with this option can be used offline, but they\nrequire a copy of the plotly.min.js bundle in the same directory.\nThis option is useful when many figures will be saved as HTML files in\nthe same directory because the plotly.js source code will be included\nonly once per output directory, rather than once per output file.\nIf a string that ends in '.js', a script tag is included that\nreferences the specified path. This approach can be used to point\nthe resulting HTML file to an alternative CDN.\nIf False, no script tag referencing plotly.js is included. This is\nuseful when output_type='div' and the resulting div string will be\nplaced inside an HTML document that already loads plotly.js.  This\noption is not advised when output_type='file' as it will result in\na non-functional html file.\nfilename (default='temp-plot.html') -- The local filename to save the\noutputted chart to. If the filename already exists, it will be\noverwritten. This argument only applies if `output_type` is 'file'.\nauto_open (default=True) -- If True, open the saved file in a\nweb browser after saving.\nThis argument only applies if `output_type` is 'file'.\nimage (default=None |'png' |'jpeg' |'svg' |'webp') -- This parameter sets\nthe format of the image to be downloaded, if we choose to download an\nimage. This parameter has a default value of None indicating that no\nimage should be downloaded. Please note: for higher resolution images\nand more export options, consider making requests to our image servers.\nType: `help(py.image)` for more details.\nimage_filename (default='plot_image') -- Sets the name of the file your\nimage will be saved to. The extension should not be included.\nimage_height (default=600) -- Specifies the height of the image in `px`.\nimage_width (default=800) -- Specifies the width of the image in `px`.\nconfig (default=None) -- Plot view options dictionary. Keyword arguments\n`show_link` and `link_text` set the associated options in this\ndictionary if it doesn't contain them already.\ninclude_mathjax (False | 'cdn' | path - default=False) --\nSpecifies how the MathJax.js library is included in the output html\nfile or div string.  MathJax is required in order to display labels\nwith LaTeX typesetting.\nIf False, no script tag referencing MathJax.js will be included in the\noutput. HTML files generated with this option will not be able to\ndisplay LaTeX typesetting.\nIf 'cdn', a script tag that references a MathJax CDN location will be\nincluded in the output.  HTML files generated with this option will be\nable to display LaTeX typesetting as long as they have internet access.\nIf a string that ends in '.js', a script tag is included that\nreferences the specified path. This approach can be used to point the\nresulting HTML file to an alternative CDN.\nauto_play (default=True) -- Whether to automatically start the animation\nsequence on page load if the figure contains frames. Has no effect if\nthe figure does not contain frames.\nanimation_opts (default=None) -- Dict of custom animation parameters that\nare used for the automatically started animation on page load. This\ndict is passed to the function Plotly.animate in Plotly.js. See\nhttps://github.com/plotly/plotly.js/blob/master/src/plots/animation_attributes.js\nfor available options. Has no effect if the figure\ndoes not contain frames, or auto_play is False.\nExample:\n```\nfrom plotly.offline import plot\nfigure = {'data': [{'x': [0, 1], 'y': [0, 1]}],\n'layout': {'xaxis': {'range': [0, 5], 'autorange': False},\n'yaxis': {'range': [0, 5], 'autorange': False},\n'title': 'Start Title'},\n'frames': [{'data': [{'x': [1, 2], 'y': [1, 2]}]},\n{'data': [{'x': [1, 4], 'y': [1, 4]}]},\n{'data': [{'x': [3, 4], 'y': [3, 4]}],\n'layout': {'title': 'End Title'}}]}\nplot(figure, animation_opts={'frame': {'duration': 1}})\n```",
    "inputSchema": {
      "type": "object",
      "properties": {
        "figure_or_data": {
          "type": "object",
          "description": "类型从参数名推断: figure_or_data"
        },
        "show_link": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "link_text": {
          "type": "string",
          "default": "Export to plot.ly",
          "description": "类型从默认值推断: str"
        },
        "validate": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "output_type": {
          "type": "string",
          "default": "file",
          "description": "类型从默认值推断: str"
        },
        "include_plotlyjs": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "filename": {
          "type": "string",
          "default": "temp-plot.html",
          "description": "类型从默认值推断: str"
        },
        "auto_open": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "image": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "image_filename": {
          "type": "string",
          "default": "plot_image",
          "description": "类型从默认值推断: str"
        },
        "image_width": {
          "type": "integer",
          "default": 800,
          "description": "类型从默认值推断: int"
        },
        "image_height": {
          "type": "integer",
          "default": 600,
          "description": "类型从默认值推断: int"
        },
        "config": {
          "type": "object",
          "description": "类型从参数名推断: config"
        },
        "include_mathjax": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "auto_play": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "animation_opts": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "figure_or_data"
      ]
    },
    "metadata": {
      "source_function": "plotly.offline.offline.plot",
      "module": "plotly.offline.offline",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.offline.offline.plot_mpl": {
    "name": "plotly_offline_offline_plot_mpl",
    "description": "Convert a matplotlib figure to a Plotly graph stored locally as HTML.\nFor more information on converting matplotlib visualizations to plotly\ngraphs, call help(plotly.tools.mpl_to_plotly)\nFor more information on creating plotly charts locally as an HTML document\nor string, call help(plotly.offline.plot)\nmpl_fig -- a matplotlib figure object to convert to a plotly graph\nKeyword arguments:\nresize (default=False) -- allow plotly to choose the figure size.\nstrip_style (default=False) -- allow plotly to choose style options.\nverbose (default=False) -- print message.\nshow_link (default=False) -- display a link in the bottom-right corner of\nof the chart that will export the chart to Plotly Cloud or\nPlotly Enterprise\nlink_text (default='Export to plot.ly') -- the text of export link\nvalidate (default=True) -- validate that all of the keys in the figure\nare valid? omit if your version of plotly.js has become outdated\nwith your version of graph_reference.json or if you need to include\nextra, unnecessary keys in your figure.\noutput_type ('file' | 'div' - default 'file') -- if 'file', then\nthe graph is saved as a standalone HTML file and `plot`\nreturns None.\nIf 'div', then `plot` returns a string that just contains the\nHTML <div> that contains the graph and the script to generate the\ngraph.\nUse 'file' if you want to save and view a single graph at a time\nin a standalone HTML file.\nUse 'div' if you are embedding these graphs in an HTML file with\nother graphs or HTML markup, like a HTML report or an website.\ninclude_plotlyjs (default=True) -- If True, include the plotly.js\nsource code in the output file or string.\nSet as False if your HTML file already contains a copy of the plotly.js\nlibrary.\nfilename (default='temp-plot.html') -- The local filename to save the\noutputted chart to. If the filename already exists, it will be\noverwritten. This argument only applies if `output_type` is 'file'.\nauto_open (default=True) -- If True, open the saved file in a\nweb browser after saving.\nThis argument only applies if `output_type` is 'file'.\nimage (default=None |'png' |'jpeg' |'svg' |'webp') -- This parameter sets\nthe format of the image to be downloaded, if we choose to download an\nimage. This parameter has a default value of None indicating that no\nimage should be downloaded.\nimage_filename (default='plot_image') -- Sets the name of the file your\nimage will be saved to. The extension should not be included.\nimage_height (default=600) -- Specifies the height of the image in `px`.\nimage_width (default=800) -- Specifies the width of the image in `px`.\nExample:\n```\nfrom plotly.offline import init_notebook_mode, plot_mpl\nimport matplotlib.pyplot as plt\ninit_notebook_mode()\nfig = plt.figure()\nx = [10, 15, 20, 25, 30]\ny = [100, 250, 200, 150, 300]\nplt.plot(x, y, \"o\")\nplot_mpl(fig)\n# If you want to to download an image of the figure as well\nplot_mpl(fig, image='png')\n```",
    "inputSchema": {
      "type": "object",
      "properties": {
        "mpl_fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "resize": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "strip_style": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "verbose": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "show_link": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "link_text": {
          "type": "string",
          "default": "Export to plot.ly",
          "description": "类型从默认值推断: str"
        },
        "validate": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "output_type": {
          "type": "string",
          "default": "file",
          "description": "类型从默认值推断: str"
        },
        "include_plotlyjs": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "filename": {
          "type": "string",
          "default": "temp-plot.html",
          "description": "类型从默认值推断: str"
        },
        "auto_open": {
          "type": "integer",
          "default": true,
          "description": "类型从默认值推断: bool"
        },
        "image": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "image_filename": {
          "type": "string",
          "default": "plot_image",
          "description": "类型从默认值推断: str"
        },
        "image_height": {
          "type": "integer",
          "default": 600,
          "description": "类型从默认值推断: int"
        },
        "image_width": {
          "type": "integer",
          "default": 800,
          "description": "类型从默认值推断: int"
        }
      },
      "required": [
        "mpl_fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.offline.offline.plot_mpl",
      "module": "plotly.offline.offline",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.shapeannotation.annotation_params_for_line": {
    "name": "plotly_shapeannotation_annotation_params_for_line",
    "description": "执行annotation_params_for_line操作（plotly.shapeannotation模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "shape_type": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "shape_args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "position": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "shape_type",
        "shape_args",
        "position"
      ]
    },
    "metadata": {
      "source_function": "plotly.shapeannotation.annotation_params_for_line",
      "module": "plotly.shapeannotation",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.shapeannotation.annotation_params_for_rect": {
    "name": "plotly_shapeannotation_annotation_params_for_rect",
    "description": "执行annotation_params_for_rect操作（plotly.shapeannotation模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "shape_type": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "shape_args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "position": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "shape_type",
        "shape_args",
        "position"
      ]
    },
    "metadata": {
      "source_function": "plotly.shapeannotation.annotation_params_for_rect",
      "module": "plotly.shapeannotation",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.shapeannotation.axis_spanning_shape_annotation": {
    "name": "plotly_shapeannotation_axis_spanning_shape_annotation",
    "description": "annotation: a go.layout.Annotation object, a dict describing an annotation, or None\nshape_type: one of 'vline', 'hline', 'vrect', 'hrect' and determines how the\nx, y, xanchor, and yanchor values are set.\nshape_args: the parameters used to draw the shape, which are used to place the annotation\nkwargs:     a dictionary that was the kwargs of a\n_process_multiple_axis_spanning_shapes spanning shapes call. Items in this\ndict whose keys start with 'annotation_' will be extracted and the keys with\nthe 'annotation_' part stripped off will be used to assign properties of the\nnew annotation.\nProperty precedence:\nThe annotation's x, y, xanchor, and yanchor properties are set based on the\nshape_type argument. Each property already specified in the annotation or\nthrough kwargs will be left as is (not replaced by the value computed using\nshape_type). Note that the xref and yref properties will in general get\noverwritten if the result of this function is passed to an add_annotation\ncalled with the row and col parameters specified.\nReturns an annotation populated with fields based on the\nannotation_position, annotation_ prefixed kwargs or the original annotation\npassed in to this function.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "annotation": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "shape_type": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "shape_args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "annotation",
        "shape_type",
        "shape_args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.shapeannotation.axis_spanning_shape_annotation",
      "module": "plotly.shapeannotation",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.shapeannotation.split_dict_by_key_prefix": {
    "name": "plotly_shapeannotation_split_dict_by_key_prefix",
    "description": "Returns two dictionaries, one containing all the items whose keys do not\nstart with a prefix and another containing all the items whose keys do start\nwith the prefix. Note that the prefix is not removed from the keys.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "d": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "prefix": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "d",
        "prefix"
      ]
    },
    "metadata": {
      "source_function": "plotly.shapeannotation.split_dict_by_key_prefix",
      "module": "plotly.shapeannotation",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.subplots.make_subplots": {
    "name": "plotly_subplots_make_subplots",
    "description": "Return an instance of plotly.graph_objs.Figure with predefined subplots\nconfigured in 'layout'.\n\nParameters\n----------\nrows: int (default 1)\nNumber of rows in the subplot grid. Must be greater than zero.\n\ncols: int (default 1)\nNumber of columns in the subplot grid. Must be greater than zero.\n\nshared_xaxes: boolean or str (default False)\nAssign shared (linked) x-axes for 2D cartesian subplots\n\n- True or 'columns': Share axes among subplots in the same column\n- 'rows': Share axes among subplots in the same row\n- 'all': Share axes across all subplots in the grid.\n\nshared_yaxes: boolean or str (default False)\nAssign shared (linked) y-axes for 2D cartesian subplots\n\n- 'columns': Share axes among subplots in the same column\n- True or 'rows': Share axes among subplots in the same row\n- 'all': Share axes across all subplots in the grid.\n\nstart_cell: 'bottom-left' or 'top-left' (default 'top-left')\nChoose the starting cell in the subplot grid used to set the\ndomains_grid of the subplots.\n\n- 'top-left': Subplots are numbered with (1, 1) in the top\nleft corner\n- 'bottom-left': Subplots are numbererd with (1, 1) in the bottom\nleft corner\n\nprint_grid: boolean (default True):\nIf True, prints a string representation of the plot grid.  Grid may\nalso be printed using the `Figure.print_grid()` method on the\nresulting figure.\n\nhorizontal_spacing: float (default 0.2 / cols)\nSpace between subplot columns in normalized plot coordinates. Must be\na float between 0 and 1.\n\nApplies to all columns (use 'specs' subplot-dependents spacing)\n\nvertical_spacing: float (default 0.3 / rows)\nSpace between subplot rows in normalized plot coordinates. Must be\na float between 0 and 1.\n\nApplies to all rows (use 'specs' subplot-dependents spacing)\n\nsubplot_titles: list of str or None (default None)\nTitle of each subplot as a list in row-major ordering.\n\nEmpty strings (\"\") can be included in the list if no subplot title\nis desired in that space so that the titles are properly indexed.\n\nspecs: list of lists of dict or None (default None)\nPer subplot specifications of subplot type, row/column spanning, and\nspacing.\n\nex1: specs=[[{}, {}], [{'colspan': 2}, None]]\n\nex2: specs=[[{'rowspan': 2}, {}], [None, {}]]\n\n- Indices of the outer list correspond to subplot grid rows\nstarting from the top, if start_cell='top-left',\nor bottom, if start_cell='bottom-left'.\nThe number of rows in 'specs' must be equal to 'rows'.\n\n- Indices of the inner lists correspond to subplot grid columns\nstarting from the left. The number of columns in 'specs'\nmust be equal to 'cols'.\n\n- Each item in the 'specs' list corresponds to one subplot\nin a subplot grid. (N.B. The subplot grid has exactly 'rows'\ntimes 'cols' cells.)\n\n- Use None for a blank a subplot cell (or to move past a col/row span).\n\n- Note that specs[0][0] has the specs of the 'start_cell' subplot.\n\n- Each item in 'specs' is a dictionary.\nThe available keys are:\n* type (string, default 'xy'): Subplot type. One of\n- 'xy': 2D Cartesian subplot type for scatter, bar, etc.\n- 'scene': 3D Cartesian subplot for scatter3d, cone, etc.\n- 'polar': Polar subplot for scatterpolar, barpolar, etc.\n- 'ternary': Ternary subplot for scatterternary\n- 'mapbox': Mapbox subplot for scattermapbox\n- 'domain': Subplot type for traces that are individually\npositioned. pie, parcoords, parcats, etc.\n- trace type: A trace type which will be used to determine\nthe appropriate subplot type for that trace\n\n* secondary_y (bool, default False): If True, create a secondary\ny-axis positioned on the right side of the subplot. Only valid\nif type='xy'.\n* colspan (int, default 1): number of subplot columns\nfor this subplot to span.\n* rowspan (int, default 1): number of subplot rows\nfor this subplot to span.\n* l (float, default 0.0): padding left of cell\n* r (float, default 0.0): padding right of cell\n* t (float, default 0.0): padding right of cell\n* b (float, default 0.0): padding bottom of cell\n\n- Note: Use 'horizontal_spacing' and 'vertical_spacing' to adjust\nthe spacing in between the subplots.\n\ninsets: list of dict or None (default None):\nInset specifications.  Insets are subplots that overlay grid subplots\n\n- Each item in 'insets' is a dictionary.\nThe available keys are:\n\n* cell (tuple, default=(1,1)): (row, col) index of the\nsubplot cell to overlay inset axes onto.\n* type (string, default 'xy'): Subplot type\n* l (float, default=0.0): padding left of inset\nin fraction of cell width\n* w (float or 'to_end', default='to_end') inset width\nin fraction of cell width ('to_end': to cell right edge)\n* b (float, default=0.0): padding bottom of inset\nin fraction of cell height\n* h (float or 'to_end', default='to_end') inset height\nin fraction of cell height ('to_end': to cell top edge)\n\ncolumn_widths: list of numbers or None (default None)\nlist of length `cols` of the relative widths of each column of subplots.\nValues are normalized internally and used to distribute overall width\nof the figure (excluding padding) among the columns.\n\nFor backward compatibility, may also be specified using the\n`column_width` keyword argument.\n\nrow_heights: list of numbers or None (default None)\nlist of length `rows` of the relative heights of each row of subplots.\nIf start_cell='top-left' then row heights are applied top to bottom.\nOtherwise, if start_cell='bottom-left' then row heights are applied\nbottom to top.\n\nFor backward compatibility, may also be specified using the\n`row_width` kwarg. If specified as `row_width`, then the width values\nare applied from bottom to top regardless of the value of start_cell.\nThis matches the legacy behavior of the `row_width` argument.\n\ncolumn_titles: list of str or None (default None)\nlist of length `cols` of titles to place above the top subplot in\neach column.\n\nrow_titles: list of str or None (default None)\nlist of length `rows` of titles to place on the right side of each\nrow of subplots. If start_cell='top-left' then row titles are\napplied top to bottom. Otherwise, if start_cell='bottom-left' then\nrow titles are applied bottom to top.\n\nx_title: str or None (default None)\nTitle to place below the bottom row of subplots,\ncentered horizontally\n\ny_title: str or None (default None)\nTitle to place to the left of the left column of subplots,\ncentered vertically\n\nfigure: go.Figure or None (default None)\nIf None, a new go.Figure instance will be created and its axes will be\npopulated with those corresponding to the requested subplot geometry and\nthis new figure will be returned.\nIf a go.Figure instance, the axes will be added to the\nlayout of this figure and this figure will be returned. If the figure\nalready contains axes, they will be overwritten.\n\nExamples\n--------\n\nExample 1:\n\n>>> # Stack two subplots vertically, and add a scatter trace to each\n>>> from plotly.subplots import make_subplots\n>>> import plotly.graph_objects as go\n>>> fig = make_subplots(rows=2)\n\nThis is the format of your plot grid:\n[ (1,1) xaxis1,yaxis1 ]\n[ (2,1) xaxis2,yaxis2 ]\n\n>>> fig.add_scatter(y=[2, 1, 3], row=1, col=1) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.add_scatter(y=[1, 3, 2], row=2, col=1) # doctest: +ELLIPSIS\nFigure(...)\n\nor see Figure.append_trace\n\nExample 2:\n\n>>> # Stack a scatter plot\n>>> fig = make_subplots(rows=2, shared_xaxes=True)\n\nThis is the format of your plot grid:\n[ (1,1) xaxis1,yaxis1 ]\n[ (2,1) xaxis2,yaxis2 ]\n\n>>> fig.add_scatter(y=[2, 1, 3], row=1, col=1) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.add_scatter(y=[1, 3, 2], row=2, col=1) # doctest: +ELLIPSIS\nFigure(...)\n\nExample 3:\n\n>>> # irregular subplot layout (more examples below under 'specs')\n>>> fig = make_subplots(rows=2, cols=2,\n...                     specs=[[{}, {}],\n...                     [{'colspan': 2}, None]])\n\nThis is the format of your plot grid:\n[ (1,1) xaxis1,yaxis1 ]  [ (1,2) xaxis2,yaxis2 ]\n[ (2,1) xaxis3,yaxis3           -              ]\n\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=1, col=1) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=1, col=2) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.add_trace(go.Scatter(x=[1,2,3], y=[2,1,2]), row=2, col=1) # doctest: +ELLIPSIS\nFigure(...)\n\nExample 4:\n\n>>> # insets\n>>> fig = make_subplots(insets=[{'cell': (1,1), 'l': 0.7, 'b': 0.3}])\n\nThis is the format of your plot grid:\n[ (1,1) xaxis1,yaxis1 ]\n\nWith insets:\n[ xaxis2,yaxis2 ] over [ (1,1) xaxis1,yaxis1 ]\n\n>>> fig.add_scatter(x=[1,2,3], y=[2,1,1]) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.add_scatter(x=[1,2,3], y=[2,1,2], xaxis='x2', yaxis='y2') # doctest: +ELLIPSIS\nFigure(...)\n\nExample 5:\n\n>>> # include subplot titles\n>>> fig = make_subplots(rows=2, subplot_titles=('Plot 1','Plot 2'))\n\nThis is the format of your plot grid:\n[ (1,1) x1,y1 ]\n[ (2,1) x2,y2 ]\n\n>>> fig.add_scatter(x=[1,2,3], y=[2,1,2], row=1, col=1) # doctest: +ELLIPSIS\nFigure(...)\n>>> fig.add_bar(x=[1,2,3], y=[2,1,2], row=2, col=1) # doctest: +ELLIPSIS\nFigure(...)\n\nExample 6:\n\nSubplot with mixed subplot types\n\n>>> fig = make_subplots(rows=2, cols=2,\n...                     specs=[[{'type': 'xy'},    {'type': 'polar'}],\n...                            [{'type': 'scene'}, {'type': 'ternary'}]])\n\n>>> fig.add_traces(\n...     [go.Scatter(y=[2, 3, 1]),\n...      go.Scatterpolar(r=[1, 3, 2], theta=[0, 45, 90]),\n...      go.Scatter3d(x=[1, 2, 1], y=[2, 3, 1], z=[0, 3, 5]),\n...      go.Scatterternary(a=[0.1, 0.2, 0.1],\n...                        b=[0.2, 0.3, 0.1],\n...                        c=[0.7, 0.5, 0.8])],\n...     rows=[1, 1, 2, 2],\n...     cols=[1, 2, 1, 2]) # doctest: +ELLIPSIS\nFigure(...)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "rows": {
          "type": "integer",
          "default": 1,
          "description": "类型从默认值推断: int"
        },
        "cols": {
          "type": "integer",
          "default": 1,
          "description": "类型从默认值推断: int"
        },
        "shared_xaxes": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "shared_yaxes": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "start_cell": {
          "type": "string",
          "default": "top-left",
          "description": "类型从默认值推断: str"
        },
        "print_grid": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "horizontal_spacing": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "vertical_spacing": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "subplot_titles": {
          "type": "string",
          "description": "类型从参数名推断: subplot_titles"
        },
        "column_widths": {
          "type": "integer",
          "description": "类型从参数名推断: column_widths"
        },
        "row_heights": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "specs": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "insets": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "column_titles": {
          "type": "string",
          "description": "类型从参数名推断: column_titles"
        },
        "row_titles": {
          "type": "string",
          "description": "类型从参数名推断: row_titles"
        },
        "x_title": {
          "type": "string",
          "description": "类型从参数名推断: x_title"
        },
        "y_title": {
          "type": "string",
          "description": "类型从参数名推断: y_title"
        },
        "figure": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.subplots.make_subplots",
      "module": "plotly.subplots",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    },
    "outputSchema": {
      "type": "object",
      "description": "自定义类型: Figure"
    }
  },
  "plotly.tools.get_config_plotly_server_url": {
    "name": "plotly_tools_get_config_plotly_server_url",
    "description": "Function to get the .config file's 'plotly_domain' without importing\nthe chart_studio package.  This property is needed to compute the default\nvalue of the plotly.js config plotlyServerURL, so it is independent of\nthe chart_studio integration and still needs to live in\nReturns\n-------\nstr",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.tools.get_config_plotly_server_url",
      "module": "plotly.tools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.tools.get_graph_obj": {
    "name": "plotly_tools_get_graph_obj",
    "description": "Returns a new graph object.\nOLD FUNCTION: this will *silently* strip out invalid pieces of the object.\nNEW FUNCTION: no striping of invalid pieces anymore - only raises error\non unrecognized graph_objs",
    "inputSchema": {
      "type": "object",
      "properties": {
        "obj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "obj_type": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "obj"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.get_graph_obj",
      "module": "plotly.tools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.tools.get_subplots": {
    "name": "plotly_tools_get_subplots",
    "description": "Return a dictionary instance with the subplots set in 'layout'.\nExample 1:\n# stack two subplots vertically\nfig = tools.get_subplots(rows=2)\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2], xaxis='x1', yaxis='y1')]\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2], xaxis='x2', yaxis='y2')]\nExample 2:\n# print out string showing the subplot grid you've put in the layout\nfig = tools.get_subplots(rows=3, columns=2, print_grid=True)\nKeywords arguments with constant defaults:\nrows (kwarg, int greater than 0, default=1):\nNumber of rows, evenly spaced vertically on the figure.\ncolumns (kwarg, int greater than 0, default=1):\nNumber of columns, evenly spaced horizontally on the figure.\nhorizontal_spacing (kwarg, float in [0,1], default=0.1):\nSpace between subplot columns. Applied to all columns.\nvertical_spacing (kwarg, float in [0,1], default=0.05):\nSpace between subplot rows. Applied to all rows.\nprint_grid (kwarg, True | False, default=False):\nIf True, prints a tab-delimited string representation\nof your plot grid.\nKeyword arguments with variable defaults:\nhorizontal_spacing (kwarg, float in [0,1], default=0.2 / columns):\nSpace between subplot columns.\nvertical_spacing (kwarg, float in [0,1], default=0.3 / rows):\nSpace between subplot rows.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "rows": {
          "type": "integer",
          "default": 1,
          "description": "类型从默认值推断: int"
        },
        "columns": {
          "type": "integer",
          "default": 1,
          "description": "类型从默认值推断: int"
        },
        "print_grid": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.get_subplots",
      "module": "plotly.tools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.tools.make_subplots": {
    "name": "plotly_tools_make_subplots",
    "description": "Return an instance of plotly.graph_objs.Figure\nwith the subplots domain set in 'layout'.\nExample 1:\n# stack two subplots vertically\nfig = tools.make_subplots(rows=2)\nThis is the format of your plot grid:\n[ (1,1) x1,y1 ]\n[ (2,1) x2,y2 ]\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2])]\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2], xaxis='x2', yaxis='y2')]\n# or see Figure.append_trace\nExample 2:\n# subplots with shared x axes\nfig = tools.make_subplots(rows=2, shared_xaxes=True)\nThis is the format of your plot grid:\n[ (1,1) x1,y1 ]\n[ (2,1) x1,y2 ]\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2])]\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2], yaxis='y2')]\nExample 3:\n# irregular subplot layout (more examples below under 'specs')\nfig = tools.make_subplots(rows=2, cols=2,\nspecs=[[{}, {}],\n[{'colspan': 2}, None]])\nThis is the format of your plot grid!\n[ (1,1) x1,y1 ]  [ (1,2) x2,y2 ]\n[ (2,1) x3,y3           -      ]\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2])]\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2], xaxis='x2', yaxis='y2')]\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2], xaxis='x3', yaxis='y3')]\nExample 4:\n# insets\nfig = tools.make_subplots(insets=[{'cell': (1,1), 'l': 0.7, 'b': 0.3}])\nThis is the format of your plot grid!\n[ (1,1) x1,y1 ]\nWith insets:\n[ x2,y2 ] over [ (1,1) x1,y1 ]\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2])]\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2], xaxis='x2', yaxis='y2')]\nExample 5:\n# include subplot titles\nfig = tools.make_subplots(rows=2, subplot_titles=('Plot 1','Plot 2'))\nThis is the format of your plot grid:\n[ (1,1) x1,y1 ]\n[ (2,1) x2,y2 ]\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2])]\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2], xaxis='x2', yaxis='y2')]\nExample 6:\n# Include subplot title on one plot (but not all)\nfig = tools.make_subplots(insets=[{'cell': (1,1), 'l': 0.7, 'b': 0.3}],\nsubplot_titles=('','Inset'))\nThis is the format of your plot grid!\n[ (1,1) x1,y1 ]\nWith insets:\n[ x2,y2 ] over [ (1,1) x1,y1 ]\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2])]\nfig['data'] += [Scatter(x=[1,2,3], y=[2,1,2], xaxis='x2', yaxis='y2')]\nKeywords arguments with constant defaults:\nrows (kwarg, int greater than 0, default=1):\nNumber of rows in the subplot grid.\ncols (kwarg, int greater than 0, default=1):\nNumber of columns in the subplot grid.\nshared_xaxes (kwarg, boolean or list, default=False)\nAssign shared x axes.\nIf True, subplots in the same grid column have one common\nshared x-axis at the bottom of the gird.\nTo assign shared x axes per subplot grid cell (see 'specs'),\nsend list (or list of lists, one list per shared x axis)\nof cell index tuples.\nshared_yaxes (kwarg, boolean or list, default=False)\nAssign shared y axes.\nIf True, subplots in the same grid row have one common\nshared y-axis on the left-hand side of the gird.\nTo assign shared y axes per subplot grid cell (see 'specs'),\nsend list (or list of lists, one list per shared y axis)\nof cell index tuples.\nstart_cell (kwarg, 'bottom-left' or 'top-left', default='top-left')\nChoose the starting cell in the subplot grid used to set the\ndomains of the subplots.\nprint_grid (kwarg, boolean, default=True):\nIf True, prints a tab-delimited string representation of\nyour plot grid.\nKeyword arguments with variable defaults:\nhorizontal_spacing (kwarg, float in [0,1], default=0.2 / cols):\nSpace between subplot columns.\nApplies to all columns (use 'specs' subplot-dependents spacing)\nvertical_spacing (kwarg, float in [0,1], default=0.3 / rows):\nSpace between subplot rows.\nApplies to all rows (use 'specs' subplot-dependents spacing)\nsubplot_titles (kwarg, list of strings, default=empty list):\nTitle of each subplot.\n\"\" can be included in the list if no subplot title is desired in\nthat space so that the titles are properly indexed.\nspecs (kwarg, list of lists of dictionaries):\nSubplot specifications.\nex1: specs=[[{}, {}], [{'colspan': 2}, None]]\nex2: specs=[[{'rowspan': 2}, {}], [None, {}]]\n- Indices of the outer list correspond to subplot grid rows\nstarting from the bottom. The number of rows in 'specs'\nmust be equal to 'rows'.\n- Indices of the inner lists correspond to subplot grid columns\nstarting from the left. The number of columns in 'specs'\nmust be equal to 'cols'.\n- Each item in the 'specs' list corresponds to one subplot\nin a subplot grid. (N.B. The subplot grid has exactly 'rows'\ntimes 'cols' cells.)\n- Use None for blank a subplot cell (or to move pass a col/row span).\n- Note that specs[0][0] has the specs of the 'start_cell' subplot.\n- Each item in 'specs' is a dictionary.\nThe available keys are:\n* is_3d (boolean, default=False): flag for 3d scenes\n* colspan (int, default=1): number of subplot columns\nfor this subplot to span.\n* rowspan (int, default=1): number of subplot rows\nfor this subplot to span.\n* l (float, default=0.0): padding left of cell\n* r (float, default=0.0): padding right of cell\n* t (float, default=0.0): padding right of cell\n* b (float, default=0.0): padding bottom of cell\n- Use 'horizontal_spacing' and 'vertical_spacing' to adjust\nthe spacing in between the subplots.\ninsets (kwarg, list of dictionaries):\nInset specifications.\n- Each item in 'insets' is a dictionary.\nThe available keys are:\n* cell (tuple, default=(1,1)): (row, col) index of the\nsubplot cell to overlay inset axes onto.\n* is_3d (boolean, default=False): flag for 3d scenes\n* l (float, default=0.0): padding left of inset\nin fraction of cell width\n* w (float or 'to_end', default='to_end') inset width\nin fraction of cell width ('to_end': to cell right edge)\n* b (float, default=0.0): padding bottom of inset\nin fraction of cell height\n* h (float or 'to_end', default='to_end') inset height\nin fraction of cell height ('to_end': to cell top edge)\ncolumn_width (kwarg, list of numbers)\nColumn_width specifications\n- Functions similarly to `column_width` of `plotly.graph_objs.Table`.\nSpecify a list that contains numbers where the amount of numbers in\nthe list is equal to `cols`.\n- The numbers in the list indicate the proportions that each column\ndomains take across the full horizontal domain excluding padding.\n- For example, if columns_width=[3, 1], horizontal_spacing=0, and\ncols=2, the domains for each column would be [0. 0.75] and [0.75, 1]\nrow_width (kwargs, list of numbers)\nRow_width specifications\n- Functions similarly to `column_width`. Specify a list that contains\nnumbers where the amount of numbers in the list is equal to `rows`.\n- The numbers in the list indicate the proportions that each row\ndomains take along the full vertical domain excluding padding.\n- For example, if row_width=[3, 1], vertical_spacing=0, and\ncols=2, the domains for each row from top to botton would be\n[0. 0.75] and [0.75, 1]",
    "inputSchema": {
      "type": "object",
      "properties": {
        "rows": {
          "type": "integer",
          "default": 1,
          "description": "类型从默认值推断: int"
        },
        "cols": {
          "type": "integer",
          "default": 1,
          "description": "类型从默认值推断: int"
        },
        "shared_xaxes": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "shared_yaxes": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "start_cell": {
          "type": "string",
          "default": "top-left",
          "description": "类型从默认值推断: str"
        },
        "print_grid": {
          "type": "integer",
          "description": "类型从参数名推断: print_grid"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.make_subplots",
      "module": "plotly.tools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.tools.mpl_to_plotly": {
    "name": "plotly_tools_mpl_to_plotly",
    "description": "Convert a matplotlib figure to plotly dictionary and send.\nAll available information about matplotlib visualizations are stored\nwithin a matplotlib.figure.Figure object. You can create a plot in python\nusing matplotlib, store the figure object, and then pass this object to\nthe fig_to_plotly function. In the background, mplexporter is used to\ncrawl through the mpl figure object for appropriate information. This\ninformation is then systematically sent to the PlotlyRenderer which\ncreates the JSON structure used to make plotly visualizations. Finally,\nthese dictionaries are sent to plotly and your browser should open up a\nnew tab for viewing! Optionally, if you're working in IPython, you can\nset notebook=True and the PlotlyRenderer will call plotly.iplot instead\nof plotly.plot to have the graph appear directly in the IPython notebook.\nNote, this function gives the user access to a simple, one-line way to\nrender an mpl figure in plotly. If you need to trouble shoot, you can do\nthis step manually by NOT running this fuction and entereing the following:\n===========================================================================\nfrom plotly.matplotlylib import mplexporter, PlotlyRenderer\n# create an mpl figure and store it under a varialble 'fig'\nrenderer = PlotlyRenderer()\nexporter = mplexporter.Exporter(renderer)\nexporter.run(fig)\n===========================================================================\nYou can then inspect the JSON structures by accessing these:\nrenderer.layout -- a plotly layout dictionary\nrenderer.data -- a list of plotly data dictionaries",
    "inputSchema": {
      "type": "object",
      "properties": {
        "fig": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "resize": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "strip_style": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        },
        "verbose": {
          "type": "integer",
          "default": false,
          "description": "类型从默认值推断: bool"
        }
      },
      "required": [
        "fig"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.mpl_to_plotly",
      "module": "plotly.tools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.tools.return_figure_from_figure_or_data": {
    "name": "plotly_tools_return_figure_from_figure_or_data",
    "description": "执行return_figure_from_figure_or_data操作（plotly.tools模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "figure_or_data": {
          "type": "object",
          "description": "类型从参数名推断: figure_or_data"
        },
        "validate_figure": {
          "type": "integer",
          "description": "类型从参数名推断: validate_figure"
        }
      },
      "required": [
        "figure_or_data",
        "validate_figure"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.return_figure_from_figure_or_data",
      "module": "plotly.tools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.tools.warning_on_one_line": {
    "name": "plotly_tools_warning_on_one_line",
    "description": "执行warning_on_one_line操作（plotly.tools模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "category": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "filename": {
          "type": "string",
          "description": "类型从参数名推断: filename"
        },
        "lineno": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "file": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "line": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "message",
        "category",
        "filename",
        "lineno"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.warning_on_one_line",
      "module": "plotly.tools",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.tools.FigureFactory.create_2D_density": {
    "name": "plotly_tools_FigureFactory_create_2D_density",
    "description": "创建数据（FigureFactory类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.FigureFactory.create_2D_density",
      "module": "plotly.tools",
      "class_name": "FigureFactory",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.tools.FigureFactory.create_annotated_heatmap": {
    "name": "plotly_tools_FigureFactory_create_annotated_heatmap",
    "description": "创建数据（FigureFactory类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.FigureFactory.create_annotated_heatmap",
      "module": "plotly.tools",
      "class_name": "FigureFactory",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.tools.FigureFactory.create_candlestick": {
    "name": "plotly_tools_FigureFactory_create_candlestick",
    "description": "创建数据（FigureFactory类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.FigureFactory.create_candlestick",
      "module": "plotly.tools",
      "class_name": "FigureFactory",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.tools.FigureFactory.create_dendrogram": {
    "name": "plotly_tools_FigureFactory_create_dendrogram",
    "description": "创建数据（FigureFactory类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.FigureFactory.create_dendrogram",
      "module": "plotly.tools",
      "class_name": "FigureFactory",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.tools.FigureFactory.create_distplot": {
    "name": "plotly_tools_FigureFactory_create_distplot",
    "description": "创建数据（FigureFactory类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.FigureFactory.create_distplot",
      "module": "plotly.tools",
      "class_name": "FigureFactory",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.tools.FigureFactory.create_facet_grid": {
    "name": "plotly_tools_FigureFactory_create_facet_grid",
    "description": "创建数据（FigureFactory类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.FigureFactory.create_facet_grid",
      "module": "plotly.tools",
      "class_name": "FigureFactory",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.tools.FigureFactory.create_gantt": {
    "name": "plotly_tools_FigureFactory_create_gantt",
    "description": "创建数据（FigureFactory类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.FigureFactory.create_gantt",
      "module": "plotly.tools",
      "class_name": "FigureFactory",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.tools.FigureFactory.create_ohlc": {
    "name": "plotly_tools_FigureFactory_create_ohlc",
    "description": "创建数据（FigureFactory类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.FigureFactory.create_ohlc",
      "module": "plotly.tools",
      "class_name": "FigureFactory",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.tools.FigureFactory.create_quiver": {
    "name": "plotly_tools_FigureFactory_create_quiver",
    "description": "创建数据（FigureFactory类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.FigureFactory.create_quiver",
      "module": "plotly.tools",
      "class_name": "FigureFactory",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.tools.FigureFactory.create_scatterplotmatrix": {
    "name": "plotly_tools_FigureFactory_create_scatterplotmatrix",
    "description": "创建数据（FigureFactory类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.FigureFactory.create_scatterplotmatrix",
      "module": "plotly.tools",
      "class_name": "FigureFactory",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.tools.FigureFactory.create_streamline": {
    "name": "plotly_tools_FigureFactory_create_streamline",
    "description": "创建数据（FigureFactory类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.FigureFactory.create_streamline",
      "module": "plotly.tools",
      "class_name": "FigureFactory",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.tools.FigureFactory.create_table": {
    "name": "plotly_tools_FigureFactory_create_table",
    "description": "创建数据（FigureFactory类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.FigureFactory.create_table",
      "module": "plotly.tools",
      "class_name": "FigureFactory",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.tools.FigureFactory.create_trisurf": {
    "name": "plotly_tools_FigureFactory_create_trisurf",
    "description": "创建数据（FigureFactory类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.FigureFactory.create_trisurf",
      "module": "plotly.tools",
      "class_name": "FigureFactory",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.tools.FigureFactory.create_violin": {
    "name": "plotly_tools_FigureFactory_create_violin",
    "description": "创建数据（FigureFactory类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "args": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "kwargs": {
          "type": "object",
          "description": "类型从参数名推断: kwargs"
        }
      },
      "required": [
        "args",
        "kwargs"
      ]
    },
    "metadata": {
      "source_function": "plotly.tools.FigureFactory.create_violin",
      "module": "plotly.tools",
      "class_name": "FigureFactory",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.utils.decode_unicode": {
    "name": "plotly_utils_decode_unicode",
    "description": "执行decode_unicode操作（plotly.utils模块的函数）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "coll": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "coll"
      ]
    },
    "metadata": {
      "source_function": "plotly.utils.decode_unicode",
      "module": "plotly.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.utils.get_by_path": {
    "name": "plotly_utils_get_by_path",
    "description": "Iteratively get on obj for each key in path.\n\n\n\nExample:\n\n>>> figure = {'data': [{'x': [5]}]}\n>>> path = ('data', 0, 'x')\n>>> get_by_path(figure, path)\n[5]",
    "inputSchema": {
      "type": "object",
      "properties": {
        "obj": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "path": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "obj",
        "path"
      ]
    },
    "metadata": {
      "source_function": "plotly.utils.get_by_path",
      "module": "plotly.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.utils.node_generator": {
    "name": "plotly_utils_node_generator",
    "description": "General, node-yielding generator.\n\nYields (node, path) tuples when it finds values that are dict\ninstances.\n\nA path is a sequence of hashable values that can be used as either keys to\na mapping (dict) or indices to a sequence (list). A path is always wrt to\nsome object. Given an object, a path explains how to get from the top level\nof that object to a nested value in the object.\n\n\nExample:\n\n>>> for node, path in node_generator({'a': {'b': 5}}):\n...     print(node, path)\n{'a': {'b': 5}} ()\n{'b': 5} ('a',)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "node": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "path": {
          "type": "string",
          "default": "()",
          "description": "类型从默认值推断: tuple"
        }
      },
      "required": [
        "node"
      ]
    },
    "metadata": {
      "source_function": "plotly.utils.node_generator",
      "module": "plotly.utils",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.utils.ElidedPrettyPrinter.format": {
    "name": "plotly_utils_ElidedPrettyPrinter_format",
    "description": "Format object for a specific context, returning a string\nand flags indicating whether the representation is 'readable'\nand whether the object represents a recursive construct.",
    "inputSchema": {
      "type": "object",
      "properties": {
        "object": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "context": {
          "type": "string",
          "description": "类型从参数名推断: context"
        },
        "maxlevels": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "level": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "object",
        "context",
        "maxlevels",
        "level"
      ]
    },
    "metadata": {
      "source_function": "plotly.utils.ElidedPrettyPrinter.format",
      "module": "plotly.utils",
      "class_name": "ElidedPrettyPrinter",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.utils.ElidedPrettyPrinter.isreadable": {
    "name": "plotly_utils_ElidedPrettyPrinter_isreadable",
    "description": "执行isreadable操作（ElidedPrettyPrinter类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "object": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "object"
      ]
    },
    "metadata": {
      "source_function": "plotly.utils.ElidedPrettyPrinter.isreadable",
      "module": "plotly.utils",
      "class_name": "ElidedPrettyPrinter",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.utils.ElidedPrettyPrinter.isrecursive": {
    "name": "plotly_utils_ElidedPrettyPrinter_isrecursive",
    "description": "执行isrecursive操作（ElidedPrettyPrinter类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "object": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "object"
      ]
    },
    "metadata": {
      "source_function": "plotly.utils.ElidedPrettyPrinter.isrecursive",
      "module": "plotly.utils",
      "class_name": "ElidedPrettyPrinter",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.utils.ElidedPrettyPrinter.pformat": {
    "name": "plotly_utils_ElidedPrettyPrinter_pformat",
    "description": "执行pformat操作（ElidedPrettyPrinter类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "object": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "object"
      ]
    },
    "metadata": {
      "source_function": "plotly.utils.ElidedPrettyPrinter.pformat",
      "module": "plotly.utils",
      "class_name": "ElidedPrettyPrinter",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.utils.ElidedPrettyPrinter.pprint": {
    "name": "plotly_utils_ElidedPrettyPrinter_pprint",
    "description": "执行pprint操作（ElidedPrettyPrinter类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "object": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "object"
      ]
    },
    "metadata": {
      "source_function": "plotly.utils.ElidedPrettyPrinter.pprint",
      "module": "plotly.utils",
      "class_name": "ElidedPrettyPrinter",
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  },
  "plotly.utils.ElidedWrapper.is_wrappable": {
    "name": "plotly_utils_ElidedWrapper_is_wrappable",
    "description": "执行is_wrappable操作（ElidedWrapper类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "v": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        }
      },
      "required": [
        "v"
      ]
    },
    "metadata": {
      "source_function": "plotly.utils.ElidedWrapper.is_wrappable",
      "module": "plotly.utils",
      "class_name": "ElidedWrapper",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    },
    "outputSchema": {
      "type": "boolean"
    }
  },
  "plotly.validator_cache.ValidatorCache.get_validator": {
    "name": "plotly_validator_cache_ValidatorCache_get_validator",
    "description": "获取数据（ValidatorCache类的方法）",
    "inputSchema": {
      "type": "object",
      "properties": {
        "parent_path": {
          "type": "string",
          "description": "未知类型，默认为字符串"
        },
        "prop_name": {
          "type": "string",
          "description": "类型从参数名推断: prop_name"
        }
      },
      "required": [
        "parent_path",
        "prop_name"
      ]
    },
    "metadata": {
      "source_function": "plotly.validator_cache.ValidatorCache.get_validator",
      "module": "plotly.validator_cache",
      "class_name": "ValidatorCache",
      "is_async": false,
      "is_static": true,
      "is_classmethod": false
    }
  },
  "plotly.version.stable_semver": {
    "name": "plotly_version_stable_semver",
    "description": "Get the stable portion of the semantic version string (the first three\nnumbers), without any of the trailing labels\n'3.0.0rc11' -> '3.0.0'",
    "inputSchema": {
      "type": "object",
      "properties": {},
      "required": []
    },
    "metadata": {
      "source_function": "plotly.version.stable_semver",
      "module": "plotly.version",
      "class_name": null,
      "is_async": false,
      "is_static": false,
      "is_classmethod": false
    }
  }
}